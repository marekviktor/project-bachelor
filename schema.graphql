"""The root query type which gives access points into the data universe."""
type Query implements Node {
  """
  Exposes the root query type nested one level down. This is helpful for Relay 1
  which can only query top level fields if they are in a particular form.
  """
  query: Query!

  """
  The root query type must be a `Node` to work well with Relay 1 mutations. This just resolves to `query`.
  """
  nodeId: ID!

  """Fetches an object given its globally unique `ID`."""
  node(
    """The globally unique `ID`."""
    nodeId: ID!
  ): Node

  """Reads and enables pagination through a set of `Admin`."""
  admins(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Admin`."""
    orderBy: [AdminsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: AdminCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: AdminFilter
  ): AdminsConnection

  """
  Reads and enables pagination through a set of `AdminMedicamentDescription`.
  """
  adminMedicamentDescriptions(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `AdminMedicamentDescription`."""
    orderBy: [AdminMedicamentDescriptionsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: AdminMedicamentDescriptionCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: AdminMedicamentDescriptionFilter
  ): AdminMedicamentDescriptionsConnection

  """Reads and enables pagination through a set of `Ambulance`."""
  ambulances(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Ambulance`."""
    orderBy: [AmbulancesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: AmbulanceCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: AmbulanceFilter
  ): AmbulancesConnection

  """Reads and enables pagination through a set of `AmbulanceUser`."""
  ambulanceUsers(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `AmbulanceUser`."""
    orderBy: [AmbulanceUsersOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: AmbulanceUserCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: AmbulanceUserFilter
  ): AmbulanceUsersConnection

  """Reads and enables pagination through a set of `BloodCount`."""
  bloodCounts(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `BloodCount`."""
    orderBy: [BloodCountsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: BloodCountCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: BloodCountFilter
  ): BloodCountsConnection

  """Reads and enables pagination through a set of `BloodCountUser`."""
  bloodCountUsers(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `BloodCountUser`."""
    orderBy: [BloodCountUsersOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: BloodCountUserCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: BloodCountUserFilter
  ): BloodCountUsersConnection

  """Reads and enables pagination through a set of `BloodCountUserValue`."""
  bloodCountUserValues(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `BloodCountUserValue`."""
    orderBy: [BloodCountUserValuesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: BloodCountUserValueCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: BloodCountUserValueFilter
  ): BloodCountUserValuesConnection

  """Reads and enables pagination through a set of `BloodType`."""
  bloodTypes(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `BloodType`."""
    orderBy: [BloodTypesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: BloodTypeCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: BloodTypeFilter
  ): BloodTypesConnection

  """Reads and enables pagination through a set of `City`."""
  cities(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `City`."""
    orderBy: [CitiesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CityCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: CityFilter
  ): CitiesConnection

  """Reads and enables pagination through a set of `Diagnosis`."""
  diagnoses(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Diagnosis`."""
    orderBy: [DiagnosesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: DiagnosisCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: DiagnosisFilter
  ): DiagnosesConnection

  """Reads and enables pagination through a set of `DiagnosisCategory`."""
  diagnosisCategories(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `DiagnosisCategory`."""
    orderBy: [DiagnosisCategoriesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: DiagnosisCategoryCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: DiagnosisCategoryFilter
  ): DiagnosisCategoriesConnection

  """Reads and enables pagination through a set of `DiagnosisGroup`."""
  diagnosisGroups(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `DiagnosisGroup`."""
    orderBy: [DiagnosisGroupsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: DiagnosisGroupCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: DiagnosisGroupFilter
  ): DiagnosisGroupsConnection

  """Reads and enables pagination through a set of `InsuranceCompany`."""
  insuranceCompanies(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `InsuranceCompany`."""
    orderBy: [InsuranceCompaniesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: InsuranceCompanyCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: InsuranceCompanyFilter
  ): InsuranceCompaniesConnection

  """Reads and enables pagination through a set of `Medicament`."""
  medicaments(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Medicament`."""
    orderBy: [MedicamentsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: MedicamentCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: MedicamentFilter
  ): MedicamentsConnection

  """Reads and enables pagination through a set of `Meeting`."""
  meetings(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Meeting`."""
    orderBy: [MeetingsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: MeetingCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: MeetingFilter
  ): MeetingsConnection

  """Reads and enables pagination through a set of `MeetingHour`."""
  meetingHours(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `MeetingHour`."""
    orderBy: [MeetingHoursOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: MeetingHourCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: MeetingHourFilter
  ): MeetingHoursConnection

  """Reads and enables pagination through a set of `Ref`."""
  refs(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Ref`."""
    orderBy: [RefsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: RefCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: RefFilter
  ): RefsConnection

  """Reads and enables pagination through a set of `RefRange`."""
  refRanges(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `RefRange`."""
    orderBy: [RefRangesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: RefRangeCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: RefRangeFilter
  ): RefRangesConnection

  """Reads and enables pagination through a set of `Region`."""
  regions(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Region`."""
    orderBy: [RegionsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: RegionCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: RegionFilter
  ): RegionsConnection

  """Reads and enables pagination through a set of `Specialization`."""
  specializations(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Specialization`."""
    orderBy: [SpecializationsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: SpecializationCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: SpecializationFilter
  ): SpecializationsConnection

  """Reads and enables pagination through a set of `User`."""
  users(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `User`."""
    orderBy: [UsersOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: UserCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: UserFilter
  ): UsersConnection

  """Reads and enables pagination through a set of `UserDiagnosis`."""
  userDiagnoses(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `UserDiagnosis`."""
    orderBy: [UserDiagnosesOrderBy!] = [NATURAL]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: UserDiagnosisCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: UserDiagnosisFilter
  ): UserDiagnosesConnection

  """Reads and enables pagination through a set of `UserMedicament`."""
  userMedicaments(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `UserMedicament`."""
    orderBy: [UserMedicamentsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: UserMedicamentCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: UserMedicamentFilter
  ): UserMedicamentsConnection

  """Reads and enables pagination through a set of `UserMedicamentDay`."""
  userMedicamentDays(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `UserMedicamentDay`."""
    orderBy: [UserMedicamentDaysOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: UserMedicamentDayCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: UserMedicamentDayFilter
  ): UserMedicamentDaysConnection

  """Reads and enables pagination through a set of `UserMedicamentTime`."""
  userMedicamentTimes(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `UserMedicamentTime`."""
    orderBy: [UserMedicamentTimesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: UserMedicamentTimeCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: UserMedicamentTimeFilter
  ): UserMedicamentTimesConnection
  admin(id: Int!): Admin
  adminMedicamentDescription(id: Int!): AdminMedicamentDescription
  ambulance(id: Int!): Ambulance
  ambulanceUser(id: Int!): AmbulanceUser
  ambulanceUserByUserIdAndAmbulanceId(userId: Int!, ambulanceId: Int!): AmbulanceUser
  bloodCount(id: Int!): BloodCount
  bloodCountUser(id: Int!): BloodCountUser
  bloodCountUserByUserIdAndBloodCountId(userId: Int!, bloodCountId: Int!): BloodCountUser
  bloodCountUserValue(id: Int!): BloodCountUserValue
  bloodType(id: Int!): BloodType
  city(id: Int!): City
  diagnosis(id: String!): Diagnosis
  diagnosisCategory(id: String!): DiagnosisCategory
  diagnosisGroup(id: String!): DiagnosisGroup
  insuranceCompany(id: Int!): InsuranceCompany
  medicament(id: Int!): Medicament
  meeting(id: Int!): Meeting
  meetingByMeetingDateAndUserIdAndAdminId(meetingDate: Date!, userId: Int!, adminId: Int!): Meeting
  meetingByAdminIdAndMeetingTimeAndMeetingDate(adminId: Int!, meetingTime: Time!, meetingDate: Date!): Meeting
  meetingHour(id: Int!): MeetingHour
  ref(id: Int!): Ref
  refRange(id: Int!): RefRange
  region(id: Int!): Region
  specialization(id: Int!): Specialization
  user(id: Int!): User
  userMedicament(id: Int!): UserMedicament
  userMedicamentDay(id: Int!): UserMedicamentDay
  userMedicamentTime(id: Int!): UserMedicamentTime
  userMedicamentTimeByUserMedicamentIdAndTime(userMedicamentId: Int!, time: Time!): UserMedicamentTime

  """Reads a single `Admin` using its globally unique `ID`."""
  adminByNodeId(
    """The globally unique `ID` to be used in selecting a single `Admin`."""
    nodeId: ID!
  ): Admin

  """
  Reads a single `AdminMedicamentDescription` using its globally unique `ID`.
  """
  adminMedicamentDescriptionByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `AdminMedicamentDescription`.
    """
    nodeId: ID!
  ): AdminMedicamentDescription

  """Reads a single `Ambulance` using its globally unique `ID`."""
  ambulanceByNodeId(
    """The globally unique `ID` to be used in selecting a single `Ambulance`."""
    nodeId: ID!
  ): Ambulance

  """Reads a single `AmbulanceUser` using its globally unique `ID`."""
  ambulanceUserByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `AmbulanceUser`.
    """
    nodeId: ID!
  ): AmbulanceUser

  """Reads a single `BloodCount` using its globally unique `ID`."""
  bloodCountByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `BloodCount`.
    """
    nodeId: ID!
  ): BloodCount

  """Reads a single `BloodCountUser` using its globally unique `ID`."""
  bloodCountUserByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `BloodCountUser`.
    """
    nodeId: ID!
  ): BloodCountUser

  """Reads a single `BloodCountUserValue` using its globally unique `ID`."""
  bloodCountUserValueByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `BloodCountUserValue`.
    """
    nodeId: ID!
  ): BloodCountUserValue

  """Reads a single `BloodType` using its globally unique `ID`."""
  bloodTypeByNodeId(
    """The globally unique `ID` to be used in selecting a single `BloodType`."""
    nodeId: ID!
  ): BloodType

  """Reads a single `City` using its globally unique `ID`."""
  cityByNodeId(
    """The globally unique `ID` to be used in selecting a single `City`."""
    nodeId: ID!
  ): City

  """Reads a single `Diagnosis` using its globally unique `ID`."""
  diagnosisByNodeId(
    """The globally unique `ID` to be used in selecting a single `Diagnosis`."""
    nodeId: ID!
  ): Diagnosis

  """Reads a single `DiagnosisCategory` using its globally unique `ID`."""
  diagnosisCategoryByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `DiagnosisCategory`.
    """
    nodeId: ID!
  ): DiagnosisCategory

  """Reads a single `DiagnosisGroup` using its globally unique `ID`."""
  diagnosisGroupByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `DiagnosisGroup`.
    """
    nodeId: ID!
  ): DiagnosisGroup

  """Reads a single `InsuranceCompany` using its globally unique `ID`."""
  insuranceCompanyByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `InsuranceCompany`.
    """
    nodeId: ID!
  ): InsuranceCompany

  """Reads a single `Medicament` using its globally unique `ID`."""
  medicamentByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `Medicament`.
    """
    nodeId: ID!
  ): Medicament

  """Reads a single `Meeting` using its globally unique `ID`."""
  meetingByNodeId(
    """The globally unique `ID` to be used in selecting a single `Meeting`."""
    nodeId: ID!
  ): Meeting

  """Reads a single `MeetingHour` using its globally unique `ID`."""
  meetingHourByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `MeetingHour`.
    """
    nodeId: ID!
  ): MeetingHour

  """Reads a single `Ref` using its globally unique `ID`."""
  refByNodeId(
    """The globally unique `ID` to be used in selecting a single `Ref`."""
    nodeId: ID!
  ): Ref

  """Reads a single `RefRange` using its globally unique `ID`."""
  refRangeByNodeId(
    """The globally unique `ID` to be used in selecting a single `RefRange`."""
    nodeId: ID!
  ): RefRange

  """Reads a single `Region` using its globally unique `ID`."""
  regionByNodeId(
    """The globally unique `ID` to be used in selecting a single `Region`."""
    nodeId: ID!
  ): Region

  """Reads a single `Specialization` using its globally unique `ID`."""
  specializationByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `Specialization`.
    """
    nodeId: ID!
  ): Specialization

  """Reads a single `User` using its globally unique `ID`."""
  userByNodeId(
    """The globally unique `ID` to be used in selecting a single `User`."""
    nodeId: ID!
  ): User

  """Reads a single `UserMedicament` using its globally unique `ID`."""
  userMedicamentByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `UserMedicament`.
    """
    nodeId: ID!
  ): UserMedicament

  """Reads a single `UserMedicamentDay` using its globally unique `ID`."""
  userMedicamentDayByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `UserMedicamentDay`.
    """
    nodeId: ID!
  ): UserMedicamentDay

  """Reads a single `UserMedicamentTime` using its globally unique `ID`."""
  userMedicamentTimeByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `UserMedicamentTime`.
    """
    nodeId: ID!
  ): UserMedicamentTime
}

"""An object with a globally unique `ID`."""
interface Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
}

"""A connection to a list of `Admin` values."""
type AdminsConnection {
  """A list of `Admin` objects."""
  nodes: [Admin]!

  """
  A list of edges which contains the `Admin` and cursor to aid in pagination.
  """
  edges: [AdminsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Admin` you could get from the connection."""
  totalCount: Int!
}

type Admin implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: Int!
  firstName: String!
  lastName: String!
  ambulanceId: Int
  adminVerified: Boolean
  registrationDate: Date
  email: String
  phone: String
  lastLogin: Date
  interval: Int!

  """Reads a single `Ambulance` that is related to this `Admin`."""
  ambulance: Ambulance

  """Reads and enables pagination through a set of `Meeting`."""
  meetings(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Meeting`."""
    orderBy: [MeetingsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: MeetingCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: MeetingFilter
  ): MeetingsConnection!

  """Reads and enables pagination through a set of `UserMedicament`."""
  userMedicaments(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `UserMedicament`."""
    orderBy: [UserMedicamentsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: UserMedicamentCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: UserMedicamentFilter
  ): UserMedicamentsConnection!

  """
  Reads and enables pagination through a set of `AdminMedicamentDescription`.
  """
  adminMedicamentDescriptions(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `AdminMedicamentDescription`."""
    orderBy: [AdminMedicamentDescriptionsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: AdminMedicamentDescriptionCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: AdminMedicamentDescriptionFilter
  ): AdminMedicamentDescriptionsConnection!

  """Reads and enables pagination through a set of `MeetingHour`."""
  meetingHours(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `MeetingHour`."""
    orderBy: [MeetingHoursOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: MeetingHourCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: MeetingHourFilter
  ): MeetingHoursConnection!

  """Reads and enables pagination through a set of `User`."""
  usersByMeetingAdminIdAndUserId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `User`."""
    orderBy: [UsersOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: UserCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: UserFilter
  ): AdminUsersByMeetingAdminIdAndUserIdManyToManyConnection!

  """Reads and enables pagination through a set of `Ambulance`."""
  ambulancesByMeetingAdminIdAndAmbulanceId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Ambulance`."""
    orderBy: [AmbulancesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: AmbulanceCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: AmbulanceFilter
  ): AdminAmbulancesByMeetingAdminIdAndAmbulanceIdManyToManyConnection!

  """Reads and enables pagination through a set of `User`."""
  usersByUserMedicamentAdminIdAndUserId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `User`."""
    orderBy: [UsersOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: UserCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: UserFilter
  ): AdminUsersByUserMedicamentAdminIdAndUserIdManyToManyConnection!

  """Reads and enables pagination through a set of `Medicament`."""
  medicamentsByUserMedicamentAdminIdAndMedicamentId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Medicament`."""
    orderBy: [MedicamentsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: MedicamentCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: MedicamentFilter
  ): AdminMedicamentsByUserMedicamentAdminIdAndMedicamentIdManyToManyConnection!

  """Reads and enables pagination through a set of `UserMedicamentDay`."""
  userMedicamentDaysByUserMedicamentAdminIdAndUserMedicamentDayId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `UserMedicamentDay`."""
    orderBy: [UserMedicamentDaysOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: UserMedicamentDayCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: UserMedicamentDayFilter
  ): AdminUserMedicamentDaysByUserMedicamentAdminIdAndUserMedicamentDayIdManyToManyConnection!

  """Reads and enables pagination through a set of `Medicament`."""
  medicamentsByAdminMedicamentDescriptionAdminIdAndMedicamentId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Medicament`."""
    orderBy: [MedicamentsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: MedicamentCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: MedicamentFilter
  ): AdminMedicamentsByAdminMedicamentDescriptionAdminIdAndMedicamentIdManyToManyConnection!

  """Reads and enables pagination through a set of `Ambulance`."""
  ambulancesByMeetingHourAdminIdAndAmbulanceId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Ambulance`."""
    orderBy: [AmbulancesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: AmbulanceCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: AmbulanceFilter
  ): AdminAmbulancesByMeetingHourAdminIdAndAmbulanceIdManyToManyConnection!
}

"""The day, does not include a time."""
scalar Date

type Ambulance implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: Int!
  name: String!
  ico: String
  cityId: Int!
  street: String!
  state: String!
  suite: String!
  email: String!

  """Reads a single `City` that is related to this `Ambulance`."""
  city: City

  """Reads and enables pagination through a set of `Admin`."""
  admins(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Admin`."""
    orderBy: [AdminsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: AdminCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: AdminFilter
  ): AdminsConnection!

  """Reads and enables pagination through a set of `Meeting`."""
  meetings(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Meeting`."""
    orderBy: [MeetingsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: MeetingCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: MeetingFilter
  ): MeetingsConnection!

  """Reads and enables pagination through a set of `AmbulanceUser`."""
  ambulanceUsers(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `AmbulanceUser`."""
    orderBy: [AmbulanceUsersOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: AmbulanceUserCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: AmbulanceUserFilter
  ): AmbulanceUsersConnection!

  """Reads and enables pagination through a set of `MeetingHour`."""
  meetingHours(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `MeetingHour`."""
    orderBy: [MeetingHoursOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: MeetingHourCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: MeetingHourFilter
  ): MeetingHoursConnection!

  """Reads and enables pagination through a set of `User`."""
  usersByMeetingAmbulanceIdAndUserId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `User`."""
    orderBy: [UsersOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: UserCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: UserFilter
  ): AmbulanceUsersByMeetingAmbulanceIdAndUserIdManyToManyConnection!

  """Reads and enables pagination through a set of `Admin`."""
  adminsByMeetingAmbulanceIdAndAdminId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Admin`."""
    orderBy: [AdminsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: AdminCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: AdminFilter
  ): AmbulanceAdminsByMeetingAmbulanceIdAndAdminIdManyToManyConnection!

  """Reads and enables pagination through a set of `User`."""
  usersByAmbulanceUserAmbulanceIdAndUserId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `User`."""
    orderBy: [UsersOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: UserCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: UserFilter
  ): AmbulanceUsersByAmbulanceUserAmbulanceIdAndUserIdManyToManyConnection!

  """Reads and enables pagination through a set of `Admin`."""
  adminsByMeetingHourAmbulanceIdAndAdminId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Admin`."""
    orderBy: [AdminsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: AdminCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: AdminFilter
  ): AmbulanceAdminsByMeetingHourAmbulanceIdAndAdminIdManyToManyConnection!
}

type City implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: Int!
  name: String
  country: String
  iso: String
  regionId: Int
  type: String

  """Reads a single `Region` that is related to this `City`."""
  region: Region

  """Reads and enables pagination through a set of `Ambulance`."""
  ambulances(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Ambulance`."""
    orderBy: [AmbulancesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: AmbulanceCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: AmbulanceFilter
  ): AmbulancesConnection!
}

type Region implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: Int!
  region: String!

  """Reads and enables pagination through a set of `City`."""
  cities(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `City`."""
    orderBy: [CitiesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CityCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: CityFilter
  ): CitiesConnection!
}

"""A connection to a list of `City` values."""
type CitiesConnection {
  """A list of `City` objects."""
  nodes: [City]!

  """
  A list of edges which contains the `City` and cursor to aid in pagination.
  """
  edges: [CitiesEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `City` you could get from the connection."""
  totalCount: Int!
}

"""A `City` edge in the connection."""
type CitiesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `City` at the end of the edge."""
  node: City
}

"""A location in a connection that can be used for resuming pagination."""
scalar Cursor

"""Information about pagination in a connection."""
type PageInfo {
  """When paginating forwards, are there more items?"""
  hasNextPage: Boolean!

  """When paginating backwards, are there more items?"""
  hasPreviousPage: Boolean!

  """When paginating backwards, the cursor to continue."""
  startCursor: Cursor

  """When paginating forwards, the cursor to continue."""
  endCursor: Cursor
}

"""Methods to use when ordering `City`."""
enum CitiesOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  NAME_ASC
  NAME_DESC
  COUNTRY_ASC
  COUNTRY_DESC
  ISO_ASC
  ISO_DESC
  REGION_ID_ASC
  REGION_ID_DESC
  TYPE_ASC
  TYPE_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `City` object types. All fields are tested for equality and combined with a logical and.
"""
input CityCondition {
  """Checks for equality with the objects `id` field."""
  id: Int

  """Checks for equality with the objects `name` field."""
  name: String

  """Checks for equality with the objects `country` field."""
  country: String

  """Checks for equality with the objects `iso` field."""
  iso: String

  """Checks for equality with the objects `regionId` field."""
  regionId: Int

  """Checks for equality with the objects `type` field."""
  type: String
}

"""
A filter to be used against `City` object types. All fields are combined with a logical and.
"""
input CityFilter {
  """Filter by the objects `id` field."""
  id: IntFilter

  """Filter by the objects `name` field."""
  name: StringFilter

  """Filter by the objects `country` field."""
  country: StringFilter

  """Filter by the objects `iso` field."""
  iso: StringFilter

  """Filter by the objects `regionId` field."""
  regionId: IntFilter

  """Filter by the objects `type` field."""
  type: StringFilter

  """Checks for all expressions in this list."""
  and: [CityFilter!]

  """Checks for any expressions in this list."""
  or: [CityFilter!]

  """Negates the expression."""
  not: CityFilter
}

"""
A filter to be used against Int fields. All fields are combined with a logical and.
"""
input IntFilter {
  """
  Is null (if `true` is specified) or is not null (if `false` is specified).
  """
  isNull: Boolean

  """Equal to the specified value."""
  equalTo: Int

  """Not equal to the specified value."""
  notEqualTo: Int

  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: Int

  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: Int

  """Included in the specified list."""
  in: [Int!]

  """Not included in the specified list."""
  notIn: [Int!]

  """Less than the specified value."""
  lessThan: Int

  """Less than or equal to the specified value."""
  lessThanOrEqualTo: Int

  """Greater than the specified value."""
  greaterThan: Int

  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: Int
}

"""
A filter to be used against String fields. All fields are combined with a logical and.
"""
input StringFilter {
  """
  Is null (if `true` is specified) or is not null (if `false` is specified).
  """
  isNull: Boolean

  """Equal to the specified value."""
  equalTo: String

  """Not equal to the specified value."""
  notEqualTo: String

  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: String

  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: String

  """Included in the specified list."""
  in: [String!]

  """Not included in the specified list."""
  notIn: [String!]

  """Less than the specified value."""
  lessThan: String

  """Less than or equal to the specified value."""
  lessThanOrEqualTo: String

  """Greater than the specified value."""
  greaterThan: String

  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: String

  """Contains the specified string (case-sensitive)."""
  includes: String

  """Does not contain the specified string (case-sensitive)."""
  notIncludes: String

  """Contains the specified string (case-insensitive)."""
  includesInsensitive: String

  """Does not contain the specified string (case-insensitive)."""
  notIncludesInsensitive: String

  """Starts with the specified string (case-sensitive)."""
  startsWith: String

  """Does not start with the specified string (case-sensitive)."""
  notStartsWith: String

  """Starts with the specified string (case-insensitive)."""
  startsWithInsensitive: String

  """Does not start with the specified string (case-insensitive)."""
  notStartsWithInsensitive: String

  """Ends with the specified string (case-sensitive)."""
  endsWith: String

  """Does not end with the specified string (case-sensitive)."""
  notEndsWith: String

  """Ends with the specified string (case-insensitive)."""
  endsWithInsensitive: String

  """Does not end with the specified string (case-insensitive)."""
  notEndsWithInsensitive: String

  """
  Matches the specified pattern (case-sensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters.
  """
  like: String

  """
  Does not match the specified pattern (case-sensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters.
  """
  notLike: String

  """
  Matches the specified pattern (case-insensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters.
  """
  likeInsensitive: String

  """
  Does not match the specified pattern (case-insensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters.
  """
  notLikeInsensitive: String

  """Equal to the specified value (case-insensitive)."""
  equalToInsensitive: String

  """Not equal to the specified value (case-insensitive)."""
  notEqualToInsensitive: String

  """
  Not equal to the specified value, treating null like an ordinary value (case-insensitive).
  """
  distinctFromInsensitive: String

  """
  Equal to the specified value, treating null like an ordinary value (case-insensitive).
  """
  notDistinctFromInsensitive: String

  """Included in the specified list (case-insensitive)."""
  inInsensitive: [String!]

  """Not included in the specified list (case-insensitive)."""
  notInInsensitive: [String!]

  """Less than the specified value (case-insensitive)."""
  lessThanInsensitive: String

  """Less than or equal to the specified value (case-insensitive)."""
  lessThanOrEqualToInsensitive: String

  """Greater than the specified value (case-insensitive)."""
  greaterThanInsensitive: String

  """Greater than or equal to the specified value (case-insensitive)."""
  greaterThanOrEqualToInsensitive: String
}

"""A connection to a list of `Ambulance` values."""
type AmbulancesConnection {
  """A list of `Ambulance` objects."""
  nodes: [Ambulance]!

  """
  A list of edges which contains the `Ambulance` and cursor to aid in pagination.
  """
  edges: [AmbulancesEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Ambulance` you could get from the connection."""
  totalCount: Int!
}

"""A `Ambulance` edge in the connection."""
type AmbulancesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Ambulance` at the end of the edge."""
  node: Ambulance
}

"""Methods to use when ordering `Ambulance`."""
enum AmbulancesOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  NAME_ASC
  NAME_DESC
  ICO_ASC
  ICO_DESC
  CITY_ID_ASC
  CITY_ID_DESC
  STREET_ASC
  STREET_DESC
  STATE_ASC
  STATE_DESC
  SUITE_ASC
  SUITE_DESC
  EMAIL_ASC
  EMAIL_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Ambulance` object types. All fields are tested
for equality and combined with a logical and.
"""
input AmbulanceCondition {
  """Checks for equality with the objects `id` field."""
  id: Int

  """Checks for equality with the objects `name` field."""
  name: String

  """Checks for equality with the objects `ico` field."""
  ico: String

  """Checks for equality with the objects `cityId` field."""
  cityId: Int

  """Checks for equality with the objects `street` field."""
  street: String

  """Checks for equality with the objects `state` field."""
  state: String

  """Checks for equality with the objects `suite` field."""
  suite: String

  """Checks for equality with the objects `email` field."""
  email: String
}

"""
A filter to be used against `Ambulance` object types. All fields are combined with a logical and.
"""
input AmbulanceFilter {
  """Filter by the objects `id` field."""
  id: IntFilter

  """Filter by the objects `name` field."""
  name: StringFilter

  """Filter by the objects `ico` field."""
  ico: StringFilter

  """Filter by the objects `cityId` field."""
  cityId: IntFilter

  """Filter by the objects `street` field."""
  street: StringFilter

  """Filter by the objects `state` field."""
  state: StringFilter

  """Filter by the objects `suite` field."""
  suite: StringFilter

  """Filter by the objects `email` field."""
  email: StringFilter

  """Checks for all expressions in this list."""
  and: [AmbulanceFilter!]

  """Checks for any expressions in this list."""
  or: [AmbulanceFilter!]

  """Negates the expression."""
  not: AmbulanceFilter
}

"""Methods to use when ordering `Admin`."""
enum AdminsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  FIRST_NAME_ASC
  FIRST_NAME_DESC
  LAST_NAME_ASC
  LAST_NAME_DESC
  AMBULANCE_ID_ASC
  AMBULANCE_ID_DESC
  ADMIN_VERIFIED_ASC
  ADMIN_VERIFIED_DESC
  REGISTRATION_DATE_ASC
  REGISTRATION_DATE_DESC
  EMAIL_ASC
  EMAIL_DESC
  PHONE_ASC
  PHONE_DESC
  LAST_LOGIN_ASC
  LAST_LOGIN_DESC
  INTERVAL_ASC
  INTERVAL_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Admin` object types. All fields are tested for equality and combined with a logical and.
"""
input AdminCondition {
  """Checks for equality with the objects `id` field."""
  id: Int

  """Checks for equality with the objects `firstName` field."""
  firstName: String

  """Checks for equality with the objects `lastName` field."""
  lastName: String

  """Checks for equality with the objects `ambulanceId` field."""
  ambulanceId: Int

  """Checks for equality with the objects `adminVerified` field."""
  adminVerified: Boolean

  """Checks for equality with the objects `registrationDate` field."""
  registrationDate: Date

  """Checks for equality with the objects `email` field."""
  email: String

  """Checks for equality with the objects `phone` field."""
  phone: String

  """Checks for equality with the objects `lastLogin` field."""
  lastLogin: Date

  """Checks for equality with the objects `interval` field."""
  interval: Int
}

"""
A filter to be used against `Admin` object types. All fields are combined with a logical and.
"""
input AdminFilter {
  """Filter by the objects `id` field."""
  id: IntFilter

  """Filter by the objects `firstName` field."""
  firstName: StringFilter

  """Filter by the objects `lastName` field."""
  lastName: StringFilter

  """Filter by the objects `ambulanceId` field."""
  ambulanceId: IntFilter

  """Filter by the objects `adminVerified` field."""
  adminVerified: BooleanFilter

  """Filter by the objects `registrationDate` field."""
  registrationDate: DateFilter

  """Filter by the objects `email` field."""
  email: StringFilter

  """Filter by the objects `phone` field."""
  phone: StringFilter

  """Filter by the objects `lastLogin` field."""
  lastLogin: DateFilter

  """Filter by the objects `interval` field."""
  interval: IntFilter

  """Checks for all expressions in this list."""
  and: [AdminFilter!]

  """Checks for any expressions in this list."""
  or: [AdminFilter!]

  """Negates the expression."""
  not: AdminFilter
}

"""
A filter to be used against Boolean fields. All fields are combined with a logical and.
"""
input BooleanFilter {
  """
  Is null (if `true` is specified) or is not null (if `false` is specified).
  """
  isNull: Boolean

  """Equal to the specified value."""
  equalTo: Boolean

  """Not equal to the specified value."""
  notEqualTo: Boolean

  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: Boolean

  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: Boolean

  """Included in the specified list."""
  in: [Boolean!]

  """Not included in the specified list."""
  notIn: [Boolean!]

  """Less than the specified value."""
  lessThan: Boolean

  """Less than or equal to the specified value."""
  lessThanOrEqualTo: Boolean

  """Greater than the specified value."""
  greaterThan: Boolean

  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: Boolean
}

"""
A filter to be used against Date fields. All fields are combined with a logical and.
"""
input DateFilter {
  """
  Is null (if `true` is specified) or is not null (if `false` is specified).
  """
  isNull: Boolean

  """Equal to the specified value."""
  equalTo: Date

  """Not equal to the specified value."""
  notEqualTo: Date

  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: Date

  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: Date

  """Included in the specified list."""
  in: [Date!]

  """Not included in the specified list."""
  notIn: [Date!]

  """Less than the specified value."""
  lessThan: Date

  """Less than or equal to the specified value."""
  lessThanOrEqualTo: Date

  """Greater than the specified value."""
  greaterThan: Date

  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: Date
}

"""A connection to a list of `Meeting` values."""
type MeetingsConnection {
  """A list of `Meeting` objects."""
  nodes: [Meeting]!

  """
  A list of edges which contains the `Meeting` and cursor to aid in pagination.
  """
  edges: [MeetingsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Meeting` you could get from the connection."""
  totalCount: Int!
}

type Meeting implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: Int!
  meetingDate: Date!
  note: String
  userId: Int
  adminId: Int
  meetingTime: Time!
  ambulanceId: Int
  createdAt: Date

  """Reads a single `User` that is related to this `Meeting`."""
  user: User

  """Reads a single `Admin` that is related to this `Meeting`."""
  admin: Admin

  """Reads a single `Ambulance` that is related to this `Meeting`."""
  ambulance: Ambulance

  """Reads and enables pagination through a set of `BloodCountUserValue`."""
  bloodCountUserValues(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `BloodCountUserValue`."""
    orderBy: [BloodCountUserValuesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: BloodCountUserValueCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: BloodCountUserValueFilter
  ): BloodCountUserValuesConnection!

  """Reads and enables pagination through a set of `BloodCountUser`."""
  bloodCountUsersByBloodCountUserValueMeetingIdAndBloodCountUserId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `BloodCountUser`."""
    orderBy: [BloodCountUsersOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: BloodCountUserCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: BloodCountUserFilter
  ): MeetingBloodCountUsersByBloodCountUserValueMeetingIdAndBloodCountUserIdManyToManyConnection!
}

"""
The exact time of day, does not include the date. May or may not have a timezone offset.
"""
scalar Time

type User implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: Int!
  foreName: String!
  surName: String!
  identNumber: String
  insuranceNumber: String
  email: String
  phone: String
  birthdate: Date
  verified: Boolean
  insuranceCompanyId: Int
  lastLogin: Date
  bloodTypeId: Int
  rhD: Boolean
  registeredAt: Date!

  """Reads a single `InsuranceCompany` that is related to this `User`."""
  insuranceCompany: InsuranceCompany

  """Reads a single `BloodType` that is related to this `User`."""
  bloodType: BloodType

  """Reads and enables pagination through a set of `Meeting`."""
  meetings(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Meeting`."""
    orderBy: [MeetingsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: MeetingCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: MeetingFilter
  ): MeetingsConnection!

  """Reads and enables pagination through a set of `UserDiagnosis`."""
  userDiagnoses(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `UserDiagnosis`."""
    orderBy: [UserDiagnosesOrderBy!] = [NATURAL]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: UserDiagnosisCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: UserDiagnosisFilter
  ): UserDiagnosesConnection!

  """Reads and enables pagination through a set of `UserMedicamentDay`."""
  userMedicamentDays(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `UserMedicamentDay`."""
    orderBy: [UserMedicamentDaysOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: UserMedicamentDayCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: UserMedicamentDayFilter
  ): UserMedicamentDaysConnection!

  """Reads and enables pagination through a set of `UserMedicament`."""
  userMedicaments(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `UserMedicament`."""
    orderBy: [UserMedicamentsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: UserMedicamentCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: UserMedicamentFilter
  ): UserMedicamentsConnection!

  """Reads and enables pagination through a set of `BloodCountUser`."""
  bloodCountUsers(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `BloodCountUser`."""
    orderBy: [BloodCountUsersOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: BloodCountUserCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: BloodCountUserFilter
  ): BloodCountUsersConnection!

  """Reads and enables pagination through a set of `AmbulanceUser`."""
  ambulanceUsers(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `AmbulanceUser`."""
    orderBy: [AmbulanceUsersOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: AmbulanceUserCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: AmbulanceUserFilter
  ): AmbulanceUsersConnection!

  """Reads and enables pagination through a set of `Admin`."""
  adminsByMeetingUserIdAndAdminId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Admin`."""
    orderBy: [AdminsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: AdminCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: AdminFilter
  ): UserAdminsByMeetingUserIdAndAdminIdManyToManyConnection!

  """Reads and enables pagination through a set of `Ambulance`."""
  ambulancesByMeetingUserIdAndAmbulanceId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Ambulance`."""
    orderBy: [AmbulancesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: AmbulanceCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: AmbulanceFilter
  ): UserAmbulancesByMeetingUserIdAndAmbulanceIdManyToManyConnection!

  """Reads and enables pagination through a set of `Diagnosis`."""
  diagnosesByUserDiagnosisUserIdAndDiagnosisId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Diagnosis`."""
    orderBy: [DiagnosesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: DiagnosisCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: DiagnosisFilter
  ): UserDiagnosesByUserDiagnosisUserIdAndDiagnosisIdManyToManyConnection!

  """Reads and enables pagination through a set of `Medicament`."""
  medicamentsByUserMedicamentUserIdAndMedicamentId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Medicament`."""
    orderBy: [MedicamentsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: MedicamentCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: MedicamentFilter
  ): UserMedicamentsByUserMedicamentUserIdAndMedicamentIdManyToManyConnection!

  """Reads and enables pagination through a set of `Admin`."""
  adminsByUserMedicamentUserIdAndAdminId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Admin`."""
    orderBy: [AdminsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: AdminCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: AdminFilter
  ): UserAdminsByUserMedicamentUserIdAndAdminIdManyToManyConnection!

  """Reads and enables pagination through a set of `UserMedicamentDay`."""
  userMedicamentDaysByUserMedicamentUserIdAndUserMedicamentDayId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `UserMedicamentDay`."""
    orderBy: [UserMedicamentDaysOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: UserMedicamentDayCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: UserMedicamentDayFilter
  ): UserUserMedicamentDaysByUserMedicamentUserIdAndUserMedicamentDayIdManyToManyConnection!

  """Reads and enables pagination through a set of `BloodCount`."""
  bloodCountsByBloodCountUserUserIdAndBloodCountId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `BloodCount`."""
    orderBy: [BloodCountsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: BloodCountCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: BloodCountFilter
  ): UserBloodCountsByBloodCountUserUserIdAndBloodCountIdManyToManyConnection!

  """Reads and enables pagination through a set of `Ambulance`."""
  ambulancesByAmbulanceUserUserIdAndAmbulanceId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Ambulance`."""
    orderBy: [AmbulancesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: AmbulanceCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: AmbulanceFilter
  ): UserAmbulancesByAmbulanceUserUserIdAndAmbulanceIdManyToManyConnection!
}

type InsuranceCompany implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: Int!
  name: String!

  """Reads and enables pagination through a set of `User`."""
  users(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `User`."""
    orderBy: [UsersOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: UserCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: UserFilter
  ): UsersConnection!

  """Reads and enables pagination through a set of `BloodType`."""
  bloodTypesByUserInsuranceCompanyIdAndBloodTypeId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `BloodType`."""
    orderBy: [BloodTypesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: BloodTypeCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: BloodTypeFilter
  ): InsuranceCompanyBloodTypesByUserInsuranceCompanyIdAndBloodTypeIdManyToManyConnection!
}

"""A connection to a list of `User` values."""
type UsersConnection {
  """A list of `User` objects."""
  nodes: [User]!

  """
  A list of edges which contains the `User` and cursor to aid in pagination.
  """
  edges: [UsersEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `User` you could get from the connection."""
  totalCount: Int!
}

"""A `User` edge in the connection."""
type UsersEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `User` at the end of the edge."""
  node: User
}

"""Methods to use when ordering `User`."""
enum UsersOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  FORE_NAME_ASC
  FORE_NAME_DESC
  SUR_NAME_ASC
  SUR_NAME_DESC
  IDENT_NUMBER_ASC
  IDENT_NUMBER_DESC
  INSURANCE_NUMBER_ASC
  INSURANCE_NUMBER_DESC
  EMAIL_ASC
  EMAIL_DESC
  PHONE_ASC
  PHONE_DESC
  BIRTHDATE_ASC
  BIRTHDATE_DESC
  VERIFIED_ASC
  VERIFIED_DESC
  INSURANCE_COMPANY_ID_ASC
  INSURANCE_COMPANY_ID_DESC
  LAST_LOGIN_ASC
  LAST_LOGIN_DESC
  BLOOD_TYPE_ID_ASC
  BLOOD_TYPE_ID_DESC
  RH_D_ASC
  RH_D_DESC
  REGISTERED_AT_ASC
  REGISTERED_AT_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `User` object types. All fields are tested for equality and combined with a logical and.
"""
input UserCondition {
  """Checks for equality with the objects `id` field."""
  id: Int

  """Checks for equality with the objects `foreName` field."""
  foreName: String

  """Checks for equality with the objects `surName` field."""
  surName: String

  """Checks for equality with the objects `identNumber` field."""
  identNumber: String

  """Checks for equality with the objects `insuranceNumber` field."""
  insuranceNumber: String

  """Checks for equality with the objects `email` field."""
  email: String

  """Checks for equality with the objects `phone` field."""
  phone: String

  """Checks for equality with the objects `birthdate` field."""
  birthdate: Date

  """Checks for equality with the objects `verified` field."""
  verified: Boolean

  """Checks for equality with the objects `insuranceCompanyId` field."""
  insuranceCompanyId: Int

  """Checks for equality with the objects `lastLogin` field."""
  lastLogin: Date

  """Checks for equality with the objects `bloodTypeId` field."""
  bloodTypeId: Int

  """Checks for equality with the objects `rhD` field."""
  rhD: Boolean

  """Checks for equality with the objects `registeredAt` field."""
  registeredAt: Date
}

"""
A filter to be used against `User` object types. All fields are combined with a logical and.
"""
input UserFilter {
  """Filter by the objects `id` field."""
  id: IntFilter

  """Filter by the objects `foreName` field."""
  foreName: StringFilter

  """Filter by the objects `surName` field."""
  surName: StringFilter

  """Filter by the objects `identNumber` field."""
  identNumber: StringFilter

  """Filter by the objects `insuranceNumber` field."""
  insuranceNumber: StringFilter

  """Filter by the objects `email` field."""
  email: StringFilter

  """Filter by the objects `phone` field."""
  phone: StringFilter

  """Filter by the objects `birthdate` field."""
  birthdate: DateFilter

  """Filter by the objects `verified` field."""
  verified: BooleanFilter

  """Filter by the objects `insuranceCompanyId` field."""
  insuranceCompanyId: IntFilter

  """Filter by the objects `lastLogin` field."""
  lastLogin: DateFilter

  """Filter by the objects `bloodTypeId` field."""
  bloodTypeId: IntFilter

  """Filter by the objects `rhD` field."""
  rhD: BooleanFilter

  """Filter by the objects `registeredAt` field."""
  registeredAt: DateFilter

  """Checks for all expressions in this list."""
  and: [UserFilter!]

  """Checks for any expressions in this list."""
  or: [UserFilter!]

  """Negates the expression."""
  not: UserFilter
}

"""A connection to a list of `BloodType` values, with data from `User`."""
type InsuranceCompanyBloodTypesByUserInsuranceCompanyIdAndBloodTypeIdManyToManyConnection {
  """A list of `BloodType` objects."""
  nodes: [BloodType]!

  """
  A list of edges which contains the `BloodType`, info from the `User`, and the cursor to aid in pagination.
  """
  edges: [InsuranceCompanyBloodTypesByUserInsuranceCompanyIdAndBloodTypeIdManyToManyEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `BloodType` you could get from the connection."""
  totalCount: Int!
}

type BloodType implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: Int!
  name: String!

  """Reads and enables pagination through a set of `User`."""
  users(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `User`."""
    orderBy: [UsersOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: UserCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: UserFilter
  ): UsersConnection!

  """Reads and enables pagination through a set of `InsuranceCompany`."""
  insuranceCompaniesByUserBloodTypeIdAndInsuranceCompanyId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `InsuranceCompany`."""
    orderBy: [InsuranceCompaniesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: InsuranceCompanyCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: InsuranceCompanyFilter
  ): BloodTypeInsuranceCompaniesByUserBloodTypeIdAndInsuranceCompanyIdManyToManyConnection!
}

"""
A connection to a list of `InsuranceCompany` values, with data from `User`.
"""
type BloodTypeInsuranceCompaniesByUserBloodTypeIdAndInsuranceCompanyIdManyToManyConnection {
  """A list of `InsuranceCompany` objects."""
  nodes: [InsuranceCompany]!

  """
  A list of edges which contains the `InsuranceCompany`, info from the `User`, and the cursor to aid in pagination.
  """
  edges: [BloodTypeInsuranceCompaniesByUserBloodTypeIdAndInsuranceCompanyIdManyToManyEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """
  The count of *all* `InsuranceCompany` you could get from the connection.
  """
  totalCount: Int!
}

"""A `InsuranceCompany` edge in the connection, with data from `User`."""
type BloodTypeInsuranceCompaniesByUserBloodTypeIdAndInsuranceCompanyIdManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `InsuranceCompany` at the end of the edge."""
  node: InsuranceCompany

  """Reads and enables pagination through a set of `User`."""
  users(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `User`."""
    orderBy: [UsersOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: UserCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: UserFilter
  ): UsersConnection!
}

"""Methods to use when ordering `InsuranceCompany`."""
enum InsuranceCompaniesOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  NAME_ASC
  NAME_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `InsuranceCompany` object types. All fields are
tested for equality and combined with a logical and.
"""
input InsuranceCompanyCondition {
  """Checks for equality with the objects `id` field."""
  id: Int

  """Checks for equality with the objects `name` field."""
  name: String
}

"""
A filter to be used against `InsuranceCompany` object types. All fields are combined with a logical and.
"""
input InsuranceCompanyFilter {
  """Filter by the objects `id` field."""
  id: IntFilter

  """Filter by the objects `name` field."""
  name: StringFilter

  """Checks for all expressions in this list."""
  and: [InsuranceCompanyFilter!]

  """Checks for any expressions in this list."""
  or: [InsuranceCompanyFilter!]

  """Negates the expression."""
  not: InsuranceCompanyFilter
}

"""A `BloodType` edge in the connection, with data from `User`."""
type InsuranceCompanyBloodTypesByUserInsuranceCompanyIdAndBloodTypeIdManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `BloodType` at the end of the edge."""
  node: BloodType

  """Reads and enables pagination through a set of `User`."""
  users(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `User`."""
    orderBy: [UsersOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: UserCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: UserFilter
  ): UsersConnection!
}

"""Methods to use when ordering `BloodType`."""
enum BloodTypesOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  NAME_ASC
  NAME_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `BloodType` object types. All fields are tested
for equality and combined with a logical and.
"""
input BloodTypeCondition {
  """Checks for equality with the objects `id` field."""
  id: Int

  """Checks for equality with the objects `name` field."""
  name: String
}

"""
A filter to be used against `BloodType` object types. All fields are combined with a logical and.
"""
input BloodTypeFilter {
  """Filter by the objects `id` field."""
  id: IntFilter

  """Filter by the objects `name` field."""
  name: StringFilter

  """Checks for all expressions in this list."""
  and: [BloodTypeFilter!]

  """Checks for any expressions in this list."""
  or: [BloodTypeFilter!]

  """Negates the expression."""
  not: BloodTypeFilter
}

"""Methods to use when ordering `Meeting`."""
enum MeetingsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  MEETING_DATE_ASC
  MEETING_DATE_DESC
  NOTE_ASC
  NOTE_DESC
  USER_ID_ASC
  USER_ID_DESC
  ADMIN_ID_ASC
  ADMIN_ID_DESC
  MEETING_TIME_ASC
  MEETING_TIME_DESC
  AMBULANCE_ID_ASC
  AMBULANCE_ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Meeting` object types. All fields are tested for equality and combined with a logical and.
"""
input MeetingCondition {
  """Checks for equality with the objects `id` field."""
  id: Int

  """Checks for equality with the objects `meetingDate` field."""
  meetingDate: Date

  """Checks for equality with the objects `note` field."""
  note: String

  """Checks for equality with the objects `userId` field."""
  userId: Int

  """Checks for equality with the objects `adminId` field."""
  adminId: Int

  """Checks for equality with the objects `meetingTime` field."""
  meetingTime: Time

  """Checks for equality with the objects `ambulanceId` field."""
  ambulanceId: Int

  """Checks for equality with the objects `createdAt` field."""
  createdAt: Date
}

"""
A filter to be used against `Meeting` object types. All fields are combined with a logical and.
"""
input MeetingFilter {
  """Filter by the objects `id` field."""
  id: IntFilter

  """Filter by the objects `meetingDate` field."""
  meetingDate: DateFilter

  """Filter by the objects `note` field."""
  note: StringFilter

  """Filter by the objects `userId` field."""
  userId: IntFilter

  """Filter by the objects `adminId` field."""
  adminId: IntFilter

  """Filter by the objects `meetingTime` field."""
  meetingTime: TimeFilter

  """Filter by the objects `ambulanceId` field."""
  ambulanceId: IntFilter

  """Filter by the objects `createdAt` field."""
  createdAt: DateFilter

  """Checks for all expressions in this list."""
  and: [MeetingFilter!]

  """Checks for any expressions in this list."""
  or: [MeetingFilter!]

  """Negates the expression."""
  not: MeetingFilter
}

"""
A filter to be used against Time fields. All fields are combined with a logical and.
"""
input TimeFilter {
  """
  Is null (if `true` is specified) or is not null (if `false` is specified).
  """
  isNull: Boolean

  """Equal to the specified value."""
  equalTo: Time

  """Not equal to the specified value."""
  notEqualTo: Time

  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: Time

  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: Time

  """Included in the specified list."""
  in: [Time!]

  """Not included in the specified list."""
  notIn: [Time!]

  """Less than the specified value."""
  lessThan: Time

  """Less than or equal to the specified value."""
  lessThanOrEqualTo: Time

  """Greater than the specified value."""
  greaterThan: Time

  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: Time
}

"""A connection to a list of `UserDiagnosis` values."""
type UserDiagnosesConnection {
  """A list of `UserDiagnosis` objects."""
  nodes: [UserDiagnosis]!

  """
  A list of edges which contains the `UserDiagnosis` and cursor to aid in pagination.
  """
  edges: [UserDiagnosesEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `UserDiagnosis` you could get from the connection."""
  totalCount: Int!
}

type UserDiagnosis {
  userId: Int!
  diagnosisId: String!

  """Reads a single `User` that is related to this `UserDiagnosis`."""
  user: User

  """Reads a single `Diagnosis` that is related to this `UserDiagnosis`."""
  diagnosis: Diagnosis
}

type Diagnosis implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: String!
  name: String!
  diagnosisCategoryId: String!
  diagnosisGroupId: String!
  description: String

  """
  Reads a single `DiagnosisCategory` that is related to this `Diagnosis`.
  """
  diagnosisCategory: DiagnosisCategory

  """Reads a single `DiagnosisGroup` that is related to this `Diagnosis`."""
  diagnosisGroup: DiagnosisGroup

  """Reads and enables pagination through a set of `UserDiagnosis`."""
  userDiagnoses(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `UserDiagnosis`."""
    orderBy: [UserDiagnosesOrderBy!] = [NATURAL]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: UserDiagnosisCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: UserDiagnosisFilter
  ): UserDiagnosesConnection!

  """Reads and enables pagination through a set of `User`."""
  usersByUserDiagnosisDiagnosisIdAndUserId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `User`."""
    orderBy: [UsersOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: UserCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: UserFilter
  ): DiagnosisUsersByUserDiagnosisDiagnosisIdAndUserIdManyToManyConnection!
}

type DiagnosisCategory implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: String!
  name: String!
  diagnosisGroupId: String!
  description: String

  """
  Reads a single `DiagnosisGroup` that is related to this `DiagnosisCategory`.
  """
  diagnosisGroup: DiagnosisGroup

  """Reads and enables pagination through a set of `Diagnosis`."""
  diagnoses(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Diagnosis`."""
    orderBy: [DiagnosesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: DiagnosisCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: DiagnosisFilter
  ): DiagnosesConnection!

  """Reads and enables pagination through a set of `DiagnosisGroup`."""
  diagnosisGroupsByDiagnosisDiagnosisCategoryIdAndDiagnosisGroupId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `DiagnosisGroup`."""
    orderBy: [DiagnosisGroupsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: DiagnosisGroupCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: DiagnosisGroupFilter
  ): DiagnosisCategoryDiagnosisGroupsByDiagnosisDiagnosisCategoryIdAndDiagnosisGroupIdManyToManyConnection!
}

type DiagnosisGroup implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: String!
  name: String!
  description: String

  """Reads and enables pagination through a set of `Diagnosis`."""
  diagnoses(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Diagnosis`."""
    orderBy: [DiagnosesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: DiagnosisCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: DiagnosisFilter
  ): DiagnosesConnection!

  """Reads and enables pagination through a set of `DiagnosisCategory`."""
  diagnosisCategories(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `DiagnosisCategory`."""
    orderBy: [DiagnosisCategoriesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: DiagnosisCategoryCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: DiagnosisCategoryFilter
  ): DiagnosisCategoriesConnection!

  """Reads and enables pagination through a set of `DiagnosisCategory`."""
  diagnosisCategoriesByDiagnosisDiagnosisGroupIdAndDiagnosisCategoryId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `DiagnosisCategory`."""
    orderBy: [DiagnosisCategoriesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: DiagnosisCategoryCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: DiagnosisCategoryFilter
  ): DiagnosisGroupDiagnosisCategoriesByDiagnosisDiagnosisGroupIdAndDiagnosisCategoryIdManyToManyConnection!
}

"""A connection to a list of `Diagnosis` values."""
type DiagnosesConnection {
  """A list of `Diagnosis` objects."""
  nodes: [Diagnosis]!

  """
  A list of edges which contains the `Diagnosis` and cursor to aid in pagination.
  """
  edges: [DiagnosesEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Diagnosis` you could get from the connection."""
  totalCount: Int!
}

"""A `Diagnosis` edge in the connection."""
type DiagnosesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Diagnosis` at the end of the edge."""
  node: Diagnosis
}

"""Methods to use when ordering `Diagnosis`."""
enum DiagnosesOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  NAME_ASC
  NAME_DESC
  DIAGNOSIS_CATEGORY_ID_ASC
  DIAGNOSIS_CATEGORY_ID_DESC
  DIAGNOSIS_GROUP_ID_ASC
  DIAGNOSIS_GROUP_ID_DESC
  DESCRIPTION_ASC
  DESCRIPTION_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Diagnosis` object types. All fields are tested
for equality and combined with a logical and.
"""
input DiagnosisCondition {
  """Checks for equality with the objects `id` field."""
  id: String

  """Checks for equality with the objects `name` field."""
  name: String

  """Checks for equality with the objects `diagnosisCategoryId` field."""
  diagnosisCategoryId: String

  """Checks for equality with the objects `diagnosisGroupId` field."""
  diagnosisGroupId: String

  """Checks for equality with the objects `description` field."""
  description: String
}

"""
A filter to be used against `Diagnosis` object types. All fields are combined with a logical and.
"""
input DiagnosisFilter {
  """Filter by the objects `id` field."""
  id: StringFilter

  """Filter by the objects `name` field."""
  name: StringFilter

  """Filter by the objects `diagnosisCategoryId` field."""
  diagnosisCategoryId: StringFilter

  """Filter by the objects `diagnosisGroupId` field."""
  diagnosisGroupId: StringFilter

  """Filter by the objects `description` field."""
  description: StringFilter

  """Checks for all expressions in this list."""
  and: [DiagnosisFilter!]

  """Checks for any expressions in this list."""
  or: [DiagnosisFilter!]

  """Negates the expression."""
  not: DiagnosisFilter
}

"""A connection to a list of `DiagnosisCategory` values."""
type DiagnosisCategoriesConnection {
  """A list of `DiagnosisCategory` objects."""
  nodes: [DiagnosisCategory]!

  """
  A list of edges which contains the `DiagnosisCategory` and cursor to aid in pagination.
  """
  edges: [DiagnosisCategoriesEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """
  The count of *all* `DiagnosisCategory` you could get from the connection.
  """
  totalCount: Int!
}

"""A `DiagnosisCategory` edge in the connection."""
type DiagnosisCategoriesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `DiagnosisCategory` at the end of the edge."""
  node: DiagnosisCategory
}

"""Methods to use when ordering `DiagnosisCategory`."""
enum DiagnosisCategoriesOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  NAME_ASC
  NAME_DESC
  DIAGNOSIS_GROUP_ID_ASC
  DIAGNOSIS_GROUP_ID_DESC
  DESCRIPTION_ASC
  DESCRIPTION_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `DiagnosisCategory` object types. All fields are
tested for equality and combined with a logical and.
"""
input DiagnosisCategoryCondition {
  """Checks for equality with the objects `id` field."""
  id: String

  """Checks for equality with the objects `name` field."""
  name: String

  """Checks for equality with the objects `diagnosisGroupId` field."""
  diagnosisGroupId: String

  """Checks for equality with the objects `description` field."""
  description: String
}

"""
A filter to be used against `DiagnosisCategory` object types. All fields are combined with a logical and.
"""
input DiagnosisCategoryFilter {
  """Filter by the objects `id` field."""
  id: StringFilter

  """Filter by the objects `name` field."""
  name: StringFilter

  """Filter by the objects `diagnosisGroupId` field."""
  diagnosisGroupId: StringFilter

  """Filter by the objects `description` field."""
  description: StringFilter

  """Checks for all expressions in this list."""
  and: [DiagnosisCategoryFilter!]

  """Checks for any expressions in this list."""
  or: [DiagnosisCategoryFilter!]

  """Negates the expression."""
  not: DiagnosisCategoryFilter
}

"""
A connection to a list of `DiagnosisCategory` values, with data from `Diagnosis`.
"""
type DiagnosisGroupDiagnosisCategoriesByDiagnosisDiagnosisGroupIdAndDiagnosisCategoryIdManyToManyConnection {
  """A list of `DiagnosisCategory` objects."""
  nodes: [DiagnosisCategory]!

  """
  A list of edges which contains the `DiagnosisCategory`, info from the `Diagnosis`, and the cursor to aid in pagination.
  """
  edges: [DiagnosisGroupDiagnosisCategoriesByDiagnosisDiagnosisGroupIdAndDiagnosisCategoryIdManyToManyEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """
  The count of *all* `DiagnosisCategory` you could get from the connection.
  """
  totalCount: Int!
}

"""
A `DiagnosisCategory` edge in the connection, with data from `Diagnosis`.
"""
type DiagnosisGroupDiagnosisCategoriesByDiagnosisDiagnosisGroupIdAndDiagnosisCategoryIdManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `DiagnosisCategory` at the end of the edge."""
  node: DiagnosisCategory

  """Reads and enables pagination through a set of `Diagnosis`."""
  diagnoses(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Diagnosis`."""
    orderBy: [DiagnosesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: DiagnosisCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: DiagnosisFilter
  ): DiagnosesConnection!
}

"""
A connection to a list of `DiagnosisGroup` values, with data from `Diagnosis`.
"""
type DiagnosisCategoryDiagnosisGroupsByDiagnosisDiagnosisCategoryIdAndDiagnosisGroupIdManyToManyConnection {
  """A list of `DiagnosisGroup` objects."""
  nodes: [DiagnosisGroup]!

  """
  A list of edges which contains the `DiagnosisGroup`, info from the `Diagnosis`, and the cursor to aid in pagination.
  """
  edges: [DiagnosisCategoryDiagnosisGroupsByDiagnosisDiagnosisCategoryIdAndDiagnosisGroupIdManyToManyEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `DiagnosisGroup` you could get from the connection."""
  totalCount: Int!
}

"""A `DiagnosisGroup` edge in the connection, with data from `Diagnosis`."""
type DiagnosisCategoryDiagnosisGroupsByDiagnosisDiagnosisCategoryIdAndDiagnosisGroupIdManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `DiagnosisGroup` at the end of the edge."""
  node: DiagnosisGroup

  """Reads and enables pagination through a set of `Diagnosis`."""
  diagnoses(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Diagnosis`."""
    orderBy: [DiagnosesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: DiagnosisCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: DiagnosisFilter
  ): DiagnosesConnection!
}

"""Methods to use when ordering `DiagnosisGroup`."""
enum DiagnosisGroupsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  NAME_ASC
  NAME_DESC
  DESCRIPTION_ASC
  DESCRIPTION_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `DiagnosisGroup` object types. All fields are
tested for equality and combined with a logical and.
"""
input DiagnosisGroupCondition {
  """Checks for equality with the objects `id` field."""
  id: String

  """Checks for equality with the objects `name` field."""
  name: String

  """Checks for equality with the objects `description` field."""
  description: String
}

"""
A filter to be used against `DiagnosisGroup` object types. All fields are combined with a logical and.
"""
input DiagnosisGroupFilter {
  """Filter by the objects `id` field."""
  id: StringFilter

  """Filter by the objects `name` field."""
  name: StringFilter

  """Filter by the objects `description` field."""
  description: StringFilter

  """Checks for all expressions in this list."""
  and: [DiagnosisGroupFilter!]

  """Checks for any expressions in this list."""
  or: [DiagnosisGroupFilter!]

  """Negates the expression."""
  not: DiagnosisGroupFilter
}

"""Methods to use when ordering `UserDiagnosis`."""
enum UserDiagnosesOrderBy {
  NATURAL
  USER_ID_ASC
  USER_ID_DESC
  DIAGNOSIS_ID_ASC
  DIAGNOSIS_ID_DESC
}

"""
A condition to be used against `UserDiagnosis` object types. All fields are
tested for equality and combined with a logical and.
"""
input UserDiagnosisCondition {
  """Checks for equality with the objects `userId` field."""
  userId: Int

  """Checks for equality with the objects `diagnosisId` field."""
  diagnosisId: String
}

"""
A filter to be used against `UserDiagnosis` object types. All fields are combined with a logical and.
"""
input UserDiagnosisFilter {
  """Filter by the objects `userId` field."""
  userId: IntFilter

  """Filter by the objects `diagnosisId` field."""
  diagnosisId: StringFilter

  """Checks for all expressions in this list."""
  and: [UserDiagnosisFilter!]

  """Checks for any expressions in this list."""
  or: [UserDiagnosisFilter!]

  """Negates the expression."""
  not: UserDiagnosisFilter
}

"""
A connection to a list of `User` values, with data from `UserDiagnosis`.
"""
type DiagnosisUsersByUserDiagnosisDiagnosisIdAndUserIdManyToManyConnection {
  """A list of `User` objects."""
  nodes: [User]!

  """
  A list of edges which contains the `User`, info from the `UserDiagnosis`, and the cursor to aid in pagination.
  """
  edges: [DiagnosisUsersByUserDiagnosisDiagnosisIdAndUserIdManyToManyEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `User` you could get from the connection."""
  totalCount: Int!
}

"""A `User` edge in the connection, with data from `UserDiagnosis`."""
type DiagnosisUsersByUserDiagnosisDiagnosisIdAndUserIdManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `User` at the end of the edge."""
  node: User

  """Reads and enables pagination through a set of `UserDiagnosis`."""
  userDiagnoses(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `UserDiagnosis`."""
    orderBy: [UserDiagnosesOrderBy!] = [NATURAL]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: UserDiagnosisCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: UserDiagnosisFilter
  ): UserDiagnosesConnection!
}

"""A `UserDiagnosis` edge in the connection."""
type UserDiagnosesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `UserDiagnosis` at the end of the edge."""
  node: UserDiagnosis
}

"""A connection to a list of `UserMedicamentDay` values."""
type UserMedicamentDaysConnection {
  """A list of `UserMedicamentDay` objects."""
  nodes: [UserMedicamentDay]!

  """
  A list of edges which contains the `UserMedicamentDay` and cursor to aid in pagination.
  """
  edges: [UserMedicamentDaysEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """
  The count of *all* `UserMedicamentDay` you could get from the connection.
  """
  totalCount: Int!
}

type UserMedicamentDay implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  monday: Boolean!
  tuesday: Boolean!
  wednesday: Boolean!
  thursday: Boolean!
  friday: Boolean!
  saturday: Boolean!
  sunday: Boolean!
  id: Int!
  userId: Int

  """Reads a single `User` that is related to this `UserMedicamentDay`."""
  user: User

  """Reads and enables pagination through a set of `UserMedicament`."""
  userMedicaments(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `UserMedicament`."""
    orderBy: [UserMedicamentsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: UserMedicamentCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: UserMedicamentFilter
  ): UserMedicamentsConnection!

  """Reads and enables pagination through a set of `User`."""
  usersByUserMedicamentUserMedicamentDayIdAndUserId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `User`."""
    orderBy: [UsersOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: UserCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: UserFilter
  ): UserMedicamentDayUsersByUserMedicamentUserMedicamentDayIdAndUserIdManyToManyConnection!

  """Reads and enables pagination through a set of `Medicament`."""
  medicamentsByUserMedicamentUserMedicamentDayIdAndMedicamentId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Medicament`."""
    orderBy: [MedicamentsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: MedicamentCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: MedicamentFilter
  ): UserMedicamentDayMedicamentsByUserMedicamentUserMedicamentDayIdAndMedicamentIdManyToManyConnection!

  """Reads and enables pagination through a set of `Admin`."""
  adminsByUserMedicamentUserMedicamentDayIdAndAdminId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Admin`."""
    orderBy: [AdminsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: AdminCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: AdminFilter
  ): UserMedicamentDayAdminsByUserMedicamentUserMedicamentDayIdAndAdminIdManyToManyConnection!
}

"""A connection to a list of `UserMedicament` values."""
type UserMedicamentsConnection {
  """A list of `UserMedicament` objects."""
  nodes: [UserMedicament]!

  """
  A list of edges which contains the `UserMedicament` and cursor to aid in pagination.
  """
  edges: [UserMedicamentsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `UserMedicament` you could get from the connection."""
  totalCount: Int!
}

type UserMedicament implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: Int!
  userId: Int!
  medicamentId: Int!
  active: Boolean!
  dosing: Int
  createdAt: Date
  nextPrescriptionDate: Date
  adminId: Int
  updatedAt: Date
  interval: Int
  everyXday: Int
  morning: Boolean!
  noon: Boolean!
  evening: Boolean!
  userMedicamentDayId: Int

  """Reads a single `User` that is related to this `UserMedicament`."""
  user: User

  """Reads a single `Medicament` that is related to this `UserMedicament`."""
  medicament: Medicament

  """Reads a single `Admin` that is related to this `UserMedicament`."""
  admin: Admin

  """
  Reads a single `UserMedicamentDay` that is related to this `UserMedicament`.
  """
  userMedicamentDay: UserMedicamentDay

  """Reads and enables pagination through a set of `UserMedicamentTime`."""
  userMedicamentTimes(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `UserMedicamentTime`."""
    orderBy: [UserMedicamentTimesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: UserMedicamentTimeCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: UserMedicamentTimeFilter
  ): UserMedicamentTimesConnection!
}

type Medicament implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: Int!
  code: String!
  title: String!
  supplement: String
  strength: String
  packaging: Int
  holderCode: String
  stateCode: String
  atcCode: String
  atcTitleSk: String
  indicationGroup: String
  regNumber: String
  expiration: String
  dispensing: String
  registrationType: String
  regDate: String
  validity: String
  securityFeature: Boolean

  """Reads and enables pagination through a set of `UserMedicament`."""
  userMedicaments(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `UserMedicament`."""
    orderBy: [UserMedicamentsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: UserMedicamentCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: UserMedicamentFilter
  ): UserMedicamentsConnection!

  """
  Reads and enables pagination through a set of `AdminMedicamentDescription`.
  """
  adminMedicamentDescriptions(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `AdminMedicamentDescription`."""
    orderBy: [AdminMedicamentDescriptionsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: AdminMedicamentDescriptionCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: AdminMedicamentDescriptionFilter
  ): AdminMedicamentDescriptionsConnection!

  """Reads and enables pagination through a set of `User`."""
  usersByUserMedicamentMedicamentIdAndUserId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `User`."""
    orderBy: [UsersOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: UserCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: UserFilter
  ): MedicamentUsersByUserMedicamentMedicamentIdAndUserIdManyToManyConnection!

  """Reads and enables pagination through a set of `Admin`."""
  adminsByUserMedicamentMedicamentIdAndAdminId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Admin`."""
    orderBy: [AdminsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: AdminCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: AdminFilter
  ): MedicamentAdminsByUserMedicamentMedicamentIdAndAdminIdManyToManyConnection!

  """Reads and enables pagination through a set of `UserMedicamentDay`."""
  userMedicamentDaysByUserMedicamentMedicamentIdAndUserMedicamentDayId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `UserMedicamentDay`."""
    orderBy: [UserMedicamentDaysOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: UserMedicamentDayCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: UserMedicamentDayFilter
  ): MedicamentUserMedicamentDaysByUserMedicamentMedicamentIdAndUserMedicamentDayIdManyToManyConnection!

  """Reads and enables pagination through a set of `Admin`."""
  adminsByAdminMedicamentDescriptionMedicamentIdAndAdminId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Admin`."""
    orderBy: [AdminsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: AdminCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: AdminFilter
  ): MedicamentAdminsByAdminMedicamentDescriptionMedicamentIdAndAdminIdManyToManyConnection!
}

"""Methods to use when ordering `UserMedicament`."""
enum UserMedicamentsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  USER_ID_ASC
  USER_ID_DESC
  MEDICAMENT_ID_ASC
  MEDICAMENT_ID_DESC
  ACTIVE_ASC
  ACTIVE_DESC
  DOSING_ASC
  DOSING_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  NEXT_PRESCRIPTION_DATE_ASC
  NEXT_PRESCRIPTION_DATE_DESC
  ADMIN_ID_ASC
  ADMIN_ID_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
  INTERVAL_ASC
  INTERVAL_DESC
  EVERY_XDAY_ASC
  EVERY_XDAY_DESC
  MORNING_ASC
  MORNING_DESC
  NOON_ASC
  NOON_DESC
  EVENING_ASC
  EVENING_DESC
  USER_MEDICAMENT_DAY_ID_ASC
  USER_MEDICAMENT_DAY_ID_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `UserMedicament` object types. All fields are
tested for equality and combined with a logical and.
"""
input UserMedicamentCondition {
  """Checks for equality with the objects `id` field."""
  id: Int

  """Checks for equality with the objects `userId` field."""
  userId: Int

  """Checks for equality with the objects `medicamentId` field."""
  medicamentId: Int

  """Checks for equality with the objects `active` field."""
  active: Boolean

  """Checks for equality with the objects `dosing` field."""
  dosing: Int

  """Checks for equality with the objects `createdAt` field."""
  createdAt: Date

  """Checks for equality with the objects `nextPrescriptionDate` field."""
  nextPrescriptionDate: Date

  """Checks for equality with the objects `adminId` field."""
  adminId: Int

  """Checks for equality with the objects `updatedAt` field."""
  updatedAt: Date

  """Checks for equality with the objects `interval` field."""
  interval: Int

  """Checks for equality with the objects `everyXday` field."""
  everyXday: Int

  """Checks for equality with the objects `morning` field."""
  morning: Boolean

  """Checks for equality with the objects `noon` field."""
  noon: Boolean

  """Checks for equality with the objects `evening` field."""
  evening: Boolean

  """Checks for equality with the objects `userMedicamentDayId` field."""
  userMedicamentDayId: Int
}

"""
A filter to be used against `UserMedicament` object types. All fields are combined with a logical and.
"""
input UserMedicamentFilter {
  """Filter by the objects `id` field."""
  id: IntFilter

  """Filter by the objects `userId` field."""
  userId: IntFilter

  """Filter by the objects `medicamentId` field."""
  medicamentId: IntFilter

  """Filter by the objects `active` field."""
  active: BooleanFilter

  """Filter by the objects `dosing` field."""
  dosing: IntFilter

  """Filter by the objects `createdAt` field."""
  createdAt: DateFilter

  """Filter by the objects `nextPrescriptionDate` field."""
  nextPrescriptionDate: DateFilter

  """Filter by the objects `adminId` field."""
  adminId: IntFilter

  """Filter by the objects `updatedAt` field."""
  updatedAt: DateFilter

  """Filter by the objects `interval` field."""
  interval: IntFilter

  """Filter by the objects `everyXday` field."""
  everyXday: IntFilter

  """Filter by the objects `morning` field."""
  morning: BooleanFilter

  """Filter by the objects `noon` field."""
  noon: BooleanFilter

  """Filter by the objects `evening` field."""
  evening: BooleanFilter

  """Filter by the objects `userMedicamentDayId` field."""
  userMedicamentDayId: IntFilter

  """Checks for all expressions in this list."""
  and: [UserMedicamentFilter!]

  """Checks for any expressions in this list."""
  or: [UserMedicamentFilter!]

  """Negates the expression."""
  not: UserMedicamentFilter
}

"""A connection to a list of `AdminMedicamentDescription` values."""
type AdminMedicamentDescriptionsConnection {
  """A list of `AdminMedicamentDescription` objects."""
  nodes: [AdminMedicamentDescription]!

  """
  A list of edges which contains the `AdminMedicamentDescription` and cursor to aid in pagination.
  """
  edges: [AdminMedicamentDescriptionsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """
  The count of *all* `AdminMedicamentDescription` you could get from the connection.
  """
  totalCount: Int!
}

type AdminMedicamentDescription implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: Int!
  adminId: Int
  medicamentId: Int
  description: String!

  """
  Reads a single `Admin` that is related to this `AdminMedicamentDescription`.
  """
  admin: Admin

  """
  Reads a single `Medicament` that is related to this `AdminMedicamentDescription`.
  """
  medicament: Medicament
}

"""A `AdminMedicamentDescription` edge in the connection."""
type AdminMedicamentDescriptionsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `AdminMedicamentDescription` at the end of the edge."""
  node: AdminMedicamentDescription
}

"""Methods to use when ordering `AdminMedicamentDescription`."""
enum AdminMedicamentDescriptionsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  ADMIN_ID_ASC
  ADMIN_ID_DESC
  MEDICAMENT_ID_ASC
  MEDICAMENT_ID_DESC
  DESCRIPTION_ASC
  DESCRIPTION_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `AdminMedicamentDescription` object types. All
fields are tested for equality and combined with a logical and.
"""
input AdminMedicamentDescriptionCondition {
  """Checks for equality with the objects `id` field."""
  id: Int

  """Checks for equality with the objects `adminId` field."""
  adminId: Int

  """Checks for equality with the objects `medicamentId` field."""
  medicamentId: Int

  """Checks for equality with the objects `description` field."""
  description: String
}

"""
A filter to be used against `AdminMedicamentDescription` object types. All fields are combined with a logical and.
"""
input AdminMedicamentDescriptionFilter {
  """Filter by the objects `id` field."""
  id: IntFilter

  """Filter by the objects `adminId` field."""
  adminId: IntFilter

  """Filter by the objects `medicamentId` field."""
  medicamentId: IntFilter

  """Filter by the objects `description` field."""
  description: StringFilter

  """Checks for all expressions in this list."""
  and: [AdminMedicamentDescriptionFilter!]

  """Checks for any expressions in this list."""
  or: [AdminMedicamentDescriptionFilter!]

  """Negates the expression."""
  not: AdminMedicamentDescriptionFilter
}

"""
A connection to a list of `User` values, with data from `UserMedicament`.
"""
type MedicamentUsersByUserMedicamentMedicamentIdAndUserIdManyToManyConnection {
  """A list of `User` objects."""
  nodes: [User]!

  """
  A list of edges which contains the `User`, info from the `UserMedicament`, and the cursor to aid in pagination.
  """
  edges: [MedicamentUsersByUserMedicamentMedicamentIdAndUserIdManyToManyEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `User` you could get from the connection."""
  totalCount: Int!
}

"""A `User` edge in the connection, with data from `UserMedicament`."""
type MedicamentUsersByUserMedicamentMedicamentIdAndUserIdManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `User` at the end of the edge."""
  node: User

  """Reads and enables pagination through a set of `UserMedicament`."""
  userMedicaments(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `UserMedicament`."""
    orderBy: [UserMedicamentsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: UserMedicamentCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: UserMedicamentFilter
  ): UserMedicamentsConnection!
}

"""
A connection to a list of `Admin` values, with data from `UserMedicament`.
"""
type MedicamentAdminsByUserMedicamentMedicamentIdAndAdminIdManyToManyConnection {
  """A list of `Admin` objects."""
  nodes: [Admin]!

  """
  A list of edges which contains the `Admin`, info from the `UserMedicament`, and the cursor to aid in pagination.
  """
  edges: [MedicamentAdminsByUserMedicamentMedicamentIdAndAdminIdManyToManyEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Admin` you could get from the connection."""
  totalCount: Int!
}

"""A `Admin` edge in the connection, with data from `UserMedicament`."""
type MedicamentAdminsByUserMedicamentMedicamentIdAndAdminIdManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Admin` at the end of the edge."""
  node: Admin

  """Reads and enables pagination through a set of `UserMedicament`."""
  userMedicaments(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `UserMedicament`."""
    orderBy: [UserMedicamentsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: UserMedicamentCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: UserMedicamentFilter
  ): UserMedicamentsConnection!
}

"""
A connection to a list of `UserMedicamentDay` values, with data from `UserMedicament`.
"""
type MedicamentUserMedicamentDaysByUserMedicamentMedicamentIdAndUserMedicamentDayIdManyToManyConnection {
  """A list of `UserMedicamentDay` objects."""
  nodes: [UserMedicamentDay]!

  """
  A list of edges which contains the `UserMedicamentDay`, info from the `UserMedicament`, and the cursor to aid in pagination.
  """
  edges: [MedicamentUserMedicamentDaysByUserMedicamentMedicamentIdAndUserMedicamentDayIdManyToManyEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """
  The count of *all* `UserMedicamentDay` you could get from the connection.
  """
  totalCount: Int!
}

"""
A `UserMedicamentDay` edge in the connection, with data from `UserMedicament`.
"""
type MedicamentUserMedicamentDaysByUserMedicamentMedicamentIdAndUserMedicamentDayIdManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `UserMedicamentDay` at the end of the edge."""
  node: UserMedicamentDay

  """Reads and enables pagination through a set of `UserMedicament`."""
  userMedicaments(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `UserMedicament`."""
    orderBy: [UserMedicamentsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: UserMedicamentCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: UserMedicamentFilter
  ): UserMedicamentsConnection!
}

"""Methods to use when ordering `UserMedicamentDay`."""
enum UserMedicamentDaysOrderBy {
  NATURAL
  MONDAY_ASC
  MONDAY_DESC
  TUESDAY_ASC
  TUESDAY_DESC
  WEDNESDAY_ASC
  WEDNESDAY_DESC
  THURSDAY_ASC
  THURSDAY_DESC
  FRIDAY_ASC
  FRIDAY_DESC
  SATURDAY_ASC
  SATURDAY_DESC
  SUNDAY_ASC
  SUNDAY_DESC
  ID_ASC
  ID_DESC
  USER_ID_ASC
  USER_ID_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `UserMedicamentDay` object types. All fields are
tested for equality and combined with a logical and.
"""
input UserMedicamentDayCondition {
  """Checks for equality with the objects `monday` field."""
  monday: Boolean

  """Checks for equality with the objects `tuesday` field."""
  tuesday: Boolean

  """Checks for equality with the objects `wednesday` field."""
  wednesday: Boolean

  """Checks for equality with the objects `thursday` field."""
  thursday: Boolean

  """Checks for equality with the objects `friday` field."""
  friday: Boolean

  """Checks for equality with the objects `saturday` field."""
  saturday: Boolean

  """Checks for equality with the objects `sunday` field."""
  sunday: Boolean

  """Checks for equality with the objects `id` field."""
  id: Int

  """Checks for equality with the objects `userId` field."""
  userId: Int
}

"""
A filter to be used against `UserMedicamentDay` object types. All fields are combined with a logical and.
"""
input UserMedicamentDayFilter {
  """Filter by the objects `monday` field."""
  monday: BooleanFilter

  """Filter by the objects `tuesday` field."""
  tuesday: BooleanFilter

  """Filter by the objects `wednesday` field."""
  wednesday: BooleanFilter

  """Filter by the objects `thursday` field."""
  thursday: BooleanFilter

  """Filter by the objects `friday` field."""
  friday: BooleanFilter

  """Filter by the objects `saturday` field."""
  saturday: BooleanFilter

  """Filter by the objects `sunday` field."""
  sunday: BooleanFilter

  """Filter by the objects `id` field."""
  id: IntFilter

  """Filter by the objects `userId` field."""
  userId: IntFilter

  """Checks for all expressions in this list."""
  and: [UserMedicamentDayFilter!]

  """Checks for any expressions in this list."""
  or: [UserMedicamentDayFilter!]

  """Negates the expression."""
  not: UserMedicamentDayFilter
}

"""
A connection to a list of `Admin` values, with data from `AdminMedicamentDescription`.
"""
type MedicamentAdminsByAdminMedicamentDescriptionMedicamentIdAndAdminIdManyToManyConnection {
  """A list of `Admin` objects."""
  nodes: [Admin]!

  """
  A list of edges which contains the `Admin`, info from the `AdminMedicamentDescription`, and the cursor to aid in pagination.
  """
  edges: [MedicamentAdminsByAdminMedicamentDescriptionMedicamentIdAndAdminIdManyToManyEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Admin` you could get from the connection."""
  totalCount: Int!
}

"""
A `Admin` edge in the connection, with data from `AdminMedicamentDescription`.
"""
type MedicamentAdminsByAdminMedicamentDescriptionMedicamentIdAndAdminIdManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Admin` at the end of the edge."""
  node: Admin

  """
  Reads and enables pagination through a set of `AdminMedicamentDescription`.
  """
  adminMedicamentDescriptions(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `AdminMedicamentDescription`."""
    orderBy: [AdminMedicamentDescriptionsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: AdminMedicamentDescriptionCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: AdminMedicamentDescriptionFilter
  ): AdminMedicamentDescriptionsConnection!
}

"""A connection to a list of `UserMedicamentTime` values."""
type UserMedicamentTimesConnection {
  """A list of `UserMedicamentTime` objects."""
  nodes: [UserMedicamentTime]!

  """
  A list of edges which contains the `UserMedicamentTime` and cursor to aid in pagination.
  """
  edges: [UserMedicamentTimesEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """
  The count of *all* `UserMedicamentTime` you could get from the connection.
  """
  totalCount: Int!
}

type UserMedicamentTime implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: Int!
  time: Time!
  userMedicamentId: Int!

  """
  Reads a single `UserMedicament` that is related to this `UserMedicamentTime`.
  """
  userMedicament: UserMedicament
}

"""A `UserMedicamentTime` edge in the connection."""
type UserMedicamentTimesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `UserMedicamentTime` at the end of the edge."""
  node: UserMedicamentTime
}

"""Methods to use when ordering `UserMedicamentTime`."""
enum UserMedicamentTimesOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  TIME_ASC
  TIME_DESC
  USER_MEDICAMENT_ID_ASC
  USER_MEDICAMENT_ID_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `UserMedicamentTime` object types. All fields are
tested for equality and combined with a logical and.
"""
input UserMedicamentTimeCondition {
  """Checks for equality with the objects `id` field."""
  id: Int

  """Checks for equality with the objects `time` field."""
  time: Time

  """Checks for equality with the objects `userMedicamentId` field."""
  userMedicamentId: Int
}

"""
A filter to be used against `UserMedicamentTime` object types. All fields are combined with a logical and.
"""
input UserMedicamentTimeFilter {
  """Filter by the objects `id` field."""
  id: IntFilter

  """Filter by the objects `time` field."""
  time: TimeFilter

  """Filter by the objects `userMedicamentId` field."""
  userMedicamentId: IntFilter

  """Checks for all expressions in this list."""
  and: [UserMedicamentTimeFilter!]

  """Checks for any expressions in this list."""
  or: [UserMedicamentTimeFilter!]

  """Negates the expression."""
  not: UserMedicamentTimeFilter
}

"""A `UserMedicament` edge in the connection."""
type UserMedicamentsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `UserMedicament` at the end of the edge."""
  node: UserMedicament
}

"""
A connection to a list of `User` values, with data from `UserMedicament`.
"""
type UserMedicamentDayUsersByUserMedicamentUserMedicamentDayIdAndUserIdManyToManyConnection {
  """A list of `User` objects."""
  nodes: [User]!

  """
  A list of edges which contains the `User`, info from the `UserMedicament`, and the cursor to aid in pagination.
  """
  edges: [UserMedicamentDayUsersByUserMedicamentUserMedicamentDayIdAndUserIdManyToManyEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `User` you could get from the connection."""
  totalCount: Int!
}

"""A `User` edge in the connection, with data from `UserMedicament`."""
type UserMedicamentDayUsersByUserMedicamentUserMedicamentDayIdAndUserIdManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `User` at the end of the edge."""
  node: User

  """Reads and enables pagination through a set of `UserMedicament`."""
  userMedicaments(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `UserMedicament`."""
    orderBy: [UserMedicamentsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: UserMedicamentCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: UserMedicamentFilter
  ): UserMedicamentsConnection!
}

"""
A connection to a list of `Medicament` values, with data from `UserMedicament`.
"""
type UserMedicamentDayMedicamentsByUserMedicamentUserMedicamentDayIdAndMedicamentIdManyToManyConnection {
  """A list of `Medicament` objects."""
  nodes: [Medicament]!

  """
  A list of edges which contains the `Medicament`, info from the `UserMedicament`, and the cursor to aid in pagination.
  """
  edges: [UserMedicamentDayMedicamentsByUserMedicamentUserMedicamentDayIdAndMedicamentIdManyToManyEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Medicament` you could get from the connection."""
  totalCount: Int!
}

"""
A `Medicament` edge in the connection, with data from `UserMedicament`.
"""
type UserMedicamentDayMedicamentsByUserMedicamentUserMedicamentDayIdAndMedicamentIdManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Medicament` at the end of the edge."""
  node: Medicament

  """Reads and enables pagination through a set of `UserMedicament`."""
  userMedicaments(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `UserMedicament`."""
    orderBy: [UserMedicamentsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: UserMedicamentCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: UserMedicamentFilter
  ): UserMedicamentsConnection!
}

"""Methods to use when ordering `Medicament`."""
enum MedicamentsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  CODE_ASC
  CODE_DESC
  TITLE_ASC
  TITLE_DESC
  SUPPLEMENT_ASC
  SUPPLEMENT_DESC
  STRENGTH_ASC
  STRENGTH_DESC
  PACKAGING_ASC
  PACKAGING_DESC
  HOLDER_CODE_ASC
  HOLDER_CODE_DESC
  STATE_CODE_ASC
  STATE_CODE_DESC
  ATC_CODE_ASC
  ATC_CODE_DESC
  ATC_TITLE_SK_ASC
  ATC_TITLE_SK_DESC
  INDICATION_GROUP_ASC
  INDICATION_GROUP_DESC
  REG_NUMBER_ASC
  REG_NUMBER_DESC
  EXPIRATION_ASC
  EXPIRATION_DESC
  DISPENSING_ASC
  DISPENSING_DESC
  REGISTRATION_TYPE_ASC
  REGISTRATION_TYPE_DESC
  REG_DATE_ASC
  REG_DATE_DESC
  VALIDITY_ASC
  VALIDITY_DESC
  SECURITY_FEATURE_ASC
  SECURITY_FEATURE_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Medicament` object types. All fields are tested
for equality and combined with a logical and.
"""
input MedicamentCondition {
  """Checks for equality with the objects `id` field."""
  id: Int

  """Checks for equality with the objects `code` field."""
  code: String

  """Checks for equality with the objects `title` field."""
  title: String

  """Checks for equality with the objects `supplement` field."""
  supplement: String

  """Checks for equality with the objects `strength` field."""
  strength: String

  """Checks for equality with the objects `packaging` field."""
  packaging: Int

  """Checks for equality with the objects `holderCode` field."""
  holderCode: String

  """Checks for equality with the objects `stateCode` field."""
  stateCode: String

  """Checks for equality with the objects `atcCode` field."""
  atcCode: String

  """Checks for equality with the objects `atcTitleSk` field."""
  atcTitleSk: String

  """Checks for equality with the objects `indicationGroup` field."""
  indicationGroup: String

  """Checks for equality with the objects `regNumber` field."""
  regNumber: String

  """Checks for equality with the objects `expiration` field."""
  expiration: String

  """Checks for equality with the objects `dispensing` field."""
  dispensing: String

  """Checks for equality with the objects `registrationType` field."""
  registrationType: String

  """Checks for equality with the objects `regDate` field."""
  regDate: String

  """Checks for equality with the objects `validity` field."""
  validity: String

  """Checks for equality with the objects `securityFeature` field."""
  securityFeature: Boolean
}

"""
A filter to be used against `Medicament` object types. All fields are combined with a logical and.
"""
input MedicamentFilter {
  """Filter by the objects `id` field."""
  id: IntFilter

  """Filter by the objects `code` field."""
  code: StringFilter

  """Filter by the objects `title` field."""
  title: StringFilter

  """Filter by the objects `supplement` field."""
  supplement: StringFilter

  """Filter by the objects `strength` field."""
  strength: StringFilter

  """Filter by the objects `packaging` field."""
  packaging: IntFilter

  """Filter by the objects `holderCode` field."""
  holderCode: StringFilter

  """Filter by the objects `stateCode` field."""
  stateCode: StringFilter

  """Filter by the objects `atcCode` field."""
  atcCode: StringFilter

  """Filter by the objects `atcTitleSk` field."""
  atcTitleSk: StringFilter

  """Filter by the objects `indicationGroup` field."""
  indicationGroup: StringFilter

  """Filter by the objects `regNumber` field."""
  regNumber: StringFilter

  """Filter by the objects `expiration` field."""
  expiration: StringFilter

  """Filter by the objects `dispensing` field."""
  dispensing: StringFilter

  """Filter by the objects `registrationType` field."""
  registrationType: StringFilter

  """Filter by the objects `regDate` field."""
  regDate: StringFilter

  """Filter by the objects `validity` field."""
  validity: StringFilter

  """Filter by the objects `securityFeature` field."""
  securityFeature: BooleanFilter

  """Checks for all expressions in this list."""
  and: [MedicamentFilter!]

  """Checks for any expressions in this list."""
  or: [MedicamentFilter!]

  """Negates the expression."""
  not: MedicamentFilter
}

"""
A connection to a list of `Admin` values, with data from `UserMedicament`.
"""
type UserMedicamentDayAdminsByUserMedicamentUserMedicamentDayIdAndAdminIdManyToManyConnection {
  """A list of `Admin` objects."""
  nodes: [Admin]!

  """
  A list of edges which contains the `Admin`, info from the `UserMedicament`, and the cursor to aid in pagination.
  """
  edges: [UserMedicamentDayAdminsByUserMedicamentUserMedicamentDayIdAndAdminIdManyToManyEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Admin` you could get from the connection."""
  totalCount: Int!
}

"""A `Admin` edge in the connection, with data from `UserMedicament`."""
type UserMedicamentDayAdminsByUserMedicamentUserMedicamentDayIdAndAdminIdManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Admin` at the end of the edge."""
  node: Admin

  """Reads and enables pagination through a set of `UserMedicament`."""
  userMedicaments(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `UserMedicament`."""
    orderBy: [UserMedicamentsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: UserMedicamentCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: UserMedicamentFilter
  ): UserMedicamentsConnection!
}

"""A `UserMedicamentDay` edge in the connection."""
type UserMedicamentDaysEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `UserMedicamentDay` at the end of the edge."""
  node: UserMedicamentDay
}

"""A connection to a list of `BloodCountUser` values."""
type BloodCountUsersConnection {
  """A list of `BloodCountUser` objects."""
  nodes: [BloodCountUser]!

  """
  A list of edges which contains the `BloodCountUser` and cursor to aid in pagination.
  """
  edges: [BloodCountUsersEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `BloodCountUser` you could get from the connection."""
  totalCount: Int!
}

type BloodCountUser implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: Int!
  userId: Int!
  bloodCountId: Int!

  """Reads a single `User` that is related to this `BloodCountUser`."""
  user: User

  """Reads a single `BloodCount` that is related to this `BloodCountUser`."""
  bloodCount: BloodCount

  """Reads and enables pagination through a set of `BloodCountUserValue`."""
  bloodCountUserValues(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `BloodCountUserValue`."""
    orderBy: [BloodCountUserValuesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: BloodCountUserValueCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: BloodCountUserValueFilter
  ): BloodCountUserValuesConnection!

  """Reads and enables pagination through a set of `Meeting`."""
  meetingsByBloodCountUserValueBloodCountUserIdAndMeetingId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Meeting`."""
    orderBy: [MeetingsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: MeetingCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: MeetingFilter
  ): BloodCountUserMeetingsByBloodCountUserValueBloodCountUserIdAndMeetingIdManyToManyConnection!
}

type BloodCount implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: Int!
  acronym: String!
  title: String!
  men: BigFloatRange!
  women: BigFloatRange!
  units: String
  source: String!
  description: String

  """Reads and enables pagination through a set of `BloodCountUser`."""
  bloodCountUsers(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `BloodCountUser`."""
    orderBy: [BloodCountUsersOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: BloodCountUserCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: BloodCountUserFilter
  ): BloodCountUsersConnection!

  """Reads and enables pagination through a set of `User`."""
  usersByBloodCountUserBloodCountIdAndUserId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `User`."""
    orderBy: [UsersOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: UserCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: UserFilter
  ): BloodCountUsersByBloodCountUserBloodCountIdAndUserIdManyToManyConnection!
}

"""A range of `BigFloat`."""
type BigFloatRange {
  """The starting bound of our range."""
  start: BigFloatRangeBound

  """The ending bound of our range."""
  end: BigFloatRangeBound
}

"""
The value at one end of a range. A range can either include this value, or not.
"""
type BigFloatRangeBound {
  """The value at one end of our range."""
  value: BigFloat!

  """Whether or not the value of this bound is included in the range."""
  inclusive: Boolean!
}

"""
A floating point number that requires more precision than IEEE 754 binary 64
"""
scalar BigFloat

"""Methods to use when ordering `BloodCountUser`."""
enum BloodCountUsersOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  USER_ID_ASC
  USER_ID_DESC
  BLOOD_COUNT_ID_ASC
  BLOOD_COUNT_ID_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `BloodCountUser` object types. All fields are
tested for equality and combined with a logical and.
"""
input BloodCountUserCondition {
  """Checks for equality with the objects `id` field."""
  id: Int

  """Checks for equality with the objects `userId` field."""
  userId: Int

  """Checks for equality with the objects `bloodCountId` field."""
  bloodCountId: Int
}

"""
A filter to be used against `BloodCountUser` object types. All fields are combined with a logical and.
"""
input BloodCountUserFilter {
  """Filter by the objects `id` field."""
  id: IntFilter

  """Filter by the objects `userId` field."""
  userId: IntFilter

  """Filter by the objects `bloodCountId` field."""
  bloodCountId: IntFilter

  """Checks for all expressions in this list."""
  and: [BloodCountUserFilter!]

  """Checks for any expressions in this list."""
  or: [BloodCountUserFilter!]

  """Negates the expression."""
  not: BloodCountUserFilter
}

"""
A connection to a list of `User` values, with data from `BloodCountUser`.
"""
type BloodCountUsersByBloodCountUserBloodCountIdAndUserIdManyToManyConnection {
  """A list of `User` objects."""
  nodes: [User]!

  """
  A list of edges which contains the `User`, info from the `BloodCountUser`, and the cursor to aid in pagination.
  """
  edges: [BloodCountUsersByBloodCountUserBloodCountIdAndUserIdManyToManyEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `User` you could get from the connection."""
  totalCount: Int!
}

"""A `User` edge in the connection, with data from `BloodCountUser`."""
type BloodCountUsersByBloodCountUserBloodCountIdAndUserIdManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `User` at the end of the edge."""
  node: User
  id: Int!
}

"""A connection to a list of `BloodCountUserValue` values."""
type BloodCountUserValuesConnection {
  """A list of `BloodCountUserValue` objects."""
  nodes: [BloodCountUserValue]!

  """
  A list of edges which contains the `BloodCountUserValue` and cursor to aid in pagination.
  """
  edges: [BloodCountUserValuesEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """
  The count of *all* `BloodCountUserValue` you could get from the connection.
  """
  totalCount: Int!
}

type BloodCountUserValue implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: Int!
  bloodCountUserId: Int!
  meetingId: Int
  bloodCountValue: Float!
  description: String
  createdAt: Date!

  """
  Reads a single `BloodCountUser` that is related to this `BloodCountUserValue`.
  """
  bloodCountUser: BloodCountUser

  """
  Reads a single `Meeting` that is related to this `BloodCountUserValue`.
  """
  meeting: Meeting
}

"""A `BloodCountUserValue` edge in the connection."""
type BloodCountUserValuesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `BloodCountUserValue` at the end of the edge."""
  node: BloodCountUserValue
}

"""Methods to use when ordering `BloodCountUserValue`."""
enum BloodCountUserValuesOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  BLOOD_COUNT_USER_ID_ASC
  BLOOD_COUNT_USER_ID_DESC
  MEETING_ID_ASC
  MEETING_ID_DESC
  BLOOD_COUNT_VALUE_ASC
  BLOOD_COUNT_VALUE_DESC
  DESCRIPTION_ASC
  DESCRIPTION_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `BloodCountUserValue` object types. All fields
are tested for equality and combined with a logical and.
"""
input BloodCountUserValueCondition {
  """Checks for equality with the objects `id` field."""
  id: Int

  """Checks for equality with the objects `bloodCountUserId` field."""
  bloodCountUserId: Int

  """Checks for equality with the objects `meetingId` field."""
  meetingId: Int

  """Checks for equality with the objects `bloodCountValue` field."""
  bloodCountValue: Float

  """Checks for equality with the objects `description` field."""
  description: String

  """Checks for equality with the objects `createdAt` field."""
  createdAt: Date
}

"""
A filter to be used against `BloodCountUserValue` object types. All fields are combined with a logical and.
"""
input BloodCountUserValueFilter {
  """Filter by the objects `id` field."""
  id: IntFilter

  """Filter by the objects `bloodCountUserId` field."""
  bloodCountUserId: IntFilter

  """Filter by the objects `meetingId` field."""
  meetingId: IntFilter

  """Filter by the objects `bloodCountValue` field."""
  bloodCountValue: FloatFilter

  """Filter by the objects `description` field."""
  description: StringFilter

  """Filter by the objects `createdAt` field."""
  createdAt: DateFilter

  """Checks for all expressions in this list."""
  and: [BloodCountUserValueFilter!]

  """Checks for any expressions in this list."""
  or: [BloodCountUserValueFilter!]

  """Negates the expression."""
  not: BloodCountUserValueFilter
}

"""
A filter to be used against Float fields. All fields are combined with a logical and.
"""
input FloatFilter {
  """
  Is null (if `true` is specified) or is not null (if `false` is specified).
  """
  isNull: Boolean

  """Equal to the specified value."""
  equalTo: Float

  """Not equal to the specified value."""
  notEqualTo: Float

  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: Float

  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: Float

  """Included in the specified list."""
  in: [Float!]

  """Not included in the specified list."""
  notIn: [Float!]

  """Less than the specified value."""
  lessThan: Float

  """Less than or equal to the specified value."""
  lessThanOrEqualTo: Float

  """Greater than the specified value."""
  greaterThan: Float

  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: Float
}

"""
A connection to a list of `Meeting` values, with data from `BloodCountUserValue`.
"""
type BloodCountUserMeetingsByBloodCountUserValueBloodCountUserIdAndMeetingIdManyToManyConnection {
  """A list of `Meeting` objects."""
  nodes: [Meeting]!

  """
  A list of edges which contains the `Meeting`, info from the `BloodCountUserValue`, and the cursor to aid in pagination.
  """
  edges: [BloodCountUserMeetingsByBloodCountUserValueBloodCountUserIdAndMeetingIdManyToManyEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Meeting` you could get from the connection."""
  totalCount: Int!
}

"""
A `Meeting` edge in the connection, with data from `BloodCountUserValue`.
"""
type BloodCountUserMeetingsByBloodCountUserValueBloodCountUserIdAndMeetingIdManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Meeting` at the end of the edge."""
  node: Meeting

  """Reads and enables pagination through a set of `BloodCountUserValue`."""
  bloodCountUserValues(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `BloodCountUserValue`."""
    orderBy: [BloodCountUserValuesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: BloodCountUserValueCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: BloodCountUserValueFilter
  ): BloodCountUserValuesConnection!
}

"""A `BloodCountUser` edge in the connection."""
type BloodCountUsersEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `BloodCountUser` at the end of the edge."""
  node: BloodCountUser
}

"""A connection to a list of `AmbulanceUser` values."""
type AmbulanceUsersConnection {
  """A list of `AmbulanceUser` objects."""
  nodes: [AmbulanceUser]!

  """
  A list of edges which contains the `AmbulanceUser` and cursor to aid in pagination.
  """
  edges: [AmbulanceUsersEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `AmbulanceUser` you could get from the connection."""
  totalCount: Int!
}

type AmbulanceUser implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: Int!
  ambulanceId: Int!
  userId: Int!

  """Reads a single `Ambulance` that is related to this `AmbulanceUser`."""
  ambulance: Ambulance

  """Reads a single `User` that is related to this `AmbulanceUser`."""
  user: User
}

"""A `AmbulanceUser` edge in the connection."""
type AmbulanceUsersEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `AmbulanceUser` at the end of the edge."""
  node: AmbulanceUser
}

"""Methods to use when ordering `AmbulanceUser`."""
enum AmbulanceUsersOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  AMBULANCE_ID_ASC
  AMBULANCE_ID_DESC
  USER_ID_ASC
  USER_ID_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `AmbulanceUser` object types. All fields are
tested for equality and combined with a logical and.
"""
input AmbulanceUserCondition {
  """Checks for equality with the objects `id` field."""
  id: Int

  """Checks for equality with the objects `ambulanceId` field."""
  ambulanceId: Int

  """Checks for equality with the objects `userId` field."""
  userId: Int
}

"""
A filter to be used against `AmbulanceUser` object types. All fields are combined with a logical and.
"""
input AmbulanceUserFilter {
  """Filter by the objects `id` field."""
  id: IntFilter

  """Filter by the objects `ambulanceId` field."""
  ambulanceId: IntFilter

  """Filter by the objects `userId` field."""
  userId: IntFilter

  """Checks for all expressions in this list."""
  and: [AmbulanceUserFilter!]

  """Checks for any expressions in this list."""
  or: [AmbulanceUserFilter!]

  """Negates the expression."""
  not: AmbulanceUserFilter
}

"""A connection to a list of `Admin` values, with data from `Meeting`."""
type UserAdminsByMeetingUserIdAndAdminIdManyToManyConnection {
  """A list of `Admin` objects."""
  nodes: [Admin]!

  """
  A list of edges which contains the `Admin`, info from the `Meeting`, and the cursor to aid in pagination.
  """
  edges: [UserAdminsByMeetingUserIdAndAdminIdManyToManyEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Admin` you could get from the connection."""
  totalCount: Int!
}

"""A `Admin` edge in the connection, with data from `Meeting`."""
type UserAdminsByMeetingUserIdAndAdminIdManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Admin` at the end of the edge."""
  node: Admin

  """Reads and enables pagination through a set of `Meeting`."""
  meetings(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Meeting`."""
    orderBy: [MeetingsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: MeetingCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: MeetingFilter
  ): MeetingsConnection!
}

"""
A connection to a list of `Ambulance` values, with data from `Meeting`.
"""
type UserAmbulancesByMeetingUserIdAndAmbulanceIdManyToManyConnection {
  """A list of `Ambulance` objects."""
  nodes: [Ambulance]!

  """
  A list of edges which contains the `Ambulance`, info from the `Meeting`, and the cursor to aid in pagination.
  """
  edges: [UserAmbulancesByMeetingUserIdAndAmbulanceIdManyToManyEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Ambulance` you could get from the connection."""
  totalCount: Int!
}

"""A `Ambulance` edge in the connection, with data from `Meeting`."""
type UserAmbulancesByMeetingUserIdAndAmbulanceIdManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Ambulance` at the end of the edge."""
  node: Ambulance

  """Reads and enables pagination through a set of `Meeting`."""
  meetings(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Meeting`."""
    orderBy: [MeetingsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: MeetingCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: MeetingFilter
  ): MeetingsConnection!
}

"""
A connection to a list of `Diagnosis` values, with data from `UserDiagnosis`.
"""
type UserDiagnosesByUserDiagnosisUserIdAndDiagnosisIdManyToManyConnection {
  """A list of `Diagnosis` objects."""
  nodes: [Diagnosis]!

  """
  A list of edges which contains the `Diagnosis`, info from the `UserDiagnosis`, and the cursor to aid in pagination.
  """
  edges: [UserDiagnosesByUserDiagnosisUserIdAndDiagnosisIdManyToManyEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Diagnosis` you could get from the connection."""
  totalCount: Int!
}

"""A `Diagnosis` edge in the connection, with data from `UserDiagnosis`."""
type UserDiagnosesByUserDiagnosisUserIdAndDiagnosisIdManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Diagnosis` at the end of the edge."""
  node: Diagnosis

  """Reads and enables pagination through a set of `UserDiagnosis`."""
  userDiagnoses(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `UserDiagnosis`."""
    orderBy: [UserDiagnosesOrderBy!] = [NATURAL]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: UserDiagnosisCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: UserDiagnosisFilter
  ): UserDiagnosesConnection!
}

"""
A connection to a list of `Medicament` values, with data from `UserMedicament`.
"""
type UserMedicamentsByUserMedicamentUserIdAndMedicamentIdManyToManyConnection {
  """A list of `Medicament` objects."""
  nodes: [Medicament]!

  """
  A list of edges which contains the `Medicament`, info from the `UserMedicament`, and the cursor to aid in pagination.
  """
  edges: [UserMedicamentsByUserMedicamentUserIdAndMedicamentIdManyToManyEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Medicament` you could get from the connection."""
  totalCount: Int!
}

"""
A `Medicament` edge in the connection, with data from `UserMedicament`.
"""
type UserMedicamentsByUserMedicamentUserIdAndMedicamentIdManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Medicament` at the end of the edge."""
  node: Medicament

  """Reads and enables pagination through a set of `UserMedicament`."""
  userMedicaments(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `UserMedicament`."""
    orderBy: [UserMedicamentsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: UserMedicamentCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: UserMedicamentFilter
  ): UserMedicamentsConnection!
}

"""
A connection to a list of `Admin` values, with data from `UserMedicament`.
"""
type UserAdminsByUserMedicamentUserIdAndAdminIdManyToManyConnection {
  """A list of `Admin` objects."""
  nodes: [Admin]!

  """
  A list of edges which contains the `Admin`, info from the `UserMedicament`, and the cursor to aid in pagination.
  """
  edges: [UserAdminsByUserMedicamentUserIdAndAdminIdManyToManyEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Admin` you could get from the connection."""
  totalCount: Int!
}

"""A `Admin` edge in the connection, with data from `UserMedicament`."""
type UserAdminsByUserMedicamentUserIdAndAdminIdManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Admin` at the end of the edge."""
  node: Admin

  """Reads and enables pagination through a set of `UserMedicament`."""
  userMedicaments(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `UserMedicament`."""
    orderBy: [UserMedicamentsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: UserMedicamentCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: UserMedicamentFilter
  ): UserMedicamentsConnection!
}

"""
A connection to a list of `UserMedicamentDay` values, with data from `UserMedicament`.
"""
type UserUserMedicamentDaysByUserMedicamentUserIdAndUserMedicamentDayIdManyToManyConnection {
  """A list of `UserMedicamentDay` objects."""
  nodes: [UserMedicamentDay]!

  """
  A list of edges which contains the `UserMedicamentDay`, info from the `UserMedicament`, and the cursor to aid in pagination.
  """
  edges: [UserUserMedicamentDaysByUserMedicamentUserIdAndUserMedicamentDayIdManyToManyEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """
  The count of *all* `UserMedicamentDay` you could get from the connection.
  """
  totalCount: Int!
}

"""
A `UserMedicamentDay` edge in the connection, with data from `UserMedicament`.
"""
type UserUserMedicamentDaysByUserMedicamentUserIdAndUserMedicamentDayIdManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `UserMedicamentDay` at the end of the edge."""
  node: UserMedicamentDay

  """Reads and enables pagination through a set of `UserMedicament`."""
  userMedicaments(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `UserMedicament`."""
    orderBy: [UserMedicamentsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: UserMedicamentCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: UserMedicamentFilter
  ): UserMedicamentsConnection!
}

"""
A connection to a list of `BloodCount` values, with data from `BloodCountUser`.
"""
type UserBloodCountsByBloodCountUserUserIdAndBloodCountIdManyToManyConnection {
  """A list of `BloodCount` objects."""
  nodes: [BloodCount]!

  """
  A list of edges which contains the `BloodCount`, info from the `BloodCountUser`, and the cursor to aid in pagination.
  """
  edges: [UserBloodCountsByBloodCountUserUserIdAndBloodCountIdManyToManyEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `BloodCount` you could get from the connection."""
  totalCount: Int!
}

"""
A `BloodCount` edge in the connection, with data from `BloodCountUser`.
"""
type UserBloodCountsByBloodCountUserUserIdAndBloodCountIdManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `BloodCount` at the end of the edge."""
  node: BloodCount
  id: Int!
}

"""Methods to use when ordering `BloodCount`."""
enum BloodCountsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  ACRONYM_ASC
  ACRONYM_DESC
  TITLE_ASC
  TITLE_DESC
  MEN_ASC
  MEN_DESC
  WOMEN_ASC
  WOMEN_DESC
  UNITS_ASC
  UNITS_DESC
  SOURCE_ASC
  SOURCE_DESC
  DESCRIPTION_ASC
  DESCRIPTION_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `BloodCount` object types. All fields are tested
for equality and combined with a logical and.
"""
input BloodCountCondition {
  """Checks for equality with the objects `id` field."""
  id: Int

  """Checks for equality with the objects `acronym` field."""
  acronym: String

  """Checks for equality with the objects `title` field."""
  title: String

  """Checks for equality with the objects `men` field."""
  men: BigFloatRangeInput

  """Checks for equality with the objects `women` field."""
  women: BigFloatRangeInput

  """Checks for equality with the objects `units` field."""
  units: String

  """Checks for equality with the objects `source` field."""
  source: String

  """Checks for equality with the objects `description` field."""
  description: String
}

"""A range of `BigFloat`."""
input BigFloatRangeInput {
  """The starting bound of our range."""
  start: BigFloatRangeBoundInput

  """The ending bound of our range."""
  end: BigFloatRangeBoundInput
}

"""
The value at one end of a range. A range can either include this value, or not.
"""
input BigFloatRangeBoundInput {
  """The value at one end of our range."""
  value: BigFloat!

  """Whether or not the value of this bound is included in the range."""
  inclusive: Boolean!
}

"""
A filter to be used against `BloodCount` object types. All fields are combined with a logical and.
"""
input BloodCountFilter {
  """Filter by the objects `id` field."""
  id: IntFilter

  """Filter by the objects `acronym` field."""
  acronym: StringFilter

  """Filter by the objects `title` field."""
  title: StringFilter

  """Filter by the objects `men` field."""
  men: BigFloatRangeFilter

  """Filter by the objects `women` field."""
  women: BigFloatRangeFilter

  """Filter by the objects `units` field."""
  units: StringFilter

  """Filter by the objects `source` field."""
  source: StringFilter

  """Filter by the objects `description` field."""
  description: StringFilter

  """Checks for all expressions in this list."""
  and: [BloodCountFilter!]

  """Checks for any expressions in this list."""
  or: [BloodCountFilter!]

  """Negates the expression."""
  not: BloodCountFilter
}

"""
A filter to be used against BigFloatRange fields. All fields are combined with a logical and.
"""
input BigFloatRangeFilter {
  """
  Is null (if `true` is specified) or is not null (if `false` is specified).
  """
  isNull: Boolean

  """Equal to the specified value."""
  equalTo: BigFloatRangeInput

  """Not equal to the specified value."""
  notEqualTo: BigFloatRangeInput

  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: BigFloatRangeInput

  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: BigFloatRangeInput

  """Included in the specified list."""
  in: [BigFloatRangeInput!]

  """Not included in the specified list."""
  notIn: [BigFloatRangeInput!]

  """Less than the specified value."""
  lessThan: BigFloatRangeInput

  """Less than or equal to the specified value."""
  lessThanOrEqualTo: BigFloatRangeInput

  """Greater than the specified value."""
  greaterThan: BigFloatRangeInput

  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: BigFloatRangeInput

  """Contains the specified range."""
  contains: BigFloatRangeInput

  """Contains the specified value."""
  containsElement: BigFloat

  """Contained by the specified range."""
  containedBy: BigFloatRangeInput

  """Overlaps the specified range."""
  overlaps: BigFloatRangeInput

  """Strictly left of the specified range."""
  strictlyLeftOf: BigFloatRangeInput

  """Strictly right of the specified range."""
  strictlyRightOf: BigFloatRangeInput

  """Does not extend right of the specified range."""
  notExtendsRightOf: BigFloatRangeInput

  """Does not extend left of the specified range."""
  notExtendsLeftOf: BigFloatRangeInput

  """Adjacent to the specified range."""
  adjacentTo: BigFloatRangeInput
}

"""
A connection to a list of `Ambulance` values, with data from `AmbulanceUser`.
"""
type UserAmbulancesByAmbulanceUserUserIdAndAmbulanceIdManyToManyConnection {
  """A list of `Ambulance` objects."""
  nodes: [Ambulance]!

  """
  A list of edges which contains the `Ambulance`, info from the `AmbulanceUser`, and the cursor to aid in pagination.
  """
  edges: [UserAmbulancesByAmbulanceUserUserIdAndAmbulanceIdManyToManyEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Ambulance` you could get from the connection."""
  totalCount: Int!
}

"""A `Ambulance` edge in the connection, with data from `AmbulanceUser`."""
type UserAmbulancesByAmbulanceUserUserIdAndAmbulanceIdManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Ambulance` at the end of the edge."""
  node: Ambulance
  id: Int!
}

"""
A connection to a list of `BloodCountUser` values, with data from `BloodCountUserValue`.
"""
type MeetingBloodCountUsersByBloodCountUserValueMeetingIdAndBloodCountUserIdManyToManyConnection {
  """A list of `BloodCountUser` objects."""
  nodes: [BloodCountUser]!

  """
  A list of edges which contains the `BloodCountUser`, info from the `BloodCountUserValue`, and the cursor to aid in pagination.
  """
  edges: [MeetingBloodCountUsersByBloodCountUserValueMeetingIdAndBloodCountUserIdManyToManyEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `BloodCountUser` you could get from the connection."""
  totalCount: Int!
}

"""
A `BloodCountUser` edge in the connection, with data from `BloodCountUserValue`.
"""
type MeetingBloodCountUsersByBloodCountUserValueMeetingIdAndBloodCountUserIdManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `BloodCountUser` at the end of the edge."""
  node: BloodCountUser

  """Reads and enables pagination through a set of `BloodCountUserValue`."""
  bloodCountUserValues(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `BloodCountUserValue`."""
    orderBy: [BloodCountUserValuesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: BloodCountUserValueCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: BloodCountUserValueFilter
  ): BloodCountUserValuesConnection!
}

"""A `Meeting` edge in the connection."""
type MeetingsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Meeting` at the end of the edge."""
  node: Meeting
}

"""A connection to a list of `MeetingHour` values."""
type MeetingHoursConnection {
  """A list of `MeetingHour` objects."""
  nodes: [MeetingHour]!

  """
  A list of edges which contains the `MeetingHour` and cursor to aid in pagination.
  """
  edges: [MeetingHoursEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `MeetingHour` you could get from the connection."""
  totalCount: Int!
}

type MeetingHour implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: Int!
  adminId: Int!
  ambulanceId: Int!
  startHours: JSON
  endHours: JSON
  interval: Int

  """Reads a single `Admin` that is related to this `MeetingHour`."""
  admin: Admin

  """Reads a single `Ambulance` that is related to this `MeetingHour`."""
  ambulance: Ambulance
}

"""
The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSON

"""A `MeetingHour` edge in the connection."""
type MeetingHoursEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `MeetingHour` at the end of the edge."""
  node: MeetingHour
}

"""Methods to use when ordering `MeetingHour`."""
enum MeetingHoursOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  ADMIN_ID_ASC
  ADMIN_ID_DESC
  AMBULANCE_ID_ASC
  AMBULANCE_ID_DESC
  START_HOURS_ASC
  START_HOURS_DESC
  END_HOURS_ASC
  END_HOURS_DESC
  INTERVAL_ASC
  INTERVAL_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `MeetingHour` object types. All fields are tested
for equality and combined with a logical and.
"""
input MeetingHourCondition {
  """Checks for equality with the objects `id` field."""
  id: Int

  """Checks for equality with the objects `adminId` field."""
  adminId: Int

  """Checks for equality with the objects `ambulanceId` field."""
  ambulanceId: Int

  """Checks for equality with the objects `startHours` field."""
  startHours: JSON

  """Checks for equality with the objects `endHours` field."""
  endHours: JSON

  """Checks for equality with the objects `interval` field."""
  interval: Int
}

"""
A filter to be used against `MeetingHour` object types. All fields are combined with a logical and.
"""
input MeetingHourFilter {
  """Filter by the objects `id` field."""
  id: IntFilter

  """Filter by the objects `adminId` field."""
  adminId: IntFilter

  """Filter by the objects `ambulanceId` field."""
  ambulanceId: IntFilter

  """Filter by the objects `interval` field."""
  interval: IntFilter

  """Checks for all expressions in this list."""
  and: [MeetingHourFilter!]

  """Checks for any expressions in this list."""
  or: [MeetingHourFilter!]

  """Negates the expression."""
  not: MeetingHourFilter
}

"""A connection to a list of `User` values, with data from `Meeting`."""
type AmbulanceUsersByMeetingAmbulanceIdAndUserIdManyToManyConnection {
  """A list of `User` objects."""
  nodes: [User]!

  """
  A list of edges which contains the `User`, info from the `Meeting`, and the cursor to aid in pagination.
  """
  edges: [AmbulanceUsersByMeetingAmbulanceIdAndUserIdManyToManyEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `User` you could get from the connection."""
  totalCount: Int!
}

"""A `User` edge in the connection, with data from `Meeting`."""
type AmbulanceUsersByMeetingAmbulanceIdAndUserIdManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `User` at the end of the edge."""
  node: User

  """Reads and enables pagination through a set of `Meeting`."""
  meetings(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Meeting`."""
    orderBy: [MeetingsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: MeetingCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: MeetingFilter
  ): MeetingsConnection!
}

"""A connection to a list of `Admin` values, with data from `Meeting`."""
type AmbulanceAdminsByMeetingAmbulanceIdAndAdminIdManyToManyConnection {
  """A list of `Admin` objects."""
  nodes: [Admin]!

  """
  A list of edges which contains the `Admin`, info from the `Meeting`, and the cursor to aid in pagination.
  """
  edges: [AmbulanceAdminsByMeetingAmbulanceIdAndAdminIdManyToManyEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Admin` you could get from the connection."""
  totalCount: Int!
}

"""A `Admin` edge in the connection, with data from `Meeting`."""
type AmbulanceAdminsByMeetingAmbulanceIdAndAdminIdManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Admin` at the end of the edge."""
  node: Admin

  """Reads and enables pagination through a set of `Meeting`."""
  meetings(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Meeting`."""
    orderBy: [MeetingsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: MeetingCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: MeetingFilter
  ): MeetingsConnection!
}

"""
A connection to a list of `User` values, with data from `AmbulanceUser`.
"""
type AmbulanceUsersByAmbulanceUserAmbulanceIdAndUserIdManyToManyConnection {
  """A list of `User` objects."""
  nodes: [User]!

  """
  A list of edges which contains the `User`, info from the `AmbulanceUser`, and the cursor to aid in pagination.
  """
  edges: [AmbulanceUsersByAmbulanceUserAmbulanceIdAndUserIdManyToManyEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `User` you could get from the connection."""
  totalCount: Int!
}

"""A `User` edge in the connection, with data from `AmbulanceUser`."""
type AmbulanceUsersByAmbulanceUserAmbulanceIdAndUserIdManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `User` at the end of the edge."""
  node: User
  id: Int!
}

"""
A connection to a list of `Admin` values, with data from `MeetingHour`.
"""
type AmbulanceAdminsByMeetingHourAmbulanceIdAndAdminIdManyToManyConnection {
  """A list of `Admin` objects."""
  nodes: [Admin]!

  """
  A list of edges which contains the `Admin`, info from the `MeetingHour`, and the cursor to aid in pagination.
  """
  edges: [AmbulanceAdminsByMeetingHourAmbulanceIdAndAdminIdManyToManyEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Admin` you could get from the connection."""
  totalCount: Int!
}

"""A `Admin` edge in the connection, with data from `MeetingHour`."""
type AmbulanceAdminsByMeetingHourAmbulanceIdAndAdminIdManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Admin` at the end of the edge."""
  node: Admin

  """Reads and enables pagination through a set of `MeetingHour`."""
  meetingHours(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `MeetingHour`."""
    orderBy: [MeetingHoursOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: MeetingHourCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: MeetingHourFilter
  ): MeetingHoursConnection!
}

"""A connection to a list of `User` values, with data from `Meeting`."""
type AdminUsersByMeetingAdminIdAndUserIdManyToManyConnection {
  """A list of `User` objects."""
  nodes: [User]!

  """
  A list of edges which contains the `User`, info from the `Meeting`, and the cursor to aid in pagination.
  """
  edges: [AdminUsersByMeetingAdminIdAndUserIdManyToManyEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `User` you could get from the connection."""
  totalCount: Int!
}

"""A `User` edge in the connection, with data from `Meeting`."""
type AdminUsersByMeetingAdminIdAndUserIdManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `User` at the end of the edge."""
  node: User

  """Reads and enables pagination through a set of `Meeting`."""
  meetings(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Meeting`."""
    orderBy: [MeetingsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: MeetingCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: MeetingFilter
  ): MeetingsConnection!
}

"""
A connection to a list of `Ambulance` values, with data from `Meeting`.
"""
type AdminAmbulancesByMeetingAdminIdAndAmbulanceIdManyToManyConnection {
  """A list of `Ambulance` objects."""
  nodes: [Ambulance]!

  """
  A list of edges which contains the `Ambulance`, info from the `Meeting`, and the cursor to aid in pagination.
  """
  edges: [AdminAmbulancesByMeetingAdminIdAndAmbulanceIdManyToManyEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Ambulance` you could get from the connection."""
  totalCount: Int!
}

"""A `Ambulance` edge in the connection, with data from `Meeting`."""
type AdminAmbulancesByMeetingAdminIdAndAmbulanceIdManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Ambulance` at the end of the edge."""
  node: Ambulance

  """Reads and enables pagination through a set of `Meeting`."""
  meetings(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Meeting`."""
    orderBy: [MeetingsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: MeetingCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: MeetingFilter
  ): MeetingsConnection!
}

"""
A connection to a list of `User` values, with data from `UserMedicament`.
"""
type AdminUsersByUserMedicamentAdminIdAndUserIdManyToManyConnection {
  """A list of `User` objects."""
  nodes: [User]!

  """
  A list of edges which contains the `User`, info from the `UserMedicament`, and the cursor to aid in pagination.
  """
  edges: [AdminUsersByUserMedicamentAdminIdAndUserIdManyToManyEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `User` you could get from the connection."""
  totalCount: Int!
}

"""A `User` edge in the connection, with data from `UserMedicament`."""
type AdminUsersByUserMedicamentAdminIdAndUserIdManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `User` at the end of the edge."""
  node: User

  """Reads and enables pagination through a set of `UserMedicament`."""
  userMedicaments(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `UserMedicament`."""
    orderBy: [UserMedicamentsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: UserMedicamentCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: UserMedicamentFilter
  ): UserMedicamentsConnection!
}

"""
A connection to a list of `Medicament` values, with data from `UserMedicament`.
"""
type AdminMedicamentsByUserMedicamentAdminIdAndMedicamentIdManyToManyConnection {
  """A list of `Medicament` objects."""
  nodes: [Medicament]!

  """
  A list of edges which contains the `Medicament`, info from the `UserMedicament`, and the cursor to aid in pagination.
  """
  edges: [AdminMedicamentsByUserMedicamentAdminIdAndMedicamentIdManyToManyEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Medicament` you could get from the connection."""
  totalCount: Int!
}

"""
A `Medicament` edge in the connection, with data from `UserMedicament`.
"""
type AdminMedicamentsByUserMedicamentAdminIdAndMedicamentIdManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Medicament` at the end of the edge."""
  node: Medicament

  """Reads and enables pagination through a set of `UserMedicament`."""
  userMedicaments(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `UserMedicament`."""
    orderBy: [UserMedicamentsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: UserMedicamentCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: UserMedicamentFilter
  ): UserMedicamentsConnection!
}

"""
A connection to a list of `UserMedicamentDay` values, with data from `UserMedicament`.
"""
type AdminUserMedicamentDaysByUserMedicamentAdminIdAndUserMedicamentDayIdManyToManyConnection {
  """A list of `UserMedicamentDay` objects."""
  nodes: [UserMedicamentDay]!

  """
  A list of edges which contains the `UserMedicamentDay`, info from the `UserMedicament`, and the cursor to aid in pagination.
  """
  edges: [AdminUserMedicamentDaysByUserMedicamentAdminIdAndUserMedicamentDayIdManyToManyEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """
  The count of *all* `UserMedicamentDay` you could get from the connection.
  """
  totalCount: Int!
}

"""
A `UserMedicamentDay` edge in the connection, with data from `UserMedicament`.
"""
type AdminUserMedicamentDaysByUserMedicamentAdminIdAndUserMedicamentDayIdManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `UserMedicamentDay` at the end of the edge."""
  node: UserMedicamentDay

  """Reads and enables pagination through a set of `UserMedicament`."""
  userMedicaments(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `UserMedicament`."""
    orderBy: [UserMedicamentsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: UserMedicamentCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: UserMedicamentFilter
  ): UserMedicamentsConnection!
}

"""
A connection to a list of `Medicament` values, with data from `AdminMedicamentDescription`.
"""
type AdminMedicamentsByAdminMedicamentDescriptionAdminIdAndMedicamentIdManyToManyConnection {
  """A list of `Medicament` objects."""
  nodes: [Medicament]!

  """
  A list of edges which contains the `Medicament`, info from the `AdminMedicamentDescription`, and the cursor to aid in pagination.
  """
  edges: [AdminMedicamentsByAdminMedicamentDescriptionAdminIdAndMedicamentIdManyToManyEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Medicament` you could get from the connection."""
  totalCount: Int!
}

"""
A `Medicament` edge in the connection, with data from `AdminMedicamentDescription`.
"""
type AdminMedicamentsByAdminMedicamentDescriptionAdminIdAndMedicamentIdManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Medicament` at the end of the edge."""
  node: Medicament

  """
  Reads and enables pagination through a set of `AdminMedicamentDescription`.
  """
  adminMedicamentDescriptions(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `AdminMedicamentDescription`."""
    orderBy: [AdminMedicamentDescriptionsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: AdminMedicamentDescriptionCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: AdminMedicamentDescriptionFilter
  ): AdminMedicamentDescriptionsConnection!
}

"""
A connection to a list of `Ambulance` values, with data from `MeetingHour`.
"""
type AdminAmbulancesByMeetingHourAdminIdAndAmbulanceIdManyToManyConnection {
  """A list of `Ambulance` objects."""
  nodes: [Ambulance]!

  """
  A list of edges which contains the `Ambulance`, info from the `MeetingHour`, and the cursor to aid in pagination.
  """
  edges: [AdminAmbulancesByMeetingHourAdminIdAndAmbulanceIdManyToManyEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Ambulance` you could get from the connection."""
  totalCount: Int!
}

"""A `Ambulance` edge in the connection, with data from `MeetingHour`."""
type AdminAmbulancesByMeetingHourAdminIdAndAmbulanceIdManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Ambulance` at the end of the edge."""
  node: Ambulance

  """Reads and enables pagination through a set of `MeetingHour`."""
  meetingHours(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `MeetingHour`."""
    orderBy: [MeetingHoursOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: MeetingHourCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: MeetingHourFilter
  ): MeetingHoursConnection!
}

"""A `Admin` edge in the connection."""
type AdminsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Admin` at the end of the edge."""
  node: Admin
}

"""A connection to a list of `BloodCount` values."""
type BloodCountsConnection {
  """A list of `BloodCount` objects."""
  nodes: [BloodCount]!

  """
  A list of edges which contains the `BloodCount` and cursor to aid in pagination.
  """
  edges: [BloodCountsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `BloodCount` you could get from the connection."""
  totalCount: Int!
}

"""A `BloodCount` edge in the connection."""
type BloodCountsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `BloodCount` at the end of the edge."""
  node: BloodCount
}

"""A connection to a list of `BloodType` values."""
type BloodTypesConnection {
  """A list of `BloodType` objects."""
  nodes: [BloodType]!

  """
  A list of edges which contains the `BloodType` and cursor to aid in pagination.
  """
  edges: [BloodTypesEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `BloodType` you could get from the connection."""
  totalCount: Int!
}

"""A `BloodType` edge in the connection."""
type BloodTypesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `BloodType` at the end of the edge."""
  node: BloodType
}

"""A connection to a list of `DiagnosisGroup` values."""
type DiagnosisGroupsConnection {
  """A list of `DiagnosisGroup` objects."""
  nodes: [DiagnosisGroup]!

  """
  A list of edges which contains the `DiagnosisGroup` and cursor to aid in pagination.
  """
  edges: [DiagnosisGroupsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `DiagnosisGroup` you could get from the connection."""
  totalCount: Int!
}

"""A `DiagnosisGroup` edge in the connection."""
type DiagnosisGroupsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `DiagnosisGroup` at the end of the edge."""
  node: DiagnosisGroup
}

"""A connection to a list of `InsuranceCompany` values."""
type InsuranceCompaniesConnection {
  """A list of `InsuranceCompany` objects."""
  nodes: [InsuranceCompany]!

  """
  A list of edges which contains the `InsuranceCompany` and cursor to aid in pagination.
  """
  edges: [InsuranceCompaniesEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """
  The count of *all* `InsuranceCompany` you could get from the connection.
  """
  totalCount: Int!
}

"""A `InsuranceCompany` edge in the connection."""
type InsuranceCompaniesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `InsuranceCompany` at the end of the edge."""
  node: InsuranceCompany
}

"""A connection to a list of `Medicament` values."""
type MedicamentsConnection {
  """A list of `Medicament` objects."""
  nodes: [Medicament]!

  """
  A list of edges which contains the `Medicament` and cursor to aid in pagination.
  """
  edges: [MedicamentsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Medicament` you could get from the connection."""
  totalCount: Int!
}

"""A `Medicament` edge in the connection."""
type MedicamentsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Medicament` at the end of the edge."""
  node: Medicament
}

"""A connection to a list of `Ref` values."""
type RefsConnection {
  """A list of `Ref` objects."""
  nodes: [Ref]!

  """
  A list of edges which contains the `Ref` and cursor to aid in pagination.
  """
  edges: [RefsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Ref` you could get from the connection."""
  totalCount: Int!
}

type Ref implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  name: String
  short: String
  unit: String
  id: Int!

  """Reads and enables pagination through a set of `RefRange`."""
  refRanges(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `RefRange`."""
    orderBy: [RefRangesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: RefRangeCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: RefRangeFilter
  ): RefRangesConnection!
}

"""A connection to a list of `RefRange` values."""
type RefRangesConnection {
  """A list of `RefRange` objects."""
  nodes: [RefRange]!

  """
  A list of edges which contains the `RefRange` and cursor to aid in pagination.
  """
  edges: [RefRangesEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `RefRange` you could get from the connection."""
  totalCount: Int!
}

type RefRange implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: Int!
  vek: String
  m: String
  z: String
  refId: Int

  """Reads a single `Ref` that is related to this `RefRange`."""
  ref: Ref
}

"""A `RefRange` edge in the connection."""
type RefRangesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `RefRange` at the end of the edge."""
  node: RefRange
}

"""Methods to use when ordering `RefRange`."""
enum RefRangesOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  VEK_ASC
  VEK_DESC
  M_ASC
  M_DESC
  Z_ASC
  Z_DESC
  REF_ID_ASC
  REF_ID_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `RefRange` object types. All fields are tested
for equality and combined with a logical and.
"""
input RefRangeCondition {
  """Checks for equality with the objects `id` field."""
  id: Int

  """Checks for equality with the objects `vek` field."""
  vek: String

  """Checks for equality with the objects `m` field."""
  m: String

  """Checks for equality with the objects `z` field."""
  z: String

  """Checks for equality with the objects `refId` field."""
  refId: Int
}

"""
A filter to be used against `RefRange` object types. All fields are combined with a logical and.
"""
input RefRangeFilter {
  """Filter by the objects `id` field."""
  id: IntFilter

  """Filter by the objects `vek` field."""
  vek: StringFilter

  """Filter by the objects `m` field."""
  m: StringFilter

  """Filter by the objects `z` field."""
  z: StringFilter

  """Filter by the objects `refId` field."""
  refId: IntFilter

  """Checks for all expressions in this list."""
  and: [RefRangeFilter!]

  """Checks for any expressions in this list."""
  or: [RefRangeFilter!]

  """Negates the expression."""
  not: RefRangeFilter
}

"""A `Ref` edge in the connection."""
type RefsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Ref` at the end of the edge."""
  node: Ref
}

"""Methods to use when ordering `Ref`."""
enum RefsOrderBy {
  NATURAL
  NAME_ASC
  NAME_DESC
  SHORT_ASC
  SHORT_DESC
  UNIT_ASC
  UNIT_DESC
  ID_ASC
  ID_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Ref` object types. All fields are tested for equality and combined with a logical and.
"""
input RefCondition {
  """Checks for equality with the objects `name` field."""
  name: String

  """Checks for equality with the objects `short` field."""
  short: String

  """Checks for equality with the objects `unit` field."""
  unit: String

  """Checks for equality with the objects `id` field."""
  id: Int
}

"""
A filter to be used against `Ref` object types. All fields are combined with a logical and.
"""
input RefFilter {
  """Filter by the objects `name` field."""
  name: StringFilter

  """Filter by the objects `short` field."""
  short: StringFilter

  """Filter by the objects `unit` field."""
  unit: StringFilter

  """Filter by the objects `id` field."""
  id: IntFilter

  """Checks for all expressions in this list."""
  and: [RefFilter!]

  """Checks for any expressions in this list."""
  or: [RefFilter!]

  """Negates the expression."""
  not: RefFilter
}

"""A connection to a list of `Region` values."""
type RegionsConnection {
  """A list of `Region` objects."""
  nodes: [Region]!

  """
  A list of edges which contains the `Region` and cursor to aid in pagination.
  """
  edges: [RegionsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Region` you could get from the connection."""
  totalCount: Int!
}

"""A `Region` edge in the connection."""
type RegionsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Region` at the end of the edge."""
  node: Region
}

"""Methods to use when ordering `Region`."""
enum RegionsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  REGION_ASC
  REGION_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Region` object types. All fields are tested for equality and combined with a logical and.
"""
input RegionCondition {
  """Checks for equality with the objects `id` field."""
  id: Int

  """Checks for equality with the objects `region` field."""
  region: String
}

"""
A filter to be used against `Region` object types. All fields are combined with a logical and.
"""
input RegionFilter {
  """Filter by the objects `id` field."""
  id: IntFilter

  """Filter by the objects `region` field."""
  region: StringFilter

  """Checks for all expressions in this list."""
  and: [RegionFilter!]

  """Checks for any expressions in this list."""
  or: [RegionFilter!]

  """Negates the expression."""
  not: RegionFilter
}

"""A connection to a list of `Specialization` values."""
type SpecializationsConnection {
  """A list of `Specialization` objects."""
  nodes: [Specialization]!

  """
  A list of edges which contains the `Specialization` and cursor to aid in pagination.
  """
  edges: [SpecializationsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Specialization` you could get from the connection."""
  totalCount: Int!
}

type Specialization implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: Int!
  name: String!
}

"""A `Specialization` edge in the connection."""
type SpecializationsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Specialization` at the end of the edge."""
  node: Specialization
}

"""Methods to use when ordering `Specialization`."""
enum SpecializationsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  NAME_ASC
  NAME_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Specialization` object types. All fields are
tested for equality and combined with a logical and.
"""
input SpecializationCondition {
  """Checks for equality with the objects `id` field."""
  id: Int

  """Checks for equality with the objects `name` field."""
  name: String
}

"""
A filter to be used against `Specialization` object types. All fields are combined with a logical and.
"""
input SpecializationFilter {
  """Filter by the objects `id` field."""
  id: IntFilter

  """Filter by the objects `name` field."""
  name: StringFilter

  """Checks for all expressions in this list."""
  and: [SpecializationFilter!]

  """Checks for any expressions in this list."""
  or: [SpecializationFilter!]

  """Negates the expression."""
  not: SpecializationFilter
}

"""
The root mutation type which contains root level fields which mutate data.
"""
type Mutation {
  """Creates a single `Admin`."""
  createAdmin(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: CreateAdminInput!
  ): CreateAdminPayload

  """Creates a single `AdminMedicamentDescription`."""
  createAdminMedicamentDescription(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: CreateAdminMedicamentDescriptionInput!
  ): CreateAdminMedicamentDescriptionPayload

  """Creates a single `Ambulance`."""
  createAmbulance(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: CreateAmbulanceInput!
  ): CreateAmbulancePayload

  """Creates a single `AmbulanceUser`."""
  createAmbulanceUser(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: CreateAmbulanceUserInput!
  ): CreateAmbulanceUserPayload

  """Creates a single `BloodCount`."""
  createBloodCount(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: CreateBloodCountInput!
  ): CreateBloodCountPayload

  """Creates a single `BloodCountUser`."""
  createBloodCountUser(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: CreateBloodCountUserInput!
  ): CreateBloodCountUserPayload

  """Creates a single `BloodCountUserValue`."""
  createBloodCountUserValue(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: CreateBloodCountUserValueInput!
  ): CreateBloodCountUserValuePayload

  """Creates a single `BloodType`."""
  createBloodType(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: CreateBloodTypeInput!
  ): CreateBloodTypePayload

  """Creates a single `City`."""
  createCity(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: CreateCityInput!
  ): CreateCityPayload

  """Creates a single `Diagnosis`."""
  createDiagnosis(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: CreateDiagnosisInput!
  ): CreateDiagnosisPayload

  """Creates a single `DiagnosisCategory`."""
  createDiagnosisCategory(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: CreateDiagnosisCategoryInput!
  ): CreateDiagnosisCategoryPayload

  """Creates a single `DiagnosisGroup`."""
  createDiagnosisGroup(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: CreateDiagnosisGroupInput!
  ): CreateDiagnosisGroupPayload

  """Creates a single `InsuranceCompany`."""
  createInsuranceCompany(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: CreateInsuranceCompanyInput!
  ): CreateInsuranceCompanyPayload

  """Creates a single `Medicament`."""
  createMedicament(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: CreateMedicamentInput!
  ): CreateMedicamentPayload

  """Creates a single `Meeting`."""
  createMeeting(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: CreateMeetingInput!
  ): CreateMeetingPayload

  """Creates a single `MeetingHour`."""
  createMeetingHour(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: CreateMeetingHourInput!
  ): CreateMeetingHourPayload

  """Creates a single `Ref`."""
  createRef(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: CreateRefInput!
  ): CreateRefPayload

  """Creates a single `RefRange`."""
  createRefRange(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: CreateRefRangeInput!
  ): CreateRefRangePayload

  """Creates a single `Region`."""
  createRegion(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: CreateRegionInput!
  ): CreateRegionPayload

  """Creates a single `Specialization`."""
  createSpecialization(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: CreateSpecializationInput!
  ): CreateSpecializationPayload

  """Creates a single `User`."""
  createUser(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: CreateUserInput!
  ): CreateUserPayload

  """Creates a single `UserDiagnosis`."""
  createUserDiagnosis(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: CreateUserDiagnosisInput!
  ): CreateUserDiagnosisPayload

  """Creates a single `UserMedicament`."""
  createUserMedicament(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: CreateUserMedicamentInput!
  ): CreateUserMedicamentPayload

  """Creates a single `UserMedicamentDay`."""
  createUserMedicamentDay(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: CreateUserMedicamentDayInput!
  ): CreateUserMedicamentDayPayload

  """Creates a single `UserMedicamentTime`."""
  createUserMedicamentTime(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: CreateUserMedicamentTimeInput!
  ): CreateUserMedicamentTimePayload

  """Updates a single `Admin` using its globally unique id and a patch."""
  updateAdminByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateAdminByNodeIdInput!
  ): UpdateAdminPayload

  """Updates a single `Admin` using a unique key and a patch."""
  updateAdmin(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateAdminInput!
  ): UpdateAdminPayload

  """
  Updates a single `AdminMedicamentDescription` using its globally unique id and a patch.
  """
  updateAdminMedicamentDescriptionByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateAdminMedicamentDescriptionByNodeIdInput!
  ): UpdateAdminMedicamentDescriptionPayload

  """
  Updates a single `AdminMedicamentDescription` using a unique key and a patch.
  """
  updateAdminMedicamentDescription(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateAdminMedicamentDescriptionInput!
  ): UpdateAdminMedicamentDescriptionPayload

  """Updates a single `Ambulance` using its globally unique id and a patch."""
  updateAmbulanceByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateAmbulanceByNodeIdInput!
  ): UpdateAmbulancePayload

  """Updates a single `Ambulance` using a unique key and a patch."""
  updateAmbulance(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateAmbulanceInput!
  ): UpdateAmbulancePayload

  """
  Updates a single `AmbulanceUser` using its globally unique id and a patch.
  """
  updateAmbulanceUserByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateAmbulanceUserByNodeIdInput!
  ): UpdateAmbulanceUserPayload

  """Updates a single `AmbulanceUser` using a unique key and a patch."""
  updateAmbulanceUser(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateAmbulanceUserInput!
  ): UpdateAmbulanceUserPayload

  """Updates a single `AmbulanceUser` using a unique key and a patch."""
  updateAmbulanceUserByUserIdAndAmbulanceId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateAmbulanceUserByUserIdAndAmbulanceIdInput!
  ): UpdateAmbulanceUserPayload

  """
  Updates a single `BloodCount` using its globally unique id and a patch.
  """
  updateBloodCountByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateBloodCountByNodeIdInput!
  ): UpdateBloodCountPayload

  """Updates a single `BloodCount` using a unique key and a patch."""
  updateBloodCount(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateBloodCountInput!
  ): UpdateBloodCountPayload

  """
  Updates a single `BloodCountUser` using its globally unique id and a patch.
  """
  updateBloodCountUserByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateBloodCountUserByNodeIdInput!
  ): UpdateBloodCountUserPayload

  """Updates a single `BloodCountUser` using a unique key and a patch."""
  updateBloodCountUser(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateBloodCountUserInput!
  ): UpdateBloodCountUserPayload

  """Updates a single `BloodCountUser` using a unique key and a patch."""
  updateBloodCountUserByUserIdAndBloodCountId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateBloodCountUserByUserIdAndBloodCountIdInput!
  ): UpdateBloodCountUserPayload

  """
  Updates a single `BloodCountUserValue` using its globally unique id and a patch.
  """
  updateBloodCountUserValueByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateBloodCountUserValueByNodeIdInput!
  ): UpdateBloodCountUserValuePayload

  """Updates a single `BloodCountUserValue` using a unique key and a patch."""
  updateBloodCountUserValue(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateBloodCountUserValueInput!
  ): UpdateBloodCountUserValuePayload

  """Updates a single `BloodType` using its globally unique id and a patch."""
  updateBloodTypeByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateBloodTypeByNodeIdInput!
  ): UpdateBloodTypePayload

  """Updates a single `BloodType` using a unique key and a patch."""
  updateBloodType(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateBloodTypeInput!
  ): UpdateBloodTypePayload

  """Updates a single `City` using its globally unique id and a patch."""
  updateCityByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateCityByNodeIdInput!
  ): UpdateCityPayload

  """Updates a single `City` using a unique key and a patch."""
  updateCity(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateCityInput!
  ): UpdateCityPayload

  """Updates a single `Diagnosis` using its globally unique id and a patch."""
  updateDiagnosisByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateDiagnosisByNodeIdInput!
  ): UpdateDiagnosisPayload

  """Updates a single `Diagnosis` using a unique key and a patch."""
  updateDiagnosis(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateDiagnosisInput!
  ): UpdateDiagnosisPayload

  """
  Updates a single `DiagnosisCategory` using its globally unique id and a patch.
  """
  updateDiagnosisCategoryByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateDiagnosisCategoryByNodeIdInput!
  ): UpdateDiagnosisCategoryPayload

  """Updates a single `DiagnosisCategory` using a unique key and a patch."""
  updateDiagnosisCategory(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateDiagnosisCategoryInput!
  ): UpdateDiagnosisCategoryPayload

  """
  Updates a single `DiagnosisGroup` using its globally unique id and a patch.
  """
  updateDiagnosisGroupByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateDiagnosisGroupByNodeIdInput!
  ): UpdateDiagnosisGroupPayload

  """Updates a single `DiagnosisGroup` using a unique key and a patch."""
  updateDiagnosisGroup(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateDiagnosisGroupInput!
  ): UpdateDiagnosisGroupPayload

  """
  Updates a single `InsuranceCompany` using its globally unique id and a patch.
  """
  updateInsuranceCompanyByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateInsuranceCompanyByNodeIdInput!
  ): UpdateInsuranceCompanyPayload

  """Updates a single `InsuranceCompany` using a unique key and a patch."""
  updateInsuranceCompany(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateInsuranceCompanyInput!
  ): UpdateInsuranceCompanyPayload

  """
  Updates a single `Medicament` using its globally unique id and a patch.
  """
  updateMedicamentByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateMedicamentByNodeIdInput!
  ): UpdateMedicamentPayload

  """Updates a single `Medicament` using a unique key and a patch."""
  updateMedicament(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateMedicamentInput!
  ): UpdateMedicamentPayload

  """Updates a single `Meeting` using its globally unique id and a patch."""
  updateMeetingByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateMeetingByNodeIdInput!
  ): UpdateMeetingPayload

  """Updates a single `Meeting` using a unique key and a patch."""
  updateMeeting(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateMeetingInput!
  ): UpdateMeetingPayload

  """Updates a single `Meeting` using a unique key and a patch."""
  updateMeetingByMeetingDateAndUserIdAndAdminId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateMeetingByMeetingDateAndUserIdAndAdminIdInput!
  ): UpdateMeetingPayload

  """Updates a single `Meeting` using a unique key and a patch."""
  updateMeetingByAdminIdAndMeetingTimeAndMeetingDate(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateMeetingByAdminIdAndMeetingTimeAndMeetingDateInput!
  ): UpdateMeetingPayload

  """
  Updates a single `MeetingHour` using its globally unique id and a patch.
  """
  updateMeetingHourByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateMeetingHourByNodeIdInput!
  ): UpdateMeetingHourPayload

  """Updates a single `MeetingHour` using a unique key and a patch."""
  updateMeetingHour(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateMeetingHourInput!
  ): UpdateMeetingHourPayload

  """Updates a single `Ref` using its globally unique id and a patch."""
  updateRefByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateRefByNodeIdInput!
  ): UpdateRefPayload

  """Updates a single `Ref` using a unique key and a patch."""
  updateRef(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateRefInput!
  ): UpdateRefPayload

  """Updates a single `RefRange` using its globally unique id and a patch."""
  updateRefRangeByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateRefRangeByNodeIdInput!
  ): UpdateRefRangePayload

  """Updates a single `RefRange` using a unique key and a patch."""
  updateRefRange(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateRefRangeInput!
  ): UpdateRefRangePayload

  """Updates a single `Region` using its globally unique id and a patch."""
  updateRegionByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateRegionByNodeIdInput!
  ): UpdateRegionPayload

  """Updates a single `Region` using a unique key and a patch."""
  updateRegion(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateRegionInput!
  ): UpdateRegionPayload

  """
  Updates a single `Specialization` using its globally unique id and a patch.
  """
  updateSpecializationByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateSpecializationByNodeIdInput!
  ): UpdateSpecializationPayload

  """Updates a single `Specialization` using a unique key and a patch."""
  updateSpecialization(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateSpecializationInput!
  ): UpdateSpecializationPayload

  """Updates a single `User` using its globally unique id and a patch."""
  updateUserByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateUserByNodeIdInput!
  ): UpdateUserPayload

  """Updates a single `User` using a unique key and a patch."""
  updateUser(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateUserInput!
  ): UpdateUserPayload

  """
  Updates a single `UserMedicament` using its globally unique id and a patch.
  """
  updateUserMedicamentByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateUserMedicamentByNodeIdInput!
  ): UpdateUserMedicamentPayload

  """Updates a single `UserMedicament` using a unique key and a patch."""
  updateUserMedicament(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateUserMedicamentInput!
  ): UpdateUserMedicamentPayload

  """
  Updates a single `UserMedicamentDay` using its globally unique id and a patch.
  """
  updateUserMedicamentDayByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateUserMedicamentDayByNodeIdInput!
  ): UpdateUserMedicamentDayPayload

  """Updates a single `UserMedicamentDay` using a unique key and a patch."""
  updateUserMedicamentDay(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateUserMedicamentDayInput!
  ): UpdateUserMedicamentDayPayload

  """
  Updates a single `UserMedicamentTime` using its globally unique id and a patch.
  """
  updateUserMedicamentTimeByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateUserMedicamentTimeByNodeIdInput!
  ): UpdateUserMedicamentTimePayload

  """Updates a single `UserMedicamentTime` using a unique key and a patch."""
  updateUserMedicamentTime(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateUserMedicamentTimeInput!
  ): UpdateUserMedicamentTimePayload

  """Updates a single `UserMedicamentTime` using a unique key and a patch."""
  updateUserMedicamentTimeByUserMedicamentIdAndTime(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateUserMedicamentTimeByUserMedicamentIdAndTimeInput!
  ): UpdateUserMedicamentTimePayload

  """Deletes a single `Admin` using its globally unique id."""
  deleteAdminByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteAdminByNodeIdInput!
  ): DeleteAdminPayload

  """Deletes a single `Admin` using a unique key."""
  deleteAdmin(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteAdminInput!
  ): DeleteAdminPayload

  """
  Deletes a single `AdminMedicamentDescription` using its globally unique id.
  """
  deleteAdminMedicamentDescriptionByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteAdminMedicamentDescriptionByNodeIdInput!
  ): DeleteAdminMedicamentDescriptionPayload

  """Deletes a single `AdminMedicamentDescription` using a unique key."""
  deleteAdminMedicamentDescription(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteAdminMedicamentDescriptionInput!
  ): DeleteAdminMedicamentDescriptionPayload

  """Deletes a single `Ambulance` using its globally unique id."""
  deleteAmbulanceByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteAmbulanceByNodeIdInput!
  ): DeleteAmbulancePayload

  """Deletes a single `Ambulance` using a unique key."""
  deleteAmbulance(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteAmbulanceInput!
  ): DeleteAmbulancePayload

  """Deletes a single `AmbulanceUser` using its globally unique id."""
  deleteAmbulanceUserByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteAmbulanceUserByNodeIdInput!
  ): DeleteAmbulanceUserPayload

  """Deletes a single `AmbulanceUser` using a unique key."""
  deleteAmbulanceUser(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteAmbulanceUserInput!
  ): DeleteAmbulanceUserPayload

  """Deletes a single `AmbulanceUser` using a unique key."""
  deleteAmbulanceUserByUserIdAndAmbulanceId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteAmbulanceUserByUserIdAndAmbulanceIdInput!
  ): DeleteAmbulanceUserPayload

  """Deletes a single `BloodCount` using its globally unique id."""
  deleteBloodCountByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteBloodCountByNodeIdInput!
  ): DeleteBloodCountPayload

  """Deletes a single `BloodCount` using a unique key."""
  deleteBloodCount(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteBloodCountInput!
  ): DeleteBloodCountPayload

  """Deletes a single `BloodCountUser` using its globally unique id."""
  deleteBloodCountUserByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteBloodCountUserByNodeIdInput!
  ): DeleteBloodCountUserPayload

  """Deletes a single `BloodCountUser` using a unique key."""
  deleteBloodCountUser(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteBloodCountUserInput!
  ): DeleteBloodCountUserPayload

  """Deletes a single `BloodCountUser` using a unique key."""
  deleteBloodCountUserByUserIdAndBloodCountId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteBloodCountUserByUserIdAndBloodCountIdInput!
  ): DeleteBloodCountUserPayload

  """Deletes a single `BloodCountUserValue` using its globally unique id."""
  deleteBloodCountUserValueByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteBloodCountUserValueByNodeIdInput!
  ): DeleteBloodCountUserValuePayload

  """Deletes a single `BloodCountUserValue` using a unique key."""
  deleteBloodCountUserValue(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteBloodCountUserValueInput!
  ): DeleteBloodCountUserValuePayload

  """Deletes a single `BloodType` using its globally unique id."""
  deleteBloodTypeByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteBloodTypeByNodeIdInput!
  ): DeleteBloodTypePayload

  """Deletes a single `BloodType` using a unique key."""
  deleteBloodType(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteBloodTypeInput!
  ): DeleteBloodTypePayload

  """Deletes a single `City` using its globally unique id."""
  deleteCityByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteCityByNodeIdInput!
  ): DeleteCityPayload

  """Deletes a single `City` using a unique key."""
  deleteCity(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteCityInput!
  ): DeleteCityPayload

  """Deletes a single `Diagnosis` using its globally unique id."""
  deleteDiagnosisByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteDiagnosisByNodeIdInput!
  ): DeleteDiagnosisPayload

  """Deletes a single `Diagnosis` using a unique key."""
  deleteDiagnosis(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteDiagnosisInput!
  ): DeleteDiagnosisPayload

  """Deletes a single `DiagnosisCategory` using its globally unique id."""
  deleteDiagnosisCategoryByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteDiagnosisCategoryByNodeIdInput!
  ): DeleteDiagnosisCategoryPayload

  """Deletes a single `DiagnosisCategory` using a unique key."""
  deleteDiagnosisCategory(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteDiagnosisCategoryInput!
  ): DeleteDiagnosisCategoryPayload

  """Deletes a single `DiagnosisGroup` using its globally unique id."""
  deleteDiagnosisGroupByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteDiagnosisGroupByNodeIdInput!
  ): DeleteDiagnosisGroupPayload

  """Deletes a single `DiagnosisGroup` using a unique key."""
  deleteDiagnosisGroup(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteDiagnosisGroupInput!
  ): DeleteDiagnosisGroupPayload

  """Deletes a single `InsuranceCompany` using its globally unique id."""
  deleteInsuranceCompanyByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteInsuranceCompanyByNodeIdInput!
  ): DeleteInsuranceCompanyPayload

  """Deletes a single `InsuranceCompany` using a unique key."""
  deleteInsuranceCompany(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteInsuranceCompanyInput!
  ): DeleteInsuranceCompanyPayload

  """Deletes a single `Medicament` using its globally unique id."""
  deleteMedicamentByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteMedicamentByNodeIdInput!
  ): DeleteMedicamentPayload

  """Deletes a single `Medicament` using a unique key."""
  deleteMedicament(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteMedicamentInput!
  ): DeleteMedicamentPayload

  """Deletes a single `Meeting` using its globally unique id."""
  deleteMeetingByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteMeetingByNodeIdInput!
  ): DeleteMeetingPayload

  """Deletes a single `Meeting` using a unique key."""
  deleteMeeting(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteMeetingInput!
  ): DeleteMeetingPayload

  """Deletes a single `Meeting` using a unique key."""
  deleteMeetingByMeetingDateAndUserIdAndAdminId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteMeetingByMeetingDateAndUserIdAndAdminIdInput!
  ): DeleteMeetingPayload

  """Deletes a single `Meeting` using a unique key."""
  deleteMeetingByAdminIdAndMeetingTimeAndMeetingDate(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteMeetingByAdminIdAndMeetingTimeAndMeetingDateInput!
  ): DeleteMeetingPayload

  """Deletes a single `MeetingHour` using its globally unique id."""
  deleteMeetingHourByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteMeetingHourByNodeIdInput!
  ): DeleteMeetingHourPayload

  """Deletes a single `MeetingHour` using a unique key."""
  deleteMeetingHour(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteMeetingHourInput!
  ): DeleteMeetingHourPayload

  """Deletes a single `Ref` using its globally unique id."""
  deleteRefByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteRefByNodeIdInput!
  ): DeleteRefPayload

  """Deletes a single `Ref` using a unique key."""
  deleteRef(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteRefInput!
  ): DeleteRefPayload

  """Deletes a single `RefRange` using its globally unique id."""
  deleteRefRangeByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteRefRangeByNodeIdInput!
  ): DeleteRefRangePayload

  """Deletes a single `RefRange` using a unique key."""
  deleteRefRange(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteRefRangeInput!
  ): DeleteRefRangePayload

  """Deletes a single `Region` using its globally unique id."""
  deleteRegionByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteRegionByNodeIdInput!
  ): DeleteRegionPayload

  """Deletes a single `Region` using a unique key."""
  deleteRegion(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteRegionInput!
  ): DeleteRegionPayload

  """Deletes a single `Specialization` using its globally unique id."""
  deleteSpecializationByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteSpecializationByNodeIdInput!
  ): DeleteSpecializationPayload

  """Deletes a single `Specialization` using a unique key."""
  deleteSpecialization(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteSpecializationInput!
  ): DeleteSpecializationPayload

  """Deletes a single `User` using its globally unique id."""
  deleteUserByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteUserByNodeIdInput!
  ): DeleteUserPayload

  """Deletes a single `User` using a unique key."""
  deleteUser(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteUserInput!
  ): DeleteUserPayload

  """Deletes a single `UserMedicament` using its globally unique id."""
  deleteUserMedicamentByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteUserMedicamentByNodeIdInput!
  ): DeleteUserMedicamentPayload

  """Deletes a single `UserMedicament` using a unique key."""
  deleteUserMedicament(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteUserMedicamentInput!
  ): DeleteUserMedicamentPayload

  """Deletes a single `UserMedicamentDay` using its globally unique id."""
  deleteUserMedicamentDayByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteUserMedicamentDayByNodeIdInput!
  ): DeleteUserMedicamentDayPayload

  """Deletes a single `UserMedicamentDay` using a unique key."""
  deleteUserMedicamentDay(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteUserMedicamentDayInput!
  ): DeleteUserMedicamentDayPayload

  """Deletes a single `UserMedicamentTime` using its globally unique id."""
  deleteUserMedicamentTimeByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteUserMedicamentTimeByNodeIdInput!
  ): DeleteUserMedicamentTimePayload

  """Deletes a single `UserMedicamentTime` using a unique key."""
  deleteUserMedicamentTime(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteUserMedicamentTimeInput!
  ): DeleteUserMedicamentTimePayload

  """Deletes a single `UserMedicamentTime` using a unique key."""
  deleteUserMedicamentTimeByUserMedicamentIdAndTime(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteUserMedicamentTimeByUserMedicamentIdAndTimeInput!
  ): DeleteUserMedicamentTimePayload
  authenticate(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: AuthenticateInput!
  ): AuthenticatePayload
  authenticateadmin(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: AuthenticateadminInput!
  ): AuthenticateadminPayload
  registeradmin(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: RegisteradminInput!
  ): RegisteradminPayload
  registeruser(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: RegisteruserInput!
  ): RegisteruserPayload
}

"""The output of our create `Admin` mutation."""
type CreateAdminPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Admin` that was created by this mutation."""
  admin: Admin

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Ambulance` that is related to this `Admin`."""
  ambulance: Ambulance

  """An edge for our `Admin`. May be used by Relay 1."""
  adminEdge(
    """The method to use when ordering `Admin`."""
    orderBy: [AdminsOrderBy!] = [PRIMARY_KEY_ASC]
  ): AdminsEdge
}

"""All input for the create `Admin` mutation."""
input CreateAdminInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Admin` to be created by this mutation."""
  admin: AdminInput!
}

"""An input for mutations affecting `Admin`"""
input AdminInput {
  id: Int
  firstName: String!
  lastName: String!
  ambulanceId: Int
  adminVerified: Boolean
  registrationDate: Date
  email: String
  phone: String
  lastLogin: Date
  interval: Int!
  ambulanceToAmbulanceId: AdminAmbulanceFkInput
  meetingsUsingId: MeetingAdminFkInverseInput
  userMedicamentsUsingId: UsermedicamentAdminFkInverseInput
  adminMedicamentDescriptionsUsingId: AdminmedicamentdescriptionAdminFkInverseInput
  meetingHoursUsingId: MeetinghoursAdminFkInverseInput
}

"""
Input for the nested mutation of `ambulance` in the `AdminInput` mutation.
"""
input AdminAmbulanceFkInput {
  """
  The primary key(s) for `ambulance` for the far side of the relationship.
  """
  connectById: AmbulanceAmbulancePkConnect

  """
  The primary key(s) for `ambulance` for the far side of the relationship.
  """
  connectByNodeId: AmbulanceNodeIdConnect

  """
  The primary key(s) for `ambulance` for the far side of the relationship.
  """
  deleteById: AmbulanceAmbulancePkDelete

  """
  The primary key(s) for `ambulance` for the far side of the relationship.
  """
  deleteByNodeId: AmbulanceNodeIdDelete

  """
  The primary key(s) and patch data for `ambulance` for the far side of the relationship.
  """
  updateById: AmbulanceOnAdminForAdminAmbulanceFkUsingAmbulancePkUpdate

  """
  The primary key(s) and patch data for `ambulance` for the far side of the relationship.
  """
  updateByNodeId: AdminOnAdminForAdminAmbulanceFkNodeIdUpdate

  """
  A `AmbulanceInput` object that will be created and connected to this object.
  """
  create: AdminAmbulanceFkAmbulanceCreateInput
}

"""The fields on `ambulance` to look up the row to connect."""
input AmbulanceAmbulancePkConnect {
  id: Int!
}

"""The globally unique `ID` look up for the row to connect."""
input AmbulanceNodeIdConnect {
  """
  The globally unique `ID` which identifies a single `ambulance` to be connected.
  """
  nodeId: ID!
}

"""The fields on `ambulance` to look up the row to delete."""
input AmbulanceAmbulancePkDelete {
  id: Int!
}

"""The globally unique `ID` look up for the row to delete."""
input AmbulanceNodeIdDelete {
  """
  The globally unique `ID` which identifies a single `ambulance` to be deleted.
  """
  nodeId: ID!
}

"""The fields on `ambulance` to look up the row to update."""
input AmbulanceOnAdminForAdminAmbulanceFkUsingAmbulancePkUpdate {
  """
  An object where the defined keys will be set on the `ambulance` being updated.
  """
  patch: updateAmbulanceOnAdminForAdminAmbulanceFkPatch!
  id: Int!
}

"""
An object where the defined keys will be set on the `ambulance` being updated.
"""
input updateAmbulanceOnAdminForAdminAmbulanceFkPatch {
  id: Int
  name: String
  ico: String
  cityId: Int
  street: String
  state: String
  suite: String
  email: String
  cityToCityId: AmbulanceCityFkInput
  adminsUsingId: AdminAmbulanceFkInverseInput
  meetingsUsingId: MeetingAmbulanceFkInverseInput
  ambulanceUsersUsingId: AmbulanceuserAmbulanceFkInverseInput
  meetingHoursUsingId: MeetinghoursAmbulanceFkInverseInput
}

"""
Input for the nested mutation of `city` in the `AmbulanceInput` mutation.
"""
input AmbulanceCityFkInput {
  """The primary key(s) for `city` for the far side of the relationship."""
  connectById: CityCityPkConnect

  """The primary key(s) for `city` for the far side of the relationship."""
  connectByNodeId: CityNodeIdConnect

  """The primary key(s) for `city` for the far side of the relationship."""
  deleteById: CityCityPkDelete

  """The primary key(s) for `city` for the far side of the relationship."""
  deleteByNodeId: CityNodeIdDelete

  """
  The primary key(s) and patch data for `city` for the far side of the relationship.
  """
  updateById: CityOnAmbulanceForAmbulanceCityFkUsingCityPkUpdate

  """
  The primary key(s) and patch data for `city` for the far side of the relationship.
  """
  updateByNodeId: AmbulanceOnAmbulanceForAmbulanceCityFkNodeIdUpdate

  """
  A `CityInput` object that will be created and connected to this object.
  """
  create: AmbulanceCityFkCityCreateInput
}

"""The fields on `city` to look up the row to connect."""
input CityCityPkConnect {
  id: Int!
}

"""The globally unique `ID` look up for the row to connect."""
input CityNodeIdConnect {
  """
  The globally unique `ID` which identifies a single `city` to be connected.
  """
  nodeId: ID!
}

"""The fields on `city` to look up the row to delete."""
input CityCityPkDelete {
  id: Int!
}

"""The globally unique `ID` look up for the row to delete."""
input CityNodeIdDelete {
  """
  The globally unique `ID` which identifies a single `city` to be deleted.
  """
  nodeId: ID!
}

"""The fields on `city` to look up the row to update."""
input CityOnAmbulanceForAmbulanceCityFkUsingCityPkUpdate {
  """
  An object where the defined keys will be set on the `city` being updated.
  """
  patch: updateCityOnAmbulanceForAmbulanceCityFkPatch!
  id: Int!
}

"""
An object where the defined keys will be set on the `city` being updated.
"""
input updateCityOnAmbulanceForAmbulanceCityFkPatch {
  id: Int
  name: String
  country: String
  iso: String
  regionId: Int
  type: String
  regionToRegionId: CityRegionFkInput
  ambulancesUsingId: AmbulanceCityFkInverseInput
}

"""Input for the nested mutation of `region` in the `CityInput` mutation."""
input CityRegionFkInput {
  """The primary key(s) for `region` for the far side of the relationship."""
  connectById: RegionRegionPkConnect

  """The primary key(s) for `region` for the far side of the relationship."""
  connectByNodeId: RegionNodeIdConnect

  """The primary key(s) for `region` for the far side of the relationship."""
  deleteById: RegionRegionPkDelete

  """The primary key(s) for `region` for the far side of the relationship."""
  deleteByNodeId: RegionNodeIdDelete

  """
  The primary key(s) and patch data for `region` for the far side of the relationship.
  """
  updateById: RegionOnCityForCityRegionFkUsingRegionPkUpdate

  """
  The primary key(s) and patch data for `region` for the far side of the relationship.
  """
  updateByNodeId: CityOnCityForCityRegionFkNodeIdUpdate

  """
  A `RegionInput` object that will be created and connected to this object.
  """
  create: CityRegionFkRegionCreateInput
}

"""The fields on `region` to look up the row to connect."""
input RegionRegionPkConnect {
  id: Int!
}

"""The globally unique `ID` look up for the row to connect."""
input RegionNodeIdConnect {
  """
  The globally unique `ID` which identifies a single `region` to be connected.
  """
  nodeId: ID!
}

"""The fields on `region` to look up the row to delete."""
input RegionRegionPkDelete {
  id: Int!
}

"""The globally unique `ID` look up for the row to delete."""
input RegionNodeIdDelete {
  """
  The globally unique `ID` which identifies a single `region` to be deleted.
  """
  nodeId: ID!
}

"""The fields on `region` to look up the row to update."""
input RegionOnCityForCityRegionFkUsingRegionPkUpdate {
  """
  An object where the defined keys will be set on the `region` being updated.
  """
  patch: updateRegionOnCityForCityRegionFkPatch!
  id: Int!
}

"""
An object where the defined keys will be set on the `region` being updated.
"""
input updateRegionOnCityForCityRegionFkPatch {
  id: Int
  region: String
  citiesUsingId: CityRegionFkInverseInput
}

"""Input for the nested mutation of `city` in the `RegionInput` mutation."""
input CityRegionFkInverseInput {
  """
  Flag indicating whether all other `city` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """The primary key(s) for `city` for the far side of the relationship."""
  connectById: [CityCityPkConnect!]

  """The primary key(s) for `city` for the far side of the relationship."""
  connectByNodeId: [CityNodeIdConnect!]

  """The primary key(s) for `city` for the far side of the relationship."""
  deleteById: [CityCityPkDelete!]

  """The primary key(s) for `city` for the far side of the relationship."""
  deleteByNodeId: [CityNodeIdDelete!]

  """
  The primary key(s) and patch data for `city` for the far side of the relationship.
  """
  updateById: [CityOnCityForCityRegionFkUsingCityPkUpdate!]

  """
  The primary key(s) and patch data for `city` for the far side of the relationship.
  """
  updateByNodeId: [RegionOnCityForCityRegionFkNodeIdUpdate!]

  """
  A `CityInput` object that will be created and connected to this object.
  """
  create: [CityRegionFkCityCreateInput!]
}

"""The fields on `city` to look up the row to update."""
input CityOnCityForCityRegionFkUsingCityPkUpdate {
  """
  An object where the defined keys will be set on the `city` being updated.
  """
  patch: updateCityOnCityForCityRegionFkPatch!
  id: Int!
}

"""
An object where the defined keys will be set on the `city` being updated.
"""
input updateCityOnCityForCityRegionFkPatch {
  id: Int
  name: String
  country: String
  iso: String
  type: String
  regionToRegionId: CityRegionFkInput
  ambulancesUsingId: AmbulanceCityFkInverseInput
}

"""
Input for the nested mutation of `ambulance` in the `CityInput` mutation.
"""
input AmbulanceCityFkInverseInput {
  """
  Flag indicating whether all other `ambulance` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) for `ambulance` for the far side of the relationship.
  """
  connectById: [AmbulanceAmbulancePkConnect!]

  """
  The primary key(s) for `ambulance` for the far side of the relationship.
  """
  connectByNodeId: [AmbulanceNodeIdConnect!]

  """
  The primary key(s) for `ambulance` for the far side of the relationship.
  """
  deleteById: [AmbulanceAmbulancePkDelete!]

  """
  The primary key(s) for `ambulance` for the far side of the relationship.
  """
  deleteByNodeId: [AmbulanceNodeIdDelete!]

  """
  The primary key(s) and patch data for `ambulance` for the far side of the relationship.
  """
  updateById: [AmbulanceOnAmbulanceForAmbulanceCityFkUsingAmbulancePkUpdate!]

  """
  The primary key(s) and patch data for `ambulance` for the far side of the relationship.
  """
  updateByNodeId: [CityOnAmbulanceForAmbulanceCityFkNodeIdUpdate!]

  """
  A `AmbulanceInput` object that will be created and connected to this object.
  """
  create: [AmbulanceCityFkAmbulanceCreateInput!]
}

"""The fields on `ambulance` to look up the row to update."""
input AmbulanceOnAmbulanceForAmbulanceCityFkUsingAmbulancePkUpdate {
  """
  An object where the defined keys will be set on the `ambulance` being updated.
  """
  patch: updateAmbulanceOnAmbulanceForAmbulanceCityFkPatch!
  id: Int!
}

"""
An object where the defined keys will be set on the `ambulance` being updated.
"""
input updateAmbulanceOnAmbulanceForAmbulanceCityFkPatch {
  id: Int
  name: String
  ico: String
  street: String
  state: String
  suite: String
  email: String
  cityToCityId: AmbulanceCityFkInput
  adminsUsingId: AdminAmbulanceFkInverseInput
  meetingsUsingId: MeetingAmbulanceFkInverseInput
  ambulanceUsersUsingId: AmbulanceuserAmbulanceFkInverseInput
  meetingHoursUsingId: MeetinghoursAmbulanceFkInverseInput
}

"""
Input for the nested mutation of `admin` in the `AmbulanceInput` mutation.
"""
input AdminAmbulanceFkInverseInput {
  """
  Flag indicating whether all other `admin` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """The primary key(s) for `admin` for the far side of the relationship."""
  connectById: [AdminAdminPkConnect!]

  """The primary key(s) for `admin` for the far side of the relationship."""
  connectByNodeId: [AdminNodeIdConnect!]

  """The primary key(s) for `admin` for the far side of the relationship."""
  deleteById: [AdminAdminPkDelete!]

  """The primary key(s) for `admin` for the far side of the relationship."""
  deleteByNodeId: [AdminNodeIdDelete!]

  """
  The primary key(s) and patch data for `admin` for the far side of the relationship.
  """
  updateById: [AdminOnAdminForAdminAmbulanceFkUsingAdminPkUpdate!]

  """
  The primary key(s) and patch data for `admin` for the far side of the relationship.
  """
  updateByNodeId: [AmbulanceOnAdminForAdminAmbulanceFkNodeIdUpdate!]

  """
  A `AdminInput` object that will be created and connected to this object.
  """
  create: [AdminAmbulanceFkAdminCreateInput!]
}

"""The fields on `admin` to look up the row to connect."""
input AdminAdminPkConnect {
  id: Int!
}

"""The globally unique `ID` look up for the row to connect."""
input AdminNodeIdConnect {
  """
  The globally unique `ID` which identifies a single `admin` to be connected.
  """
  nodeId: ID!
}

"""The fields on `admin` to look up the row to delete."""
input AdminAdminPkDelete {
  id: Int!
}

"""The globally unique `ID` look up for the row to delete."""
input AdminNodeIdDelete {
  """
  The globally unique `ID` which identifies a single `admin` to be deleted.
  """
  nodeId: ID!
}

"""The fields on `admin` to look up the row to update."""
input AdminOnAdminForAdminAmbulanceFkUsingAdminPkUpdate {
  """
  An object where the defined keys will be set on the `admin` being updated.
  """
  patch: updateAdminOnAdminForAdminAmbulanceFkPatch!
  id: Int!
}

"""
An object where the defined keys will be set on the `admin` being updated.
"""
input updateAdminOnAdminForAdminAmbulanceFkPatch {
  id: Int
  firstName: String
  lastName: String
  adminVerified: Boolean
  registrationDate: Date
  email: String
  phone: String
  lastLogin: Date
  interval: Int
  ambulanceToAmbulanceId: AdminAmbulanceFkInput
  meetingsUsingId: MeetingAdminFkInverseInput
  userMedicamentsUsingId: UsermedicamentAdminFkInverseInput
  adminMedicamentDescriptionsUsingId: AdminmedicamentdescriptionAdminFkInverseInput
  meetingHoursUsingId: MeetinghoursAdminFkInverseInput
}

"""
Input for the nested mutation of `meeting` in the `AdminInput` mutation.
"""
input MeetingAdminFkInverseInput {
  """
  Flag indicating whether all other `meeting` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """The primary key(s) for `meeting` for the far side of the relationship."""
  connectById: [MeetingMeetingPkConnect!]

  """The primary key(s) for `meeting` for the far side of the relationship."""
  connectByMeetingDateAndUserIdAndAdminId: [MeetingMeetingMeetingDateUserIdAdminIdKeyConnect!]

  """The primary key(s) for `meeting` for the far side of the relationship."""
  connectByAdminIdAndMeetingTimeAndMeetingDate: [MeetingMeetingAdminIdMeetingTimeMeetingDateKeyConnect!]

  """The primary key(s) for `meeting` for the far side of the relationship."""
  connectByNodeId: [MeetingNodeIdConnect!]

  """The primary key(s) for `meeting` for the far side of the relationship."""
  deleteById: [MeetingMeetingPkDelete!]

  """The primary key(s) for `meeting` for the far side of the relationship."""
  deleteByMeetingDateAndUserIdAndAdminId: [MeetingMeetingMeetingDateUserIdAdminIdKeyDelete!]

  """The primary key(s) for `meeting` for the far side of the relationship."""
  deleteByAdminIdAndMeetingTimeAndMeetingDate: [MeetingMeetingAdminIdMeetingTimeMeetingDateKeyDelete!]

  """The primary key(s) for `meeting` for the far side of the relationship."""
  deleteByNodeId: [MeetingNodeIdDelete!]

  """
  The primary key(s) and patch data for `meeting` for the far side of the relationship.
  """
  updateById: [MeetingOnMeetingForMeetingAdminFkUsingMeetingPkUpdate!]

  """
  The primary key(s) and patch data for `meeting` for the far side of the relationship.
  """
  updateByMeetingDateAndUserIdAndAdminId: [MeetingOnMeetingForMeetingAdminFkUsingMeetingMeetingDateUserIdAdminIdKeyUpdate!]

  """
  The primary key(s) and patch data for `meeting` for the far side of the relationship.
  """
  updateByAdminIdAndMeetingTimeAndMeetingDate: [MeetingOnMeetingForMeetingAdminFkUsingMeetingAdminIdMeetingTimeMeetingDateKeyUpdate!]

  """
  The primary key(s) and patch data for `meeting` for the far side of the relationship.
  """
  updateByNodeId: [AdminOnMeetingForMeetingAdminFkNodeIdUpdate!]

  """
  A `MeetingInput` object that will be created and connected to this object.
  """
  create: [MeetingAdminFkMeetingCreateInput!]
}

"""The fields on `meeting` to look up the row to connect."""
input MeetingMeetingPkConnect {
  id: Int!
}

"""The fields on `meeting` to look up the row to connect."""
input MeetingMeetingMeetingDateUserIdAdminIdKeyConnect {
  meetingDate: Date!
  userId: Int!
  adminId: Int!
}

"""The fields on `meeting` to look up the row to connect."""
input MeetingMeetingAdminIdMeetingTimeMeetingDateKeyConnect {
  adminId: Int!
  meetingTime: Time!
  meetingDate: Date!
}

"""The globally unique `ID` look up for the row to connect."""
input MeetingNodeIdConnect {
  """
  The globally unique `ID` which identifies a single `meeting` to be connected.
  """
  nodeId: ID!
}

"""The fields on `meeting` to look up the row to delete."""
input MeetingMeetingPkDelete {
  id: Int!
}

"""The fields on `meeting` to look up the row to delete."""
input MeetingMeetingMeetingDateUserIdAdminIdKeyDelete {
  meetingDate: Date!
  userId: Int!
  adminId: Int!
}

"""The fields on `meeting` to look up the row to delete."""
input MeetingMeetingAdminIdMeetingTimeMeetingDateKeyDelete {
  adminId: Int!
  meetingTime: Time!
  meetingDate: Date!
}

"""The globally unique `ID` look up for the row to delete."""
input MeetingNodeIdDelete {
  """
  The globally unique `ID` which identifies a single `meeting` to be deleted.
  """
  nodeId: ID!
}

"""The fields on `meeting` to look up the row to update."""
input MeetingOnMeetingForMeetingAdminFkUsingMeetingPkUpdate {
  """
  An object where the defined keys will be set on the `meeting` being updated.
  """
  patch: updateMeetingOnMeetingForMeetingAdminFkPatch!
  id: Int!
}

"""
An object where the defined keys will be set on the `meeting` being updated.
"""
input updateMeetingOnMeetingForMeetingAdminFkPatch {
  id: Int
  meetingDate: Date
  note: String
  userId: Int
  meetingTime: Time
  ambulanceId: Int
  createdAt: Date
  userToUserId: MeetingUserFkInput
  adminToAdminId: MeetingAdminFkInput
  ambulanceToAmbulanceId: MeetingAmbulanceFkInput
  bloodCountUserValuesUsingId: BloodcountuservalueMeetingFkInverseInput
}

"""
Input for the nested mutation of `user` in the `MeetingInput` mutation.
"""
input MeetingUserFkInput {
  """The primary key(s) for `user` for the far side of the relationship."""
  connectById: UserUserPkConnect

  """The primary key(s) for `user` for the far side of the relationship."""
  connectByNodeId: UserNodeIdConnect

  """The primary key(s) for `user` for the far side of the relationship."""
  deleteById: UserUserPkDelete

  """The primary key(s) for `user` for the far side of the relationship."""
  deleteByNodeId: UserNodeIdDelete

  """
  The primary key(s) and patch data for `user` for the far side of the relationship.
  """
  updateById: UserOnMeetingForMeetingUserFkUsingUserPkUpdate

  """
  The primary key(s) and patch data for `user` for the far side of the relationship.
  """
  updateByNodeId: MeetingOnMeetingForMeetingUserFkNodeIdUpdate

  """
  A `UserInput` object that will be created and connected to this object.
  """
  create: MeetingUserFkUserCreateInput
}

"""The fields on `user` to look up the row to connect."""
input UserUserPkConnect {
  id: Int!
}

"""The globally unique `ID` look up for the row to connect."""
input UserNodeIdConnect {
  """
  The globally unique `ID` which identifies a single `user` to be connected.
  """
  nodeId: ID!
}

"""The fields on `user` to look up the row to delete."""
input UserUserPkDelete {
  id: Int!
}

"""The globally unique `ID` look up for the row to delete."""
input UserNodeIdDelete {
  """
  The globally unique `ID` which identifies a single `user` to be deleted.
  """
  nodeId: ID!
}

"""The fields on `user` to look up the row to update."""
input UserOnMeetingForMeetingUserFkUsingUserPkUpdate {
  """
  An object where the defined keys will be set on the `user` being updated.
  """
  patch: updateUserOnMeetingForMeetingUserFkPatch!
  id: Int!
}

"""
An object where the defined keys will be set on the `user` being updated.
"""
input updateUserOnMeetingForMeetingUserFkPatch {
  id: Int
  foreName: String
  surName: String
  identNumber: String
  insuranceNumber: String
  email: String
  phone: String
  birthdate: Date
  verified: Boolean
  insuranceCompanyId: Int
  lastLogin: Date
  bloodTypeId: Int
  rhD: Boolean
  registeredAt: Date
  insuranceCompanyToInsuranceCompanyId: UserInsurancecompanyFkInput
  bloodTypeToBloodTypeId: UserBloodtypeFkInput
  meetingsUsingId: MeetingUserFkInverseInput
  userDiagnosesUsingId: UserdiagnosisUserFkInverseInput
  userMedicamentDaysUsingId: UsermedicamentdayUserFkInverseInput
  userMedicamentsUsingId: UsermedicamentUserFkInverseInput
  bloodCountUsersUsingId: BloodcountuserUserFkInverseInput
  ambulanceUsersUsingId: AmbulanceuserUserFkInverseInput
}

"""
Input for the nested mutation of `insuranceCompany` in the `UserInput` mutation.
"""
input UserInsurancecompanyFkInput {
  """
  The primary key(s) for `insuranceCompany` for the far side of the relationship.
  """
  connectById: InsuranceCompanyInsurancecompanyPkConnect

  """
  The primary key(s) for `insuranceCompany` for the far side of the relationship.
  """
  connectByNodeId: InsuranceCompanyNodeIdConnect

  """
  The primary key(s) for `insuranceCompany` for the far side of the relationship.
  """
  deleteById: InsuranceCompanyInsurancecompanyPkDelete

  """
  The primary key(s) for `insuranceCompany` for the far side of the relationship.
  """
  deleteByNodeId: InsuranceCompanyNodeIdDelete

  """
  The primary key(s) and patch data for `insuranceCompany` for the far side of the relationship.
  """
  updateById: InsuranceCompanyOnUserForUserInsurancecompanyFkUsingInsurancecompanyPkUpdate

  """
  The primary key(s) and patch data for `insuranceCompany` for the far side of the relationship.
  """
  updateByNodeId: UserOnUserForUserInsurancecompanyFkNodeIdUpdate

  """
  A `InsuranceCompanyInput` object that will be created and connected to this object.
  """
  create: UserInsurancecompanyFkInsuranceCompanyCreateInput
}

"""The fields on `insuranceCompany` to look up the row to connect."""
input InsuranceCompanyInsurancecompanyPkConnect {
  id: Int!
}

"""The globally unique `ID` look up for the row to connect."""
input InsuranceCompanyNodeIdConnect {
  """
  The globally unique `ID` which identifies a single `insuranceCompany` to be connected.
  """
  nodeId: ID!
}

"""The fields on `insuranceCompany` to look up the row to delete."""
input InsuranceCompanyInsurancecompanyPkDelete {
  id: Int!
}

"""The globally unique `ID` look up for the row to delete."""
input InsuranceCompanyNodeIdDelete {
  """
  The globally unique `ID` which identifies a single `insuranceCompany` to be deleted.
  """
  nodeId: ID!
}

"""The fields on `insuranceCompany` to look up the row to update."""
input InsuranceCompanyOnUserForUserInsurancecompanyFkUsingInsurancecompanyPkUpdate {
  """
  An object where the defined keys will be set on the `insuranceCompany` being updated.
  """
  patch: updateInsuranceCompanyOnUserForUserInsurancecompanyFkPatch!
  id: Int!
}

"""
An object where the defined keys will be set on the `insuranceCompany` being updated.
"""
input updateInsuranceCompanyOnUserForUserInsurancecompanyFkPatch {
  id: Int
  name: String
  usersUsingId: UserInsurancecompanyFkInverseInput
}

"""
Input for the nested mutation of `user` in the `InsuranceCompanyInput` mutation.
"""
input UserInsurancecompanyFkInverseInput {
  """
  Flag indicating whether all other `user` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """The primary key(s) for `user` for the far side of the relationship."""
  connectById: [UserUserPkConnect!]

  """The primary key(s) for `user` for the far side of the relationship."""
  connectByNodeId: [UserNodeIdConnect!]

  """The primary key(s) for `user` for the far side of the relationship."""
  deleteById: [UserUserPkDelete!]

  """The primary key(s) for `user` for the far side of the relationship."""
  deleteByNodeId: [UserNodeIdDelete!]

  """
  The primary key(s) and patch data for `user` for the far side of the relationship.
  """
  updateById: [UserOnUserForUserInsurancecompanyFkUsingUserPkUpdate!]

  """
  The primary key(s) and patch data for `user` for the far side of the relationship.
  """
  updateByNodeId: [InsuranceCompanyOnUserForUserInsurancecompanyFkNodeIdUpdate!]

  """
  A `UserInput` object that will be created and connected to this object.
  """
  create: [UserInsurancecompanyFkUserCreateInput!]
}

"""The fields on `user` to look up the row to update."""
input UserOnUserForUserInsurancecompanyFkUsingUserPkUpdate {
  """
  An object where the defined keys will be set on the `user` being updated.
  """
  patch: updateUserOnUserForUserInsurancecompanyFkPatch!
  id: Int!
}

"""
An object where the defined keys will be set on the `user` being updated.
"""
input updateUserOnUserForUserInsurancecompanyFkPatch {
  id: Int
  foreName: String
  surName: String
  identNumber: String
  insuranceNumber: String
  email: String
  phone: String
  birthdate: Date
  verified: Boolean
  lastLogin: Date
  bloodTypeId: Int
  rhD: Boolean
  registeredAt: Date
  insuranceCompanyToInsuranceCompanyId: UserInsurancecompanyFkInput
  bloodTypeToBloodTypeId: UserBloodtypeFkInput
  meetingsUsingId: MeetingUserFkInverseInput
  userDiagnosesUsingId: UserdiagnosisUserFkInverseInput
  userMedicamentDaysUsingId: UsermedicamentdayUserFkInverseInput
  userMedicamentsUsingId: UsermedicamentUserFkInverseInput
  bloodCountUsersUsingId: BloodcountuserUserFkInverseInput
  ambulanceUsersUsingId: AmbulanceuserUserFkInverseInput
}

"""
Input for the nested mutation of `bloodType` in the `UserInput` mutation.
"""
input UserBloodtypeFkInput {
  """
  The primary key(s) for `bloodType` for the far side of the relationship.
  """
  connectById: BloodTypeBloodtypePkConnect

  """
  The primary key(s) for `bloodType` for the far side of the relationship.
  """
  connectByNodeId: BloodTypeNodeIdConnect

  """
  The primary key(s) for `bloodType` for the far side of the relationship.
  """
  deleteById: BloodTypeBloodtypePkDelete

  """
  The primary key(s) for `bloodType` for the far side of the relationship.
  """
  deleteByNodeId: BloodTypeNodeIdDelete

  """
  The primary key(s) and patch data for `bloodType` for the far side of the relationship.
  """
  updateById: BloodTypeOnUserForUserBloodtypeFkUsingBloodtypePkUpdate

  """
  The primary key(s) and patch data for `bloodType` for the far side of the relationship.
  """
  updateByNodeId: UserOnUserForUserBloodtypeFkNodeIdUpdate

  """
  A `BloodTypeInput` object that will be created and connected to this object.
  """
  create: UserBloodtypeFkBloodTypeCreateInput
}

"""The fields on `bloodType` to look up the row to connect."""
input BloodTypeBloodtypePkConnect {
  id: Int!
}

"""The globally unique `ID` look up for the row to connect."""
input BloodTypeNodeIdConnect {
  """
  The globally unique `ID` which identifies a single `bloodType` to be connected.
  """
  nodeId: ID!
}

"""The fields on `bloodType` to look up the row to delete."""
input BloodTypeBloodtypePkDelete {
  id: Int!
}

"""The globally unique `ID` look up for the row to delete."""
input BloodTypeNodeIdDelete {
  """
  The globally unique `ID` which identifies a single `bloodType` to be deleted.
  """
  nodeId: ID!
}

"""The fields on `bloodType` to look up the row to update."""
input BloodTypeOnUserForUserBloodtypeFkUsingBloodtypePkUpdate {
  """
  An object where the defined keys will be set on the `bloodType` being updated.
  """
  patch: updateBloodTypeOnUserForUserBloodtypeFkPatch!
  id: Int!
}

"""
An object where the defined keys will be set on the `bloodType` being updated.
"""
input updateBloodTypeOnUserForUserBloodtypeFkPatch {
  id: Int
  name: String
  usersUsingId: UserBloodtypeFkInverseInput
}

"""
Input for the nested mutation of `user` in the `BloodTypeInput` mutation.
"""
input UserBloodtypeFkInverseInput {
  """
  Flag indicating whether all other `user` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """The primary key(s) for `user` for the far side of the relationship."""
  connectById: [UserUserPkConnect!]

  """The primary key(s) for `user` for the far side of the relationship."""
  connectByNodeId: [UserNodeIdConnect!]

  """The primary key(s) for `user` for the far side of the relationship."""
  deleteById: [UserUserPkDelete!]

  """The primary key(s) for `user` for the far side of the relationship."""
  deleteByNodeId: [UserNodeIdDelete!]

  """
  The primary key(s) and patch data for `user` for the far side of the relationship.
  """
  updateById: [UserOnUserForUserBloodtypeFkUsingUserPkUpdate!]

  """
  The primary key(s) and patch data for `user` for the far side of the relationship.
  """
  updateByNodeId: [BloodTypeOnUserForUserBloodtypeFkNodeIdUpdate!]

  """
  A `UserInput` object that will be created and connected to this object.
  """
  create: [UserBloodtypeFkUserCreateInput!]
}

"""The fields on `user` to look up the row to update."""
input UserOnUserForUserBloodtypeFkUsingUserPkUpdate {
  """
  An object where the defined keys will be set on the `user` being updated.
  """
  patch: updateUserOnUserForUserBloodtypeFkPatch!
  id: Int!
}

"""
An object where the defined keys will be set on the `user` being updated.
"""
input updateUserOnUserForUserBloodtypeFkPatch {
  id: Int
  foreName: String
  surName: String
  identNumber: String
  insuranceNumber: String
  email: String
  phone: String
  birthdate: Date
  verified: Boolean
  insuranceCompanyId: Int
  lastLogin: Date
  rhD: Boolean
  registeredAt: Date
  insuranceCompanyToInsuranceCompanyId: UserInsurancecompanyFkInput
  bloodTypeToBloodTypeId: UserBloodtypeFkInput
  meetingsUsingId: MeetingUserFkInverseInput
  userDiagnosesUsingId: UserdiagnosisUserFkInverseInput
  userMedicamentDaysUsingId: UsermedicamentdayUserFkInverseInput
  userMedicamentsUsingId: UsermedicamentUserFkInverseInput
  bloodCountUsersUsingId: BloodcountuserUserFkInverseInput
  ambulanceUsersUsingId: AmbulanceuserUserFkInverseInput
}

"""
Input for the nested mutation of `meeting` in the `UserInput` mutation.
"""
input MeetingUserFkInverseInput {
  """
  Flag indicating whether all other `meeting` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """The primary key(s) for `meeting` for the far side of the relationship."""
  connectById: [MeetingMeetingPkConnect!]

  """The primary key(s) for `meeting` for the far side of the relationship."""
  connectByMeetingDateAndUserIdAndAdminId: [MeetingMeetingMeetingDateUserIdAdminIdKeyConnect!]

  """The primary key(s) for `meeting` for the far side of the relationship."""
  connectByAdminIdAndMeetingTimeAndMeetingDate: [MeetingMeetingAdminIdMeetingTimeMeetingDateKeyConnect!]

  """The primary key(s) for `meeting` for the far side of the relationship."""
  connectByNodeId: [MeetingNodeIdConnect!]

  """The primary key(s) for `meeting` for the far side of the relationship."""
  deleteById: [MeetingMeetingPkDelete!]

  """The primary key(s) for `meeting` for the far side of the relationship."""
  deleteByMeetingDateAndUserIdAndAdminId: [MeetingMeetingMeetingDateUserIdAdminIdKeyDelete!]

  """The primary key(s) for `meeting` for the far side of the relationship."""
  deleteByAdminIdAndMeetingTimeAndMeetingDate: [MeetingMeetingAdminIdMeetingTimeMeetingDateKeyDelete!]

  """The primary key(s) for `meeting` for the far side of the relationship."""
  deleteByNodeId: [MeetingNodeIdDelete!]

  """
  The primary key(s) and patch data for `meeting` for the far side of the relationship.
  """
  updateById: [MeetingOnMeetingForMeetingUserFkUsingMeetingPkUpdate!]

  """
  The primary key(s) and patch data for `meeting` for the far side of the relationship.
  """
  updateByMeetingDateAndUserIdAndAdminId: [MeetingOnMeetingForMeetingUserFkUsingMeetingMeetingDateUserIdAdminIdKeyUpdate!]

  """
  The primary key(s) and patch data for `meeting` for the far side of the relationship.
  """
  updateByAdminIdAndMeetingTimeAndMeetingDate: [MeetingOnMeetingForMeetingUserFkUsingMeetingAdminIdMeetingTimeMeetingDateKeyUpdate!]

  """
  The primary key(s) and patch data for `meeting` for the far side of the relationship.
  """
  updateByNodeId: [UserOnMeetingForMeetingUserFkNodeIdUpdate!]

  """
  A `MeetingInput` object that will be created and connected to this object.
  """
  create: [MeetingUserFkMeetingCreateInput!]
}

"""The fields on `meeting` to look up the row to update."""
input MeetingOnMeetingForMeetingUserFkUsingMeetingPkUpdate {
  """
  An object where the defined keys will be set on the `meeting` being updated.
  """
  patch: updateMeetingOnMeetingForMeetingUserFkPatch!
  id: Int!
}

"""
An object where the defined keys will be set on the `meeting` being updated.
"""
input updateMeetingOnMeetingForMeetingUserFkPatch {
  id: Int
  meetingDate: Date
  note: String
  adminId: Int
  meetingTime: Time
  ambulanceId: Int
  createdAt: Date
  userToUserId: MeetingUserFkInput
  adminToAdminId: MeetingAdminFkInput
  ambulanceToAmbulanceId: MeetingAmbulanceFkInput
  bloodCountUserValuesUsingId: BloodcountuservalueMeetingFkInverseInput
}

"""
Input for the nested mutation of `admin` in the `MeetingInput` mutation.
"""
input MeetingAdminFkInput {
  """The primary key(s) for `admin` for the far side of the relationship."""
  connectById: AdminAdminPkConnect

  """The primary key(s) for `admin` for the far side of the relationship."""
  connectByNodeId: AdminNodeIdConnect

  """The primary key(s) for `admin` for the far side of the relationship."""
  deleteById: AdminAdminPkDelete

  """The primary key(s) for `admin` for the far side of the relationship."""
  deleteByNodeId: AdminNodeIdDelete

  """
  The primary key(s) and patch data for `admin` for the far side of the relationship.
  """
  updateById: AdminOnMeetingForMeetingAdminFkUsingAdminPkUpdate

  """
  The primary key(s) and patch data for `admin` for the far side of the relationship.
  """
  updateByNodeId: MeetingOnMeetingForMeetingAdminFkNodeIdUpdate

  """
  A `AdminInput` object that will be created and connected to this object.
  """
  create: MeetingAdminFkAdminCreateInput
}

"""The fields on `admin` to look up the row to update."""
input AdminOnMeetingForMeetingAdminFkUsingAdminPkUpdate {
  """
  An object where the defined keys will be set on the `admin` being updated.
  """
  patch: updateAdminOnMeetingForMeetingAdminFkPatch!
  id: Int!
}

"""
An object where the defined keys will be set on the `admin` being updated.
"""
input updateAdminOnMeetingForMeetingAdminFkPatch {
  id: Int
  firstName: String
  lastName: String
  ambulanceId: Int
  adminVerified: Boolean
  registrationDate: Date
  email: String
  phone: String
  lastLogin: Date
  interval: Int
  ambulanceToAmbulanceId: AdminAmbulanceFkInput
  meetingsUsingId: MeetingAdminFkInverseInput
  userMedicamentsUsingId: UsermedicamentAdminFkInverseInput
  adminMedicamentDescriptionsUsingId: AdminmedicamentdescriptionAdminFkInverseInput
  meetingHoursUsingId: MeetinghoursAdminFkInverseInput
}

"""
Input for the nested mutation of `userMedicament` in the `AdminInput` mutation.
"""
input UsermedicamentAdminFkInverseInput {
  """
  Flag indicating whether all other `userMedicament` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) for `userMedicament` for the far side of the relationship.
  """
  connectById: [UserMedicamentUsermedicamentPkConnect!]

  """
  The primary key(s) for `userMedicament` for the far side of the relationship.
  """
  connectByNodeId: [UserMedicamentNodeIdConnect!]

  """
  The primary key(s) for `userMedicament` for the far side of the relationship.
  """
  deleteById: [UserMedicamentUsermedicamentPkDelete!]

  """
  The primary key(s) for `userMedicament` for the far side of the relationship.
  """
  deleteByNodeId: [UserMedicamentNodeIdDelete!]

  """
  The primary key(s) and patch data for `userMedicament` for the far side of the relationship.
  """
  updateById: [UserMedicamentOnUserMedicamentForUsermedicamentAdminFkUsingUsermedicamentPkUpdate!]

  """
  The primary key(s) and patch data for `userMedicament` for the far side of the relationship.
  """
  updateByNodeId: [AdminOnUserMedicamentForUsermedicamentAdminFkNodeIdUpdate!]

  """
  A `UserMedicamentInput` object that will be created and connected to this object.
  """
  create: [UsermedicamentAdminFkUserMedicamentCreateInput!]
}

"""The fields on `userMedicament` to look up the row to connect."""
input UserMedicamentUsermedicamentPkConnect {
  id: Int!
}

"""The globally unique `ID` look up for the row to connect."""
input UserMedicamentNodeIdConnect {
  """
  The globally unique `ID` which identifies a single `userMedicament` to be connected.
  """
  nodeId: ID!
}

"""The fields on `userMedicament` to look up the row to delete."""
input UserMedicamentUsermedicamentPkDelete {
  id: Int!
}

"""The globally unique `ID` look up for the row to delete."""
input UserMedicamentNodeIdDelete {
  """
  The globally unique `ID` which identifies a single `userMedicament` to be deleted.
  """
  nodeId: ID!
}

"""The fields on `userMedicament` to look up the row to update."""
input UserMedicamentOnUserMedicamentForUsermedicamentAdminFkUsingUsermedicamentPkUpdate {
  """
  An object where the defined keys will be set on the `userMedicament` being updated.
  """
  patch: updateUserMedicamentOnUserMedicamentForUsermedicamentAdminFkPatch!
  id: Int!
}

"""
An object where the defined keys will be set on the `userMedicament` being updated.
"""
input updateUserMedicamentOnUserMedicamentForUsermedicamentAdminFkPatch {
  id: Int
  userId: Int
  medicamentId: Int
  active: Boolean
  dosing: Int
  createdAt: Date
  nextPrescriptionDate: Date
  updatedAt: Date
  interval: Int
  everyXday: Int
  morning: Boolean
  noon: Boolean
  evening: Boolean
  userMedicamentDayId: Int
  userToUserId: UsermedicamentUserFkInput
  medicamentToMedicamentId: UsermedicamentMedicamentFkInput
  adminToAdminId: UsermedicamentAdminFkInput
  userMedicamentDayToUserMedicamentDayId: UsermedicamentUsermedicamentdayFkInput
  userMedicamentTimesUsingId: UsermedicamenttimeUsermedicamentFkInverseInput
}

"""
Input for the nested mutation of `user` in the `UserMedicamentInput` mutation.
"""
input UsermedicamentUserFkInput {
  """The primary key(s) for `user` for the far side of the relationship."""
  connectById: UserUserPkConnect

  """The primary key(s) for `user` for the far side of the relationship."""
  connectByNodeId: UserNodeIdConnect

  """The primary key(s) for `user` for the far side of the relationship."""
  deleteById: UserUserPkDelete

  """The primary key(s) for `user` for the far side of the relationship."""
  deleteByNodeId: UserNodeIdDelete

  """
  The primary key(s) and patch data for `user` for the far side of the relationship.
  """
  updateById: UserOnUserMedicamentForUsermedicamentUserFkUsingUserPkUpdate

  """
  The primary key(s) and patch data for `user` for the far side of the relationship.
  """
  updateByNodeId: UserMedicamentOnUserMedicamentForUsermedicamentUserFkNodeIdUpdate

  """
  A `UserInput` object that will be created and connected to this object.
  """
  create: UsermedicamentUserFkUserCreateInput
}

"""The fields on `user` to look up the row to update."""
input UserOnUserMedicamentForUsermedicamentUserFkUsingUserPkUpdate {
  """
  An object where the defined keys will be set on the `user` being updated.
  """
  patch: updateUserOnUserMedicamentForUsermedicamentUserFkPatch!
  id: Int!
}

"""
An object where the defined keys will be set on the `user` being updated.
"""
input updateUserOnUserMedicamentForUsermedicamentUserFkPatch {
  id: Int
  foreName: String
  surName: String
  identNumber: String
  insuranceNumber: String
  email: String
  phone: String
  birthdate: Date
  verified: Boolean
  insuranceCompanyId: Int
  lastLogin: Date
  bloodTypeId: Int
  rhD: Boolean
  registeredAt: Date
  insuranceCompanyToInsuranceCompanyId: UserInsurancecompanyFkInput
  bloodTypeToBloodTypeId: UserBloodtypeFkInput
  meetingsUsingId: MeetingUserFkInverseInput
  userDiagnosesUsingId: UserdiagnosisUserFkInverseInput
  userMedicamentDaysUsingId: UsermedicamentdayUserFkInverseInput
  userMedicamentsUsingId: UsermedicamentUserFkInverseInput
  bloodCountUsersUsingId: BloodcountuserUserFkInverseInput
  ambulanceUsersUsingId: AmbulanceuserUserFkInverseInput
}

"""
Input for the nested mutation of `userDiagnosis` in the `UserInput` mutation.
"""
input UserdiagnosisUserFkInverseInput {
  """
  A `UserDiagnosisInput` object that will be created and connected to this object.
  """
  create: [UserdiagnosisUserFkUserDiagnosisCreateInput!]
}

"""The `userDiagnosis` to be created by this mutation."""
input UserdiagnosisUserFkUserDiagnosisCreateInput {
  diagnosisId: String
  userToUserId: UserdiagnosisUserFkInput
  diagnosisToDiagnosisId: UserdiagnosisDiagnosisFkInput
}

"""
Input for the nested mutation of `user` in the `UserDiagnosisInput` mutation.
"""
input UserdiagnosisUserFkInput {
  """The primary key(s) for `user` for the far side of the relationship."""
  connectById: UserUserPkConnect

  """The primary key(s) for `user` for the far side of the relationship."""
  connectByNodeId: UserNodeIdConnect

  """The primary key(s) for `user` for the far side of the relationship."""
  deleteById: UserUserPkDelete

  """The primary key(s) for `user` for the far side of the relationship."""
  deleteByNodeId: UserNodeIdDelete

  """
  The primary key(s) and patch data for `user` for the far side of the relationship.
  """
  updateById: UserOnUserDiagnosisForUserdiagnosisUserFkUsingUserPkUpdate

  """
  The primary key(s) and patch data for `user` for the far side of the relationship.
  """
  updateByNodeId: UserDiagnosisOnUserDiagnosisForUserdiagnosisUserFkNodeIdUpdate

  """
  A `UserInput` object that will be created and connected to this object.
  """
  create: UserdiagnosisUserFkUserCreateInput
}

"""The fields on `user` to look up the row to update."""
input UserOnUserDiagnosisForUserdiagnosisUserFkUsingUserPkUpdate {
  """
  An object where the defined keys will be set on the `user` being updated.
  """
  patch: updateUserOnUserDiagnosisForUserdiagnosisUserFkPatch!
  id: Int!
}

"""
An object where the defined keys will be set on the `user` being updated.
"""
input updateUserOnUserDiagnosisForUserdiagnosisUserFkPatch {
  id: Int
  foreName: String
  surName: String
  identNumber: String
  insuranceNumber: String
  email: String
  phone: String
  birthdate: Date
  verified: Boolean
  insuranceCompanyId: Int
  lastLogin: Date
  bloodTypeId: Int
  rhD: Boolean
  registeredAt: Date
  insuranceCompanyToInsuranceCompanyId: UserInsurancecompanyFkInput
  bloodTypeToBloodTypeId: UserBloodtypeFkInput
  meetingsUsingId: MeetingUserFkInverseInput
  userDiagnosesUsingId: UserdiagnosisUserFkInverseInput
  userMedicamentDaysUsingId: UsermedicamentdayUserFkInverseInput
  userMedicamentsUsingId: UsermedicamentUserFkInverseInput
  bloodCountUsersUsingId: BloodcountuserUserFkInverseInput
  ambulanceUsersUsingId: AmbulanceuserUserFkInverseInput
}

"""
Input for the nested mutation of `userMedicamentDay` in the `UserInput` mutation.
"""
input UsermedicamentdayUserFkInverseInput {
  """
  Flag indicating whether all other `userMedicamentDay` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) for `userMedicamentDay` for the far side of the relationship.
  """
  connectById: [UserMedicamentDayUsermedicamentdaysPkConnect!]

  """
  The primary key(s) for `userMedicamentDay` for the far side of the relationship.
  """
  connectByNodeId: [UserMedicamentDayNodeIdConnect!]

  """
  The primary key(s) for `userMedicamentDay` for the far side of the relationship.
  """
  deleteById: [UserMedicamentDayUsermedicamentdaysPkDelete!]

  """
  The primary key(s) for `userMedicamentDay` for the far side of the relationship.
  """
  deleteByNodeId: [UserMedicamentDayNodeIdDelete!]

  """
  The primary key(s) and patch data for `userMedicamentDay` for the far side of the relationship.
  """
  updateById: [UserMedicamentDayOnUserMedicamentDayForUsermedicamentdayUserFkUsingUsermedicamentdaysPkUpdate!]

  """
  The primary key(s) and patch data for `userMedicamentDay` for the far side of the relationship.
  """
  updateByNodeId: [UserOnUserMedicamentDayForUsermedicamentdayUserFkNodeIdUpdate!]

  """
  A `UserMedicamentDayInput` object that will be created and connected to this object.
  """
  create: [UsermedicamentdayUserFkUserMedicamentDayCreateInput!]
}

"""The fields on `userMedicamentDay` to look up the row to connect."""
input UserMedicamentDayUsermedicamentdaysPkConnect {
  id: Int!
}

"""The globally unique `ID` look up for the row to connect."""
input UserMedicamentDayNodeIdConnect {
  """
  The globally unique `ID` which identifies a single `userMedicamentDay` to be connected.
  """
  nodeId: ID!
}

"""The fields on `userMedicamentDay` to look up the row to delete."""
input UserMedicamentDayUsermedicamentdaysPkDelete {
  id: Int!
}

"""The globally unique `ID` look up for the row to delete."""
input UserMedicamentDayNodeIdDelete {
  """
  The globally unique `ID` which identifies a single `userMedicamentDay` to be deleted.
  """
  nodeId: ID!
}

"""The fields on `userMedicamentDay` to look up the row to update."""
input UserMedicamentDayOnUserMedicamentDayForUsermedicamentdayUserFkUsingUsermedicamentdaysPkUpdate {
  """
  An object where the defined keys will be set on the `userMedicamentDay` being updated.
  """
  patch: updateUserMedicamentDayOnUserMedicamentDayForUsermedicamentdayUserFkPatch!
  id: Int!
}

"""
An object where the defined keys will be set on the `userMedicamentDay` being updated.
"""
input updateUserMedicamentDayOnUserMedicamentDayForUsermedicamentdayUserFkPatch {
  monday: Boolean
  tuesday: Boolean
  wednesday: Boolean
  thursday: Boolean
  friday: Boolean
  saturday: Boolean
  sunday: Boolean
  id: Int
  userToUserId: UsermedicamentdayUserFkInput
  userMedicamentsUsingId: UsermedicamentUsermedicamentdayFkInverseInput
}

"""
Input for the nested mutation of `user` in the `UserMedicamentDayInput` mutation.
"""
input UsermedicamentdayUserFkInput {
  """The primary key(s) for `user` for the far side of the relationship."""
  connectById: UserUserPkConnect

  """The primary key(s) for `user` for the far side of the relationship."""
  connectByNodeId: UserNodeIdConnect

  """The primary key(s) for `user` for the far side of the relationship."""
  deleteById: UserUserPkDelete

  """The primary key(s) for `user` for the far side of the relationship."""
  deleteByNodeId: UserNodeIdDelete

  """
  The primary key(s) and patch data for `user` for the far side of the relationship.
  """
  updateById: UserOnUserMedicamentDayForUsermedicamentdayUserFkUsingUserPkUpdate

  """
  The primary key(s) and patch data for `user` for the far side of the relationship.
  """
  updateByNodeId: UserMedicamentDayOnUserMedicamentDayForUsermedicamentdayUserFkNodeIdUpdate

  """
  A `UserInput` object that will be created and connected to this object.
  """
  create: UsermedicamentdayUserFkUserCreateInput
}

"""The fields on `user` to look up the row to update."""
input UserOnUserMedicamentDayForUsermedicamentdayUserFkUsingUserPkUpdate {
  """
  An object where the defined keys will be set on the `user` being updated.
  """
  patch: updateUserOnUserMedicamentDayForUsermedicamentdayUserFkPatch!
  id: Int!
}

"""
An object where the defined keys will be set on the `user` being updated.
"""
input updateUserOnUserMedicamentDayForUsermedicamentdayUserFkPatch {
  id: Int
  foreName: String
  surName: String
  identNumber: String
  insuranceNumber: String
  email: String
  phone: String
  birthdate: Date
  verified: Boolean
  insuranceCompanyId: Int
  lastLogin: Date
  bloodTypeId: Int
  rhD: Boolean
  registeredAt: Date
  insuranceCompanyToInsuranceCompanyId: UserInsurancecompanyFkInput
  bloodTypeToBloodTypeId: UserBloodtypeFkInput
  meetingsUsingId: MeetingUserFkInverseInput
  userDiagnosesUsingId: UserdiagnosisUserFkInverseInput
  userMedicamentDaysUsingId: UsermedicamentdayUserFkInverseInput
  userMedicamentsUsingId: UsermedicamentUserFkInverseInput
  bloodCountUsersUsingId: BloodcountuserUserFkInverseInput
  ambulanceUsersUsingId: AmbulanceuserUserFkInverseInput
}

"""
Input for the nested mutation of `userMedicament` in the `UserInput` mutation.
"""
input UsermedicamentUserFkInverseInput {
  """
  Flag indicating whether all other `userMedicament` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) for `userMedicament` for the far side of the relationship.
  """
  connectById: [UserMedicamentUsermedicamentPkConnect!]

  """
  The primary key(s) for `userMedicament` for the far side of the relationship.
  """
  connectByNodeId: [UserMedicamentNodeIdConnect!]

  """
  The primary key(s) for `userMedicament` for the far side of the relationship.
  """
  deleteById: [UserMedicamentUsermedicamentPkDelete!]

  """
  The primary key(s) for `userMedicament` for the far side of the relationship.
  """
  deleteByNodeId: [UserMedicamentNodeIdDelete!]

  """
  The primary key(s) and patch data for `userMedicament` for the far side of the relationship.
  """
  updateById: [UserMedicamentOnUserMedicamentForUsermedicamentUserFkUsingUsermedicamentPkUpdate!]

  """
  The primary key(s) and patch data for `userMedicament` for the far side of the relationship.
  """
  updateByNodeId: [UserOnUserMedicamentForUsermedicamentUserFkNodeIdUpdate!]

  """
  A `UserMedicamentInput` object that will be created and connected to this object.
  """
  create: [UsermedicamentUserFkUserMedicamentCreateInput!]
}

"""The fields on `userMedicament` to look up the row to update."""
input UserMedicamentOnUserMedicamentForUsermedicamentUserFkUsingUsermedicamentPkUpdate {
  """
  An object where the defined keys will be set on the `userMedicament` being updated.
  """
  patch: updateUserMedicamentOnUserMedicamentForUsermedicamentUserFkPatch!
  id: Int!
}

"""
An object where the defined keys will be set on the `userMedicament` being updated.
"""
input updateUserMedicamentOnUserMedicamentForUsermedicamentUserFkPatch {
  id: Int
  medicamentId: Int
  active: Boolean
  dosing: Int
  createdAt: Date
  nextPrescriptionDate: Date
  adminId: Int
  updatedAt: Date
  interval: Int
  everyXday: Int
  morning: Boolean
  noon: Boolean
  evening: Boolean
  userMedicamentDayId: Int
  userToUserId: UsermedicamentUserFkInput
  medicamentToMedicamentId: UsermedicamentMedicamentFkInput
  adminToAdminId: UsermedicamentAdminFkInput
  userMedicamentDayToUserMedicamentDayId: UsermedicamentUsermedicamentdayFkInput
  userMedicamentTimesUsingId: UsermedicamenttimeUsermedicamentFkInverseInput
}

"""
Input for the nested mutation of `medicament` in the `UserMedicamentInput` mutation.
"""
input UsermedicamentMedicamentFkInput {
  """
  The primary key(s) for `medicament` for the far side of the relationship.
  """
  connectById: MedicamentMedicamentPkConnect

  """
  The primary key(s) for `medicament` for the far side of the relationship.
  """
  connectByNodeId: MedicamentNodeIdConnect

  """
  The primary key(s) for `medicament` for the far side of the relationship.
  """
  deleteById: MedicamentMedicamentPkDelete

  """
  The primary key(s) for `medicament` for the far side of the relationship.
  """
  deleteByNodeId: MedicamentNodeIdDelete

  """
  The primary key(s) and patch data for `medicament` for the far side of the relationship.
  """
  updateById: MedicamentOnUserMedicamentForUsermedicamentMedicamentFkUsingMedicamentPkUpdate

  """
  The primary key(s) and patch data for `medicament` for the far side of the relationship.
  """
  updateByNodeId: UserMedicamentOnUserMedicamentForUsermedicamentMedicamentFkNodeIdUpdate

  """
  A `MedicamentInput` object that will be created and connected to this object.
  """
  create: UsermedicamentMedicamentFkMedicamentCreateInput
}

"""The fields on `medicament` to look up the row to connect."""
input MedicamentMedicamentPkConnect {
  id: Int!
}

"""The globally unique `ID` look up for the row to connect."""
input MedicamentNodeIdConnect {
  """
  The globally unique `ID` which identifies a single `medicament` to be connected.
  """
  nodeId: ID!
}

"""The fields on `medicament` to look up the row to delete."""
input MedicamentMedicamentPkDelete {
  id: Int!
}

"""The globally unique `ID` look up for the row to delete."""
input MedicamentNodeIdDelete {
  """
  The globally unique `ID` which identifies a single `medicament` to be deleted.
  """
  nodeId: ID!
}

"""The fields on `medicament` to look up the row to update."""
input MedicamentOnUserMedicamentForUsermedicamentMedicamentFkUsingMedicamentPkUpdate {
  """
  An object where the defined keys will be set on the `medicament` being updated.
  """
  patch: updateMedicamentOnUserMedicamentForUsermedicamentMedicamentFkPatch!
  id: Int!
}

"""
An object where the defined keys will be set on the `medicament` being updated.
"""
input updateMedicamentOnUserMedicamentForUsermedicamentMedicamentFkPatch {
  id: Int
  code: String
  title: String
  supplement: String
  strength: String
  packaging: Int
  holderCode: String
  stateCode: String
  atcCode: String
  atcTitleSk: String
  indicationGroup: String
  regNumber: String
  expiration: String
  dispensing: String
  registrationType: String
  regDate: String
  validity: String
  securityFeature: Boolean
  userMedicamentsUsingId: UsermedicamentMedicamentFkInverseInput
  adminMedicamentDescriptionsUsingId: AdminmedicamentdescriptionMedicamentFkInverseInput
}

"""
Input for the nested mutation of `userMedicament` in the `MedicamentInput` mutation.
"""
input UsermedicamentMedicamentFkInverseInput {
  """
  Flag indicating whether all other `userMedicament` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) for `userMedicament` for the far side of the relationship.
  """
  connectById: [UserMedicamentUsermedicamentPkConnect!]

  """
  The primary key(s) for `userMedicament` for the far side of the relationship.
  """
  connectByNodeId: [UserMedicamentNodeIdConnect!]

  """
  The primary key(s) for `userMedicament` for the far side of the relationship.
  """
  deleteById: [UserMedicamentUsermedicamentPkDelete!]

  """
  The primary key(s) for `userMedicament` for the far side of the relationship.
  """
  deleteByNodeId: [UserMedicamentNodeIdDelete!]

  """
  The primary key(s) and patch data for `userMedicament` for the far side of the relationship.
  """
  updateById: [UserMedicamentOnUserMedicamentForUsermedicamentMedicamentFkUsingUsermedicamentPkUpdate!]

  """
  The primary key(s) and patch data for `userMedicament` for the far side of the relationship.
  """
  updateByNodeId: [MedicamentOnUserMedicamentForUsermedicamentMedicamentFkNodeIdUpdate!]

  """
  A `UserMedicamentInput` object that will be created and connected to this object.
  """
  create: [UsermedicamentMedicamentFkUserMedicamentCreateInput!]
}

"""The fields on `userMedicament` to look up the row to update."""
input UserMedicamentOnUserMedicamentForUsermedicamentMedicamentFkUsingUsermedicamentPkUpdate {
  """
  An object where the defined keys will be set on the `userMedicament` being updated.
  """
  patch: updateUserMedicamentOnUserMedicamentForUsermedicamentMedicamentFkPatch!
  id: Int!
}

"""
An object where the defined keys will be set on the `userMedicament` being updated.
"""
input updateUserMedicamentOnUserMedicamentForUsermedicamentMedicamentFkPatch {
  id: Int
  userId: Int
  active: Boolean
  dosing: Int
  createdAt: Date
  nextPrescriptionDate: Date
  adminId: Int
  updatedAt: Date
  interval: Int
  everyXday: Int
  morning: Boolean
  noon: Boolean
  evening: Boolean
  userMedicamentDayId: Int
  userToUserId: UsermedicamentUserFkInput
  medicamentToMedicamentId: UsermedicamentMedicamentFkInput
  adminToAdminId: UsermedicamentAdminFkInput
  userMedicamentDayToUserMedicamentDayId: UsermedicamentUsermedicamentdayFkInput
  userMedicamentTimesUsingId: UsermedicamenttimeUsermedicamentFkInverseInput
}

"""
Input for the nested mutation of `admin` in the `UserMedicamentInput` mutation.
"""
input UsermedicamentAdminFkInput {
  """The primary key(s) for `admin` for the far side of the relationship."""
  connectById: AdminAdminPkConnect

  """The primary key(s) for `admin` for the far side of the relationship."""
  connectByNodeId: AdminNodeIdConnect

  """The primary key(s) for `admin` for the far side of the relationship."""
  deleteById: AdminAdminPkDelete

  """The primary key(s) for `admin` for the far side of the relationship."""
  deleteByNodeId: AdminNodeIdDelete

  """
  The primary key(s) and patch data for `admin` for the far side of the relationship.
  """
  updateById: AdminOnUserMedicamentForUsermedicamentAdminFkUsingAdminPkUpdate

  """
  The primary key(s) and patch data for `admin` for the far side of the relationship.
  """
  updateByNodeId: UserMedicamentOnUserMedicamentForUsermedicamentAdminFkNodeIdUpdate

  """
  A `AdminInput` object that will be created and connected to this object.
  """
  create: UsermedicamentAdminFkAdminCreateInput
}

"""The fields on `admin` to look up the row to update."""
input AdminOnUserMedicamentForUsermedicamentAdminFkUsingAdminPkUpdate {
  """
  An object where the defined keys will be set on the `admin` being updated.
  """
  patch: updateAdminOnUserMedicamentForUsermedicamentAdminFkPatch!
  id: Int!
}

"""
An object where the defined keys will be set on the `admin` being updated.
"""
input updateAdminOnUserMedicamentForUsermedicamentAdminFkPatch {
  id: Int
  firstName: String
  lastName: String
  ambulanceId: Int
  adminVerified: Boolean
  registrationDate: Date
  email: String
  phone: String
  lastLogin: Date
  interval: Int
  ambulanceToAmbulanceId: AdminAmbulanceFkInput
  meetingsUsingId: MeetingAdminFkInverseInput
  userMedicamentsUsingId: UsermedicamentAdminFkInverseInput
  adminMedicamentDescriptionsUsingId: AdminmedicamentdescriptionAdminFkInverseInput
  meetingHoursUsingId: MeetinghoursAdminFkInverseInput
}

"""
Input for the nested mutation of `adminMedicamentDescription` in the `AdminInput` mutation.
"""
input AdminmedicamentdescriptionAdminFkInverseInput {
  """
  Flag indicating whether all other `adminMedicamentDescription` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) for `adminMedicamentDescription` for the far side of the relationship.
  """
  connectById: [AdminMedicamentDescriptionAdminmedicamentdescriptionPkConnect!]

  """
  The primary key(s) for `adminMedicamentDescription` for the far side of the relationship.
  """
  connectByNodeId: [AdminMedicamentDescriptionNodeIdConnect!]

  """
  The primary key(s) for `adminMedicamentDescription` for the far side of the relationship.
  """
  deleteById: [AdminMedicamentDescriptionAdminmedicamentdescriptionPkDelete!]

  """
  The primary key(s) for `adminMedicamentDescription` for the far side of the relationship.
  """
  deleteByNodeId: [AdminMedicamentDescriptionNodeIdDelete!]

  """
  The primary key(s) and patch data for `adminMedicamentDescription` for the far side of the relationship.
  """
  updateById: [AdminMedicamentDescriptionOnAdminMedicamentDescriptionForAdminmedicamentdescriptionAdminFkUsingAdminmedicamentdescriptionPkUpdate!]

  """
  The primary key(s) and patch data for `adminMedicamentDescription` for the far side of the relationship.
  """
  updateByNodeId: [AdminOnAdminMedicamentDescriptionForAdminmedicamentdescriptionAdminFkNodeIdUpdate!]

  """
  A `AdminMedicamentDescriptionInput` object that will be created and connected to this object.
  """
  create: [AdminmedicamentdescriptionAdminFkAdminMedicamentDescriptionCreateInput!]
}

"""
The fields on `adminMedicamentDescription` to look up the row to connect.
"""
input AdminMedicamentDescriptionAdminmedicamentdescriptionPkConnect {
  id: Int!
}

"""The globally unique `ID` look up for the row to connect."""
input AdminMedicamentDescriptionNodeIdConnect {
  """
  The globally unique `ID` which identifies a single `adminMedicamentDescription` to be connected.
  """
  nodeId: ID!
}

"""
The fields on `adminMedicamentDescription` to look up the row to delete.
"""
input AdminMedicamentDescriptionAdminmedicamentdescriptionPkDelete {
  id: Int!
}

"""The globally unique `ID` look up for the row to delete."""
input AdminMedicamentDescriptionNodeIdDelete {
  """
  The globally unique `ID` which identifies a single `adminMedicamentDescription` to be deleted.
  """
  nodeId: ID!
}

"""
The fields on `adminMedicamentDescription` to look up the row to update.
"""
input AdminMedicamentDescriptionOnAdminMedicamentDescriptionForAdminmedicamentdescriptionAdminFkUsingAdminmedicamentdescriptionPkUpdate {
  """
  An object where the defined keys will be set on the `adminMedicamentDescription` being updated.
  """
  patch: updateAdminMedicamentDescriptionOnAdminMedicamentDescriptionForAdminmedicamentdescriptionAdminFkPatch!
  id: Int!
}

"""
An object where the defined keys will be set on the `adminMedicamentDescription` being updated.
"""
input updateAdminMedicamentDescriptionOnAdminMedicamentDescriptionForAdminmedicamentdescriptionAdminFkPatch {
  id: Int
  medicamentId: Int
  description: String
  adminToAdminId: AdminmedicamentdescriptionAdminFkInput
  medicamentToMedicamentId: AdminmedicamentdescriptionMedicamentFkInput
}

"""
Input for the nested mutation of `admin` in the `AdminMedicamentDescriptionInput` mutation.
"""
input AdminmedicamentdescriptionAdminFkInput {
  """The primary key(s) for `admin` for the far side of the relationship."""
  connectById: AdminAdminPkConnect

  """The primary key(s) for `admin` for the far side of the relationship."""
  connectByNodeId: AdminNodeIdConnect

  """The primary key(s) for `admin` for the far side of the relationship."""
  deleteById: AdminAdminPkDelete

  """The primary key(s) for `admin` for the far side of the relationship."""
  deleteByNodeId: AdminNodeIdDelete

  """
  The primary key(s) and patch data for `admin` for the far side of the relationship.
  """
  updateById: AdminOnAdminMedicamentDescriptionForAdminmedicamentdescriptionAdminFkUsingAdminPkUpdate

  """
  The primary key(s) and patch data for `admin` for the far side of the relationship.
  """
  updateByNodeId: AdminMedicamentDescriptionOnAdminMedicamentDescriptionForAdminmedicamentdescriptionAdminFkNodeIdUpdate

  """
  A `AdminInput` object that will be created and connected to this object.
  """
  create: AdminmedicamentdescriptionAdminFkAdminCreateInput
}

"""The fields on `admin` to look up the row to update."""
input AdminOnAdminMedicamentDescriptionForAdminmedicamentdescriptionAdminFkUsingAdminPkUpdate {
  """
  An object where the defined keys will be set on the `admin` being updated.
  """
  patch: updateAdminOnAdminMedicamentDescriptionForAdminmedicamentdescriptionAdminFkPatch!
  id: Int!
}

"""
An object where the defined keys will be set on the `admin` being updated.
"""
input updateAdminOnAdminMedicamentDescriptionForAdminmedicamentdescriptionAdminFkPatch {
  id: Int
  firstName: String
  lastName: String
  ambulanceId: Int
  adminVerified: Boolean
  registrationDate: Date
  email: String
  phone: String
  lastLogin: Date
  interval: Int
  ambulanceToAmbulanceId: AdminAmbulanceFkInput
  meetingsUsingId: MeetingAdminFkInverseInput
  userMedicamentsUsingId: UsermedicamentAdminFkInverseInput
  adminMedicamentDescriptionsUsingId: AdminmedicamentdescriptionAdminFkInverseInput
  meetingHoursUsingId: MeetinghoursAdminFkInverseInput
}

"""
Input for the nested mutation of `meetingHour` in the `AdminInput` mutation.
"""
input MeetinghoursAdminFkInverseInput {
  """
  Flag indicating whether all other `meetingHour` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) for `meetingHour` for the far side of the relationship.
  """
  connectById: [MeetingHourMeetinghoursPkConnect!]

  """
  The primary key(s) for `meetingHour` for the far side of the relationship.
  """
  connectByNodeId: [MeetingHourNodeIdConnect!]

  """
  The primary key(s) for `meetingHour` for the far side of the relationship.
  """
  deleteById: [MeetingHourMeetinghoursPkDelete!]

  """
  The primary key(s) for `meetingHour` for the far side of the relationship.
  """
  deleteByNodeId: [MeetingHourNodeIdDelete!]

  """
  The primary key(s) and patch data for `meetingHour` for the far side of the relationship.
  """
  updateById: [MeetingHourOnMeetingHourForMeetinghoursAdminFkUsingMeetinghoursPkUpdate!]

  """
  The primary key(s) and patch data for `meetingHour` for the far side of the relationship.
  """
  updateByNodeId: [AdminOnMeetingHourForMeetinghoursAdminFkNodeIdUpdate!]

  """
  A `MeetingHourInput` object that will be created and connected to this object.
  """
  create: [MeetinghoursAdminFkMeetingHoursCreateInput!]
}

"""The fields on `meetingHour` to look up the row to connect."""
input MeetingHourMeetinghoursPkConnect {
  id: Int!
}

"""The globally unique `ID` look up for the row to connect."""
input MeetingHourNodeIdConnect {
  """
  The globally unique `ID` which identifies a single `meetingHour` to be connected.
  """
  nodeId: ID!
}

"""The fields on `meetingHour` to look up the row to delete."""
input MeetingHourMeetinghoursPkDelete {
  id: Int!
}

"""The globally unique `ID` look up for the row to delete."""
input MeetingHourNodeIdDelete {
  """
  The globally unique `ID` which identifies a single `meetingHour` to be deleted.
  """
  nodeId: ID!
}

"""The fields on `meetingHour` to look up the row to update."""
input MeetingHourOnMeetingHourForMeetinghoursAdminFkUsingMeetinghoursPkUpdate {
  """
  An object where the defined keys will be set on the `meetingHour` being updated.
  """
  patch: updateMeetingHourOnMeetingHourForMeetinghoursAdminFkPatch!
  id: Int!
}

"""
An object where the defined keys will be set on the `meetingHour` being updated.
"""
input updateMeetingHourOnMeetingHourForMeetinghoursAdminFkPatch {
  id: Int
  ambulanceId: Int
  startHours: JSON
  endHours: JSON
  interval: Int
  adminToAdminId: MeetinghoursAdminFkInput
  ambulanceToAmbulanceId: MeetinghoursAmbulanceFkInput
}

"""
Input for the nested mutation of `admin` in the `MeetingHourInput` mutation.
"""
input MeetinghoursAdminFkInput {
  """The primary key(s) for `admin` for the far side of the relationship."""
  connectById: AdminAdminPkConnect

  """The primary key(s) for `admin` for the far side of the relationship."""
  connectByNodeId: AdminNodeIdConnect

  """The primary key(s) for `admin` for the far side of the relationship."""
  deleteById: AdminAdminPkDelete

  """The primary key(s) for `admin` for the far side of the relationship."""
  deleteByNodeId: AdminNodeIdDelete

  """
  The primary key(s) and patch data for `admin` for the far side of the relationship.
  """
  updateById: AdminOnMeetingHourForMeetinghoursAdminFkUsingAdminPkUpdate

  """
  The primary key(s) and patch data for `admin` for the far side of the relationship.
  """
  updateByNodeId: MeetingHourOnMeetingHourForMeetinghoursAdminFkNodeIdUpdate

  """
  A `AdminInput` object that will be created and connected to this object.
  """
  create: MeetinghoursAdminFkAdminCreateInput
}

"""The fields on `admin` to look up the row to update."""
input AdminOnMeetingHourForMeetinghoursAdminFkUsingAdminPkUpdate {
  """
  An object where the defined keys will be set on the `admin` being updated.
  """
  patch: updateAdminOnMeetingHourForMeetinghoursAdminFkPatch!
  id: Int!
}

"""
An object where the defined keys will be set on the `admin` being updated.
"""
input updateAdminOnMeetingHourForMeetinghoursAdminFkPatch {
  id: Int
  firstName: String
  lastName: String
  ambulanceId: Int
  adminVerified: Boolean
  registrationDate: Date
  email: String
  phone: String
  lastLogin: Date
  interval: Int
  ambulanceToAmbulanceId: AdminAmbulanceFkInput
  meetingsUsingId: MeetingAdminFkInverseInput
  userMedicamentsUsingId: UsermedicamentAdminFkInverseInput
  adminMedicamentDescriptionsUsingId: AdminmedicamentdescriptionAdminFkInverseInput
  meetingHoursUsingId: MeetinghoursAdminFkInverseInput
}

"""The globally unique `ID` look up for the row to update."""
input MeetingHourOnMeetingHourForMeetinghoursAdminFkNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `admin` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `admin` being updated.
  """
  patch: AdminPatch!
}

"""
Represents an update to a `Admin`. Fields that are set will be updated.
"""
input AdminPatch {
  id: Int
  firstName: String
  lastName: String
  ambulanceId: Int
  adminVerified: Boolean
  registrationDate: Date
  email: String
  phone: String
  lastLogin: Date
  interval: Int
  ambulanceToAmbulanceId: AdminAmbulanceFkInput
  meetingsUsingId: MeetingAdminFkInverseInput
  userMedicamentsUsingId: UsermedicamentAdminFkInverseInput
  adminMedicamentDescriptionsUsingId: AdminmedicamentdescriptionAdminFkInverseInput
  meetingHoursUsingId: MeetinghoursAdminFkInverseInput
}

"""The `admin` to be created by this mutation."""
input MeetinghoursAdminFkAdminCreateInput {
  id: Int
  firstName: String!
  lastName: String!
  ambulanceId: Int
  adminVerified: Boolean
  registrationDate: Date
  email: String
  phone: String
  lastLogin: Date
  interval: Int!
  ambulanceToAmbulanceId: AdminAmbulanceFkInput
  meetingsUsingId: MeetingAdminFkInverseInput
  userMedicamentsUsingId: UsermedicamentAdminFkInverseInput
  adminMedicamentDescriptionsUsingId: AdminmedicamentdescriptionAdminFkInverseInput
  meetingHoursUsingId: MeetinghoursAdminFkInverseInput
}

"""
Input for the nested mutation of `ambulance` in the `MeetingHourInput` mutation.
"""
input MeetinghoursAmbulanceFkInput {
  """
  The primary key(s) for `ambulance` for the far side of the relationship.
  """
  connectById: AmbulanceAmbulancePkConnect

  """
  The primary key(s) for `ambulance` for the far side of the relationship.
  """
  connectByNodeId: AmbulanceNodeIdConnect

  """
  The primary key(s) for `ambulance` for the far side of the relationship.
  """
  deleteById: AmbulanceAmbulancePkDelete

  """
  The primary key(s) for `ambulance` for the far side of the relationship.
  """
  deleteByNodeId: AmbulanceNodeIdDelete

  """
  The primary key(s) and patch data for `ambulance` for the far side of the relationship.
  """
  updateById: AmbulanceOnMeetingHourForMeetinghoursAmbulanceFkUsingAmbulancePkUpdate

  """
  The primary key(s) and patch data for `ambulance` for the far side of the relationship.
  """
  updateByNodeId: MeetingHourOnMeetingHourForMeetinghoursAmbulanceFkNodeIdUpdate

  """
  A `AmbulanceInput` object that will be created and connected to this object.
  """
  create: MeetinghoursAmbulanceFkAmbulanceCreateInput
}

"""The fields on `ambulance` to look up the row to update."""
input AmbulanceOnMeetingHourForMeetinghoursAmbulanceFkUsingAmbulancePkUpdate {
  """
  An object where the defined keys will be set on the `ambulance` being updated.
  """
  patch: updateAmbulanceOnMeetingHourForMeetinghoursAmbulanceFkPatch!
  id: Int!
}

"""
An object where the defined keys will be set on the `ambulance` being updated.
"""
input updateAmbulanceOnMeetingHourForMeetinghoursAmbulanceFkPatch {
  id: Int
  name: String
  ico: String
  cityId: Int
  street: String
  state: String
  suite: String
  email: String
  cityToCityId: AmbulanceCityFkInput
  adminsUsingId: AdminAmbulanceFkInverseInput
  meetingsUsingId: MeetingAmbulanceFkInverseInput
  ambulanceUsersUsingId: AmbulanceuserAmbulanceFkInverseInput
  meetingHoursUsingId: MeetinghoursAmbulanceFkInverseInput
}

"""
Input for the nested mutation of `meeting` in the `AmbulanceInput` mutation.
"""
input MeetingAmbulanceFkInverseInput {
  """
  Flag indicating whether all other `meeting` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """The primary key(s) for `meeting` for the far side of the relationship."""
  connectById: [MeetingMeetingPkConnect!]

  """The primary key(s) for `meeting` for the far side of the relationship."""
  connectByMeetingDateAndUserIdAndAdminId: [MeetingMeetingMeetingDateUserIdAdminIdKeyConnect!]

  """The primary key(s) for `meeting` for the far side of the relationship."""
  connectByAdminIdAndMeetingTimeAndMeetingDate: [MeetingMeetingAdminIdMeetingTimeMeetingDateKeyConnect!]

  """The primary key(s) for `meeting` for the far side of the relationship."""
  connectByNodeId: [MeetingNodeIdConnect!]

  """The primary key(s) for `meeting` for the far side of the relationship."""
  deleteById: [MeetingMeetingPkDelete!]

  """The primary key(s) for `meeting` for the far side of the relationship."""
  deleteByMeetingDateAndUserIdAndAdminId: [MeetingMeetingMeetingDateUserIdAdminIdKeyDelete!]

  """The primary key(s) for `meeting` for the far side of the relationship."""
  deleteByAdminIdAndMeetingTimeAndMeetingDate: [MeetingMeetingAdminIdMeetingTimeMeetingDateKeyDelete!]

  """The primary key(s) for `meeting` for the far side of the relationship."""
  deleteByNodeId: [MeetingNodeIdDelete!]

  """
  The primary key(s) and patch data for `meeting` for the far side of the relationship.
  """
  updateById: [MeetingOnMeetingForMeetingAmbulanceFkUsingMeetingPkUpdate!]

  """
  The primary key(s) and patch data for `meeting` for the far side of the relationship.
  """
  updateByMeetingDateAndUserIdAndAdminId: [MeetingOnMeetingForMeetingAmbulanceFkUsingMeetingMeetingDateUserIdAdminIdKeyUpdate!]

  """
  The primary key(s) and patch data for `meeting` for the far side of the relationship.
  """
  updateByAdminIdAndMeetingTimeAndMeetingDate: [MeetingOnMeetingForMeetingAmbulanceFkUsingMeetingAdminIdMeetingTimeMeetingDateKeyUpdate!]

  """
  The primary key(s) and patch data for `meeting` for the far side of the relationship.
  """
  updateByNodeId: [AmbulanceOnMeetingForMeetingAmbulanceFkNodeIdUpdate!]

  """
  A `MeetingInput` object that will be created and connected to this object.
  """
  create: [MeetingAmbulanceFkMeetingCreateInput!]
}

"""The fields on `meeting` to look up the row to update."""
input MeetingOnMeetingForMeetingAmbulanceFkUsingMeetingPkUpdate {
  """
  An object where the defined keys will be set on the `meeting` being updated.
  """
  patch: updateMeetingOnMeetingForMeetingAmbulanceFkPatch!
  id: Int!
}

"""
An object where the defined keys will be set on the `meeting` being updated.
"""
input updateMeetingOnMeetingForMeetingAmbulanceFkPatch {
  id: Int
  meetingDate: Date
  note: String
  userId: Int
  adminId: Int
  meetingTime: Time
  createdAt: Date
  userToUserId: MeetingUserFkInput
  adminToAdminId: MeetingAdminFkInput
  ambulanceToAmbulanceId: MeetingAmbulanceFkInput
  bloodCountUserValuesUsingId: BloodcountuservalueMeetingFkInverseInput
}

"""
Input for the nested mutation of `ambulance` in the `MeetingInput` mutation.
"""
input MeetingAmbulanceFkInput {
  """
  The primary key(s) for `ambulance` for the far side of the relationship.
  """
  connectById: AmbulanceAmbulancePkConnect

  """
  The primary key(s) for `ambulance` for the far side of the relationship.
  """
  connectByNodeId: AmbulanceNodeIdConnect

  """
  The primary key(s) for `ambulance` for the far side of the relationship.
  """
  deleteById: AmbulanceAmbulancePkDelete

  """
  The primary key(s) for `ambulance` for the far side of the relationship.
  """
  deleteByNodeId: AmbulanceNodeIdDelete

  """
  The primary key(s) and patch data for `ambulance` for the far side of the relationship.
  """
  updateById: AmbulanceOnMeetingForMeetingAmbulanceFkUsingAmbulancePkUpdate

  """
  The primary key(s) and patch data for `ambulance` for the far side of the relationship.
  """
  updateByNodeId: MeetingOnMeetingForMeetingAmbulanceFkNodeIdUpdate

  """
  A `AmbulanceInput` object that will be created and connected to this object.
  """
  create: MeetingAmbulanceFkAmbulanceCreateInput
}

"""The fields on `ambulance` to look up the row to update."""
input AmbulanceOnMeetingForMeetingAmbulanceFkUsingAmbulancePkUpdate {
  """
  An object where the defined keys will be set on the `ambulance` being updated.
  """
  patch: updateAmbulanceOnMeetingForMeetingAmbulanceFkPatch!
  id: Int!
}

"""
An object where the defined keys will be set on the `ambulance` being updated.
"""
input updateAmbulanceOnMeetingForMeetingAmbulanceFkPatch {
  id: Int
  name: String
  ico: String
  cityId: Int
  street: String
  state: String
  suite: String
  email: String
  cityToCityId: AmbulanceCityFkInput
  adminsUsingId: AdminAmbulanceFkInverseInput
  meetingsUsingId: MeetingAmbulanceFkInverseInput
  ambulanceUsersUsingId: AmbulanceuserAmbulanceFkInverseInput
  meetingHoursUsingId: MeetinghoursAmbulanceFkInverseInput
}

"""
Input for the nested mutation of `ambulanceUser` in the `AmbulanceInput` mutation.
"""
input AmbulanceuserAmbulanceFkInverseInput {
  """
  Flag indicating whether all other `ambulanceUser` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) for `ambulanceUser` for the far side of the relationship.
  """
  connectById: [AmbulanceUserAmbulanceuserPkConnect!]

  """
  The primary key(s) for `ambulanceUser` for the far side of the relationship.
  """
  connectByUserIdAndAmbulanceId: [AmbulanceUserAmbulanceUserUserIdAmbulanceIdKeyConnect!]

  """
  The primary key(s) for `ambulanceUser` for the far side of the relationship.
  """
  connectByNodeId: [AmbulanceUserNodeIdConnect!]

  """
  The primary key(s) for `ambulanceUser` for the far side of the relationship.
  """
  deleteById: [AmbulanceUserAmbulanceuserPkDelete!]

  """
  The primary key(s) for `ambulanceUser` for the far side of the relationship.
  """
  deleteByUserIdAndAmbulanceId: [AmbulanceUserAmbulanceUserUserIdAmbulanceIdKeyDelete!]

  """
  The primary key(s) for `ambulanceUser` for the far side of the relationship.
  """
  deleteByNodeId: [AmbulanceUserNodeIdDelete!]

  """
  The primary key(s) and patch data for `ambulanceUser` for the far side of the relationship.
  """
  updateById: [AmbulanceUserOnAmbulanceUserForAmbulanceuserAmbulanceFkUsingAmbulanceuserPkUpdate!]

  """
  The primary key(s) and patch data for `ambulanceUser` for the far side of the relationship.
  """
  updateByUserIdAndAmbulanceId: [AmbulanceUserOnAmbulanceUserForAmbulanceuserAmbulanceFkUsingAmbulanceUserUserIdAmbulanceIdKeyUpdate!]

  """
  The primary key(s) and patch data for `ambulanceUser` for the far side of the relationship.
  """
  updateByNodeId: [AmbulanceOnAmbulanceUserForAmbulanceuserAmbulanceFkNodeIdUpdate!]

  """
  A `AmbulanceUserInput` object that will be created and connected to this object.
  """
  create: [AmbulanceuserAmbulanceFkAmbulanceUserCreateInput!]
}

"""The fields on `ambulanceUser` to look up the row to connect."""
input AmbulanceUserAmbulanceuserPkConnect {
  id: Int!
}

"""The fields on `ambulanceUser` to look up the row to connect."""
input AmbulanceUserAmbulanceUserUserIdAmbulanceIdKeyConnect {
  userId: Int!
  ambulanceId: Int!
}

"""The globally unique `ID` look up for the row to connect."""
input AmbulanceUserNodeIdConnect {
  """
  The globally unique `ID` which identifies a single `ambulanceUser` to be connected.
  """
  nodeId: ID!
}

"""The fields on `ambulanceUser` to look up the row to delete."""
input AmbulanceUserAmbulanceuserPkDelete {
  id: Int!
}

"""The fields on `ambulanceUser` to look up the row to delete."""
input AmbulanceUserAmbulanceUserUserIdAmbulanceIdKeyDelete {
  userId: Int!
  ambulanceId: Int!
}

"""The globally unique `ID` look up for the row to delete."""
input AmbulanceUserNodeIdDelete {
  """
  The globally unique `ID` which identifies a single `ambulanceUser` to be deleted.
  """
  nodeId: ID!
}

"""The fields on `ambulanceUser` to look up the row to update."""
input AmbulanceUserOnAmbulanceUserForAmbulanceuserAmbulanceFkUsingAmbulanceuserPkUpdate {
  """
  An object where the defined keys will be set on the `ambulanceUser` being updated.
  """
  patch: updateAmbulanceUserOnAmbulanceUserForAmbulanceuserAmbulanceFkPatch!
  id: Int!
}

"""
An object where the defined keys will be set on the `ambulanceUser` being updated.
"""
input updateAmbulanceUserOnAmbulanceUserForAmbulanceuserAmbulanceFkPatch {
  id: Int
  userId: Int
  ambulanceToAmbulanceId: AmbulanceuserAmbulanceFkInput
  userToUserId: AmbulanceuserUserFkInput
}

"""
Input for the nested mutation of `ambulance` in the `AmbulanceUserInput` mutation.
"""
input AmbulanceuserAmbulanceFkInput {
  """
  The primary key(s) for `ambulance` for the far side of the relationship.
  """
  connectById: AmbulanceAmbulancePkConnect

  """
  The primary key(s) for `ambulance` for the far side of the relationship.
  """
  connectByNodeId: AmbulanceNodeIdConnect

  """
  The primary key(s) for `ambulance` for the far side of the relationship.
  """
  deleteById: AmbulanceAmbulancePkDelete

  """
  The primary key(s) for `ambulance` for the far side of the relationship.
  """
  deleteByNodeId: AmbulanceNodeIdDelete

  """
  The primary key(s) and patch data for `ambulance` for the far side of the relationship.
  """
  updateById: AmbulanceOnAmbulanceUserForAmbulanceuserAmbulanceFkUsingAmbulancePkUpdate

  """
  The primary key(s) and patch data for `ambulance` for the far side of the relationship.
  """
  updateByNodeId: AmbulanceUserOnAmbulanceUserForAmbulanceuserAmbulanceFkNodeIdUpdate

  """
  A `AmbulanceInput` object that will be created and connected to this object.
  """
  create: AmbulanceuserAmbulanceFkAmbulanceCreateInput
}

"""The fields on `ambulance` to look up the row to update."""
input AmbulanceOnAmbulanceUserForAmbulanceuserAmbulanceFkUsingAmbulancePkUpdate {
  """
  An object where the defined keys will be set on the `ambulance` being updated.
  """
  patch: updateAmbulanceOnAmbulanceUserForAmbulanceuserAmbulanceFkPatch!
  id: Int!
}

"""
An object where the defined keys will be set on the `ambulance` being updated.
"""
input updateAmbulanceOnAmbulanceUserForAmbulanceuserAmbulanceFkPatch {
  id: Int
  name: String
  ico: String
  cityId: Int
  street: String
  state: String
  suite: String
  email: String
  cityToCityId: AmbulanceCityFkInput
  adminsUsingId: AdminAmbulanceFkInverseInput
  meetingsUsingId: MeetingAmbulanceFkInverseInput
  ambulanceUsersUsingId: AmbulanceuserAmbulanceFkInverseInput
  meetingHoursUsingId: MeetinghoursAmbulanceFkInverseInput
}

"""
Input for the nested mutation of `meetingHour` in the `AmbulanceInput` mutation.
"""
input MeetinghoursAmbulanceFkInverseInput {
  """
  Flag indicating whether all other `meetingHour` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) for `meetingHour` for the far side of the relationship.
  """
  connectById: [MeetingHourMeetinghoursPkConnect!]

  """
  The primary key(s) for `meetingHour` for the far side of the relationship.
  """
  connectByNodeId: [MeetingHourNodeIdConnect!]

  """
  The primary key(s) for `meetingHour` for the far side of the relationship.
  """
  deleteById: [MeetingHourMeetinghoursPkDelete!]

  """
  The primary key(s) for `meetingHour` for the far side of the relationship.
  """
  deleteByNodeId: [MeetingHourNodeIdDelete!]

  """
  The primary key(s) and patch data for `meetingHour` for the far side of the relationship.
  """
  updateById: [MeetingHourOnMeetingHourForMeetinghoursAmbulanceFkUsingMeetinghoursPkUpdate!]

  """
  The primary key(s) and patch data for `meetingHour` for the far side of the relationship.
  """
  updateByNodeId: [AmbulanceOnMeetingHourForMeetinghoursAmbulanceFkNodeIdUpdate!]

  """
  A `MeetingHourInput` object that will be created and connected to this object.
  """
  create: [MeetinghoursAmbulanceFkMeetingHoursCreateInput!]
}

"""The fields on `meetingHour` to look up the row to update."""
input MeetingHourOnMeetingHourForMeetinghoursAmbulanceFkUsingMeetinghoursPkUpdate {
  """
  An object where the defined keys will be set on the `meetingHour` being updated.
  """
  patch: updateMeetingHourOnMeetingHourForMeetinghoursAmbulanceFkPatch!
  id: Int!
}

"""
An object where the defined keys will be set on the `meetingHour` being updated.
"""
input updateMeetingHourOnMeetingHourForMeetinghoursAmbulanceFkPatch {
  id: Int
  adminId: Int
  startHours: JSON
  endHours: JSON
  interval: Int
  adminToAdminId: MeetinghoursAdminFkInput
  ambulanceToAmbulanceId: MeetinghoursAmbulanceFkInput
}

"""The globally unique `ID` look up for the row to update."""
input AmbulanceOnMeetingHourForMeetinghoursAmbulanceFkNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `meetingHour` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `meetingHour` being updated.
  """
  patch: MeetingHourPatch!
}

"""
Represents an update to a `MeetingHour`. Fields that are set will be updated.
"""
input MeetingHourPatch {
  id: Int
  adminId: Int
  ambulanceId: Int
  startHours: JSON
  endHours: JSON
  interval: Int
  adminToAdminId: MeetinghoursAdminFkInput
  ambulanceToAmbulanceId: MeetinghoursAmbulanceFkInput
}

"""The `meetingHour` to be created by this mutation."""
input MeetinghoursAmbulanceFkMeetingHoursCreateInput {
  id: Int
  adminId: Int
  startHours: JSON
  endHours: JSON
  interval: Int
  adminToAdminId: MeetinghoursAdminFkInput
  ambulanceToAmbulanceId: MeetinghoursAmbulanceFkInput
}

"""The globally unique `ID` look up for the row to update."""
input AmbulanceUserOnAmbulanceUserForAmbulanceuserAmbulanceFkNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `ambulance` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `ambulance` being updated.
  """
  patch: AmbulancePatch!
}

"""
Represents an update to a `Ambulance`. Fields that are set will be updated.
"""
input AmbulancePatch {
  id: Int
  name: String
  ico: String
  cityId: Int
  street: String
  state: String
  suite: String
  email: String
  cityToCityId: AmbulanceCityFkInput
  adminsUsingId: AdminAmbulanceFkInverseInput
  meetingsUsingId: MeetingAmbulanceFkInverseInput
  ambulanceUsersUsingId: AmbulanceuserAmbulanceFkInverseInput
  meetingHoursUsingId: MeetinghoursAmbulanceFkInverseInput
}

"""The `ambulance` to be created by this mutation."""
input AmbulanceuserAmbulanceFkAmbulanceCreateInput {
  id: Int
  name: String!
  ico: String
  cityId: Int
  street: String!
  state: String!
  suite: String!
  email: String!
  cityToCityId: AmbulanceCityFkInput
  adminsUsingId: AdminAmbulanceFkInverseInput
  meetingsUsingId: MeetingAmbulanceFkInverseInput
  ambulanceUsersUsingId: AmbulanceuserAmbulanceFkInverseInput
  meetingHoursUsingId: MeetinghoursAmbulanceFkInverseInput
}

"""
Input for the nested mutation of `user` in the `AmbulanceUserInput` mutation.
"""
input AmbulanceuserUserFkInput {
  """The primary key(s) for `user` for the far side of the relationship."""
  connectById: UserUserPkConnect

  """The primary key(s) for `user` for the far side of the relationship."""
  connectByNodeId: UserNodeIdConnect

  """The primary key(s) for `user` for the far side of the relationship."""
  deleteById: UserUserPkDelete

  """The primary key(s) for `user` for the far side of the relationship."""
  deleteByNodeId: UserNodeIdDelete

  """
  The primary key(s) and patch data for `user` for the far side of the relationship.
  """
  updateById: UserOnAmbulanceUserForAmbulanceuserUserFkUsingUserPkUpdate

  """
  The primary key(s) and patch data for `user` for the far side of the relationship.
  """
  updateByNodeId: AmbulanceUserOnAmbulanceUserForAmbulanceuserUserFkNodeIdUpdate

  """
  A `UserInput` object that will be created and connected to this object.
  """
  create: AmbulanceuserUserFkUserCreateInput
}

"""The fields on `user` to look up the row to update."""
input UserOnAmbulanceUserForAmbulanceuserUserFkUsingUserPkUpdate {
  """
  An object where the defined keys will be set on the `user` being updated.
  """
  patch: updateUserOnAmbulanceUserForAmbulanceuserUserFkPatch!
  id: Int!
}

"""
An object where the defined keys will be set on the `user` being updated.
"""
input updateUserOnAmbulanceUserForAmbulanceuserUserFkPatch {
  id: Int
  foreName: String
  surName: String
  identNumber: String
  insuranceNumber: String
  email: String
  phone: String
  birthdate: Date
  verified: Boolean
  insuranceCompanyId: Int
  lastLogin: Date
  bloodTypeId: Int
  rhD: Boolean
  registeredAt: Date
  insuranceCompanyToInsuranceCompanyId: UserInsurancecompanyFkInput
  bloodTypeToBloodTypeId: UserBloodtypeFkInput
  meetingsUsingId: MeetingUserFkInverseInput
  userDiagnosesUsingId: UserdiagnosisUserFkInverseInput
  userMedicamentDaysUsingId: UsermedicamentdayUserFkInverseInput
  userMedicamentsUsingId: UsermedicamentUserFkInverseInput
  bloodCountUsersUsingId: BloodcountuserUserFkInverseInput
  ambulanceUsersUsingId: AmbulanceuserUserFkInverseInput
}

"""
Input for the nested mutation of `bloodCountUser` in the `UserInput` mutation.
"""
input BloodcountuserUserFkInverseInput {
  """
  Flag indicating whether all other `bloodCountUser` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) for `bloodCountUser` for the far side of the relationship.
  """
  connectById: [BloodCountUserBloodcountuserPkConnect!]

  """
  The primary key(s) for `bloodCountUser` for the far side of the relationship.
  """
  connectByUserIdAndBloodCountId: [BloodCountUserBloodCountUserUserIdBloodCountIdKeyConnect!]

  """
  The primary key(s) for `bloodCountUser` for the far side of the relationship.
  """
  connectByNodeId: [BloodCountUserNodeIdConnect!]

  """
  The primary key(s) for `bloodCountUser` for the far side of the relationship.
  """
  deleteById: [BloodCountUserBloodcountuserPkDelete!]

  """
  The primary key(s) for `bloodCountUser` for the far side of the relationship.
  """
  deleteByUserIdAndBloodCountId: [BloodCountUserBloodCountUserUserIdBloodCountIdKeyDelete!]

  """
  The primary key(s) for `bloodCountUser` for the far side of the relationship.
  """
  deleteByNodeId: [BloodCountUserNodeIdDelete!]

  """
  The primary key(s) and patch data for `bloodCountUser` for the far side of the relationship.
  """
  updateById: [BloodCountUserOnBloodCountUserForBloodcountuserUserFkUsingBloodcountuserPkUpdate!]

  """
  The primary key(s) and patch data for `bloodCountUser` for the far side of the relationship.
  """
  updateByUserIdAndBloodCountId: [BloodCountUserOnBloodCountUserForBloodcountuserUserFkUsingBloodCountUserUserIdBloodCountIdKeyUpdate!]

  """
  The primary key(s) and patch data for `bloodCountUser` for the far side of the relationship.
  """
  updateByNodeId: [UserOnBloodCountUserForBloodcountuserUserFkNodeIdUpdate!]

  """
  A `BloodCountUserInput` object that will be created and connected to this object.
  """
  create: [BloodcountuserUserFkBloodCountUserCreateInput!]
}

"""The fields on `bloodCountUser` to look up the row to connect."""
input BloodCountUserBloodcountuserPkConnect {
  id: Int!
}

"""The fields on `bloodCountUser` to look up the row to connect."""
input BloodCountUserBloodCountUserUserIdBloodCountIdKeyConnect {
  userId: Int!
  bloodCountId: Int!
}

"""The globally unique `ID` look up for the row to connect."""
input BloodCountUserNodeIdConnect {
  """
  The globally unique `ID` which identifies a single `bloodCountUser` to be connected.
  """
  nodeId: ID!
}

"""The fields on `bloodCountUser` to look up the row to delete."""
input BloodCountUserBloodcountuserPkDelete {
  id: Int!
}

"""The fields on `bloodCountUser` to look up the row to delete."""
input BloodCountUserBloodCountUserUserIdBloodCountIdKeyDelete {
  userId: Int!
  bloodCountId: Int!
}

"""The globally unique `ID` look up for the row to delete."""
input BloodCountUserNodeIdDelete {
  """
  The globally unique `ID` which identifies a single `bloodCountUser` to be deleted.
  """
  nodeId: ID!
}

"""The fields on `bloodCountUser` to look up the row to update."""
input BloodCountUserOnBloodCountUserForBloodcountuserUserFkUsingBloodcountuserPkUpdate {
  """
  An object where the defined keys will be set on the `bloodCountUser` being updated.
  """
  patch: updateBloodCountUserOnBloodCountUserForBloodcountuserUserFkPatch!
  id: Int!
}

"""
An object where the defined keys will be set on the `bloodCountUser` being updated.
"""
input updateBloodCountUserOnBloodCountUserForBloodcountuserUserFkPatch {
  id: Int
  bloodCountId: Int
  userToUserId: BloodcountuserUserFkInput
  bloodCountToBloodCountId: BloodcountuserBloodcountFkInput
  bloodCountUserValuesUsingId: BloodcountuservalueBloodcountuserFkInverseInput
}

"""
Input for the nested mutation of `user` in the `BloodCountUserInput` mutation.
"""
input BloodcountuserUserFkInput {
  """The primary key(s) for `user` for the far side of the relationship."""
  connectById: UserUserPkConnect

  """The primary key(s) for `user` for the far side of the relationship."""
  connectByNodeId: UserNodeIdConnect

  """The primary key(s) for `user` for the far side of the relationship."""
  deleteById: UserUserPkDelete

  """The primary key(s) for `user` for the far side of the relationship."""
  deleteByNodeId: UserNodeIdDelete

  """
  The primary key(s) and patch data for `user` for the far side of the relationship.
  """
  updateById: UserOnBloodCountUserForBloodcountuserUserFkUsingUserPkUpdate

  """
  The primary key(s) and patch data for `user` for the far side of the relationship.
  """
  updateByNodeId: BloodCountUserOnBloodCountUserForBloodcountuserUserFkNodeIdUpdate

  """
  A `UserInput` object that will be created and connected to this object.
  """
  create: BloodcountuserUserFkUserCreateInput
}

"""The fields on `user` to look up the row to update."""
input UserOnBloodCountUserForBloodcountuserUserFkUsingUserPkUpdate {
  """
  An object where the defined keys will be set on the `user` being updated.
  """
  patch: updateUserOnBloodCountUserForBloodcountuserUserFkPatch!
  id: Int!
}

"""
An object where the defined keys will be set on the `user` being updated.
"""
input updateUserOnBloodCountUserForBloodcountuserUserFkPatch {
  id: Int
  foreName: String
  surName: String
  identNumber: String
  insuranceNumber: String
  email: String
  phone: String
  birthdate: Date
  verified: Boolean
  insuranceCompanyId: Int
  lastLogin: Date
  bloodTypeId: Int
  rhD: Boolean
  registeredAt: Date
  insuranceCompanyToInsuranceCompanyId: UserInsurancecompanyFkInput
  bloodTypeToBloodTypeId: UserBloodtypeFkInput
  meetingsUsingId: MeetingUserFkInverseInput
  userDiagnosesUsingId: UserdiagnosisUserFkInverseInput
  userMedicamentDaysUsingId: UsermedicamentdayUserFkInverseInput
  userMedicamentsUsingId: UsermedicamentUserFkInverseInput
  bloodCountUsersUsingId: BloodcountuserUserFkInverseInput
  ambulanceUsersUsingId: AmbulanceuserUserFkInverseInput
}

"""
Input for the nested mutation of `ambulanceUser` in the `UserInput` mutation.
"""
input AmbulanceuserUserFkInverseInput {
  """
  Flag indicating whether all other `ambulanceUser` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) for `ambulanceUser` for the far side of the relationship.
  """
  connectById: [AmbulanceUserAmbulanceuserPkConnect!]

  """
  The primary key(s) for `ambulanceUser` for the far side of the relationship.
  """
  connectByUserIdAndAmbulanceId: [AmbulanceUserAmbulanceUserUserIdAmbulanceIdKeyConnect!]

  """
  The primary key(s) for `ambulanceUser` for the far side of the relationship.
  """
  connectByNodeId: [AmbulanceUserNodeIdConnect!]

  """
  The primary key(s) for `ambulanceUser` for the far side of the relationship.
  """
  deleteById: [AmbulanceUserAmbulanceuserPkDelete!]

  """
  The primary key(s) for `ambulanceUser` for the far side of the relationship.
  """
  deleteByUserIdAndAmbulanceId: [AmbulanceUserAmbulanceUserUserIdAmbulanceIdKeyDelete!]

  """
  The primary key(s) for `ambulanceUser` for the far side of the relationship.
  """
  deleteByNodeId: [AmbulanceUserNodeIdDelete!]

  """
  The primary key(s) and patch data for `ambulanceUser` for the far side of the relationship.
  """
  updateById: [AmbulanceUserOnAmbulanceUserForAmbulanceuserUserFkUsingAmbulanceuserPkUpdate!]

  """
  The primary key(s) and patch data for `ambulanceUser` for the far side of the relationship.
  """
  updateByUserIdAndAmbulanceId: [AmbulanceUserOnAmbulanceUserForAmbulanceuserUserFkUsingAmbulanceUserUserIdAmbulanceIdKeyUpdate!]

  """
  The primary key(s) and patch data for `ambulanceUser` for the far side of the relationship.
  """
  updateByNodeId: [UserOnAmbulanceUserForAmbulanceuserUserFkNodeIdUpdate!]

  """
  A `AmbulanceUserInput` object that will be created and connected to this object.
  """
  create: [AmbulanceuserUserFkAmbulanceUserCreateInput!]
}

"""The fields on `ambulanceUser` to look up the row to update."""
input AmbulanceUserOnAmbulanceUserForAmbulanceuserUserFkUsingAmbulanceuserPkUpdate {
  """
  An object where the defined keys will be set on the `ambulanceUser` being updated.
  """
  patch: updateAmbulanceUserOnAmbulanceUserForAmbulanceuserUserFkPatch!
  id: Int!
}

"""
An object where the defined keys will be set on the `ambulanceUser` being updated.
"""
input updateAmbulanceUserOnAmbulanceUserForAmbulanceuserUserFkPatch {
  id: Int
  ambulanceId: Int
  ambulanceToAmbulanceId: AmbulanceuserAmbulanceFkInput
  userToUserId: AmbulanceuserUserFkInput
}

"""The fields on `ambulanceUser` to look up the row to update."""
input AmbulanceUserOnAmbulanceUserForAmbulanceuserUserFkUsingAmbulanceUserUserIdAmbulanceIdKeyUpdate {
  """
  An object where the defined keys will be set on the `ambulanceUser` being updated.
  """
  patch: updateAmbulanceUserOnAmbulanceUserForAmbulanceuserUserFkPatch!
  userId: Int!
  ambulanceId: Int!
}

"""The globally unique `ID` look up for the row to update."""
input UserOnAmbulanceUserForAmbulanceuserUserFkNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `ambulanceUser` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `ambulanceUser` being updated.
  """
  patch: AmbulanceUserPatch!
}

"""
Represents an update to a `AmbulanceUser`. Fields that are set will be updated.
"""
input AmbulanceUserPatch {
  id: Int
  ambulanceId: Int
  userId: Int
  ambulanceToAmbulanceId: AmbulanceuserAmbulanceFkInput
  userToUserId: AmbulanceuserUserFkInput
}

"""The `ambulanceUser` to be created by this mutation."""
input AmbulanceuserUserFkAmbulanceUserCreateInput {
  id: Int
  ambulanceId: Int
  ambulanceToAmbulanceId: AmbulanceuserAmbulanceFkInput
  userToUserId: AmbulanceuserUserFkInput
}

"""The globally unique `ID` look up for the row to update."""
input BloodCountUserOnBloodCountUserForBloodcountuserUserFkNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `user` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `user` being updated.
  """
  patch: UserPatch!
}

"""Represents an update to a `User`. Fields that are set will be updated."""
input UserPatch {
  id: Int
  foreName: String
  surName: String
  identNumber: String
  insuranceNumber: String
  email: String
  phone: String
  birthdate: Date
  verified: Boolean
  insuranceCompanyId: Int
  lastLogin: Date
  bloodTypeId: Int
  rhD: Boolean
  registeredAt: Date
  insuranceCompanyToInsuranceCompanyId: UserInsurancecompanyFkInput
  bloodTypeToBloodTypeId: UserBloodtypeFkInput
  meetingsUsingId: MeetingUserFkInverseInput
  userDiagnosesUsingId: UserdiagnosisUserFkInverseInput
  userMedicamentDaysUsingId: UsermedicamentdayUserFkInverseInput
  userMedicamentsUsingId: UsermedicamentUserFkInverseInput
  bloodCountUsersUsingId: BloodcountuserUserFkInverseInput
  ambulanceUsersUsingId: AmbulanceuserUserFkInverseInput
}

"""The `user` to be created by this mutation."""
input BloodcountuserUserFkUserCreateInput {
  id: Int
  foreName: String!
  surName: String!
  identNumber: String
  insuranceNumber: String
  email: String
  phone: String
  birthdate: Date
  verified: Boolean
  insuranceCompanyId: Int
  lastLogin: Date
  bloodTypeId: Int
  rhD: Boolean
  registeredAt: Date
  insuranceCompanyToInsuranceCompanyId: UserInsurancecompanyFkInput
  bloodTypeToBloodTypeId: UserBloodtypeFkInput
  meetingsUsingId: MeetingUserFkInverseInput
  userDiagnosesUsingId: UserdiagnosisUserFkInverseInput
  userMedicamentDaysUsingId: UsermedicamentdayUserFkInverseInput
  userMedicamentsUsingId: UsermedicamentUserFkInverseInput
  bloodCountUsersUsingId: BloodcountuserUserFkInverseInput
  ambulanceUsersUsingId: AmbulanceuserUserFkInverseInput
}

"""
Input for the nested mutation of `bloodCount` in the `BloodCountUserInput` mutation.
"""
input BloodcountuserBloodcountFkInput {
  """
  The primary key(s) for `bloodCount` for the far side of the relationship.
  """
  connectById: BloodCountBloodcountPkConnect

  """
  The primary key(s) for `bloodCount` for the far side of the relationship.
  """
  connectByNodeId: BloodCountNodeIdConnect

  """
  The primary key(s) for `bloodCount` for the far side of the relationship.
  """
  deleteById: BloodCountBloodcountPkDelete

  """
  The primary key(s) for `bloodCount` for the far side of the relationship.
  """
  deleteByNodeId: BloodCountNodeIdDelete

  """
  The primary key(s) and patch data for `bloodCount` for the far side of the relationship.
  """
  updateById: BloodCountOnBloodCountUserForBloodcountuserBloodcountFkUsingBloodcountPkUpdate

  """
  The primary key(s) and patch data for `bloodCount` for the far side of the relationship.
  """
  updateByNodeId: BloodCountUserOnBloodCountUserForBloodcountuserBloodcountFkNodeIdUpdate

  """
  A `BloodCountInput` object that will be created and connected to this object.
  """
  create: BloodcountuserBloodcountFkBloodCountCreateInput
}

"""The fields on `bloodCount` to look up the row to connect."""
input BloodCountBloodcountPkConnect {
  id: Int!
}

"""The globally unique `ID` look up for the row to connect."""
input BloodCountNodeIdConnect {
  """
  The globally unique `ID` which identifies a single `bloodCount` to be connected.
  """
  nodeId: ID!
}

"""The fields on `bloodCount` to look up the row to delete."""
input BloodCountBloodcountPkDelete {
  id: Int!
}

"""The globally unique `ID` look up for the row to delete."""
input BloodCountNodeIdDelete {
  """
  The globally unique `ID` which identifies a single `bloodCount` to be deleted.
  """
  nodeId: ID!
}

"""The fields on `bloodCount` to look up the row to update."""
input BloodCountOnBloodCountUserForBloodcountuserBloodcountFkUsingBloodcountPkUpdate {
  """
  An object where the defined keys will be set on the `bloodCount` being updated.
  """
  patch: updateBloodCountOnBloodCountUserForBloodcountuserBloodcountFkPatch!
  id: Int!
}

"""
An object where the defined keys will be set on the `bloodCount` being updated.
"""
input updateBloodCountOnBloodCountUserForBloodcountuserBloodcountFkPatch {
  id: Int
  acronym: String
  title: String
  men: BigFloatRangeInput
  women: BigFloatRangeInput
  units: String
  source: String
  description: String
  bloodCountUsersUsingId: BloodcountuserBloodcountFkInverseInput
}

"""
Input for the nested mutation of `bloodCountUser` in the `BloodCountInput` mutation.
"""
input BloodcountuserBloodcountFkInverseInput {
  """
  Flag indicating whether all other `bloodCountUser` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) for `bloodCountUser` for the far side of the relationship.
  """
  connectById: [BloodCountUserBloodcountuserPkConnect!]

  """
  The primary key(s) for `bloodCountUser` for the far side of the relationship.
  """
  connectByUserIdAndBloodCountId: [BloodCountUserBloodCountUserUserIdBloodCountIdKeyConnect!]

  """
  The primary key(s) for `bloodCountUser` for the far side of the relationship.
  """
  connectByNodeId: [BloodCountUserNodeIdConnect!]

  """
  The primary key(s) for `bloodCountUser` for the far side of the relationship.
  """
  deleteById: [BloodCountUserBloodcountuserPkDelete!]

  """
  The primary key(s) for `bloodCountUser` for the far side of the relationship.
  """
  deleteByUserIdAndBloodCountId: [BloodCountUserBloodCountUserUserIdBloodCountIdKeyDelete!]

  """
  The primary key(s) for `bloodCountUser` for the far side of the relationship.
  """
  deleteByNodeId: [BloodCountUserNodeIdDelete!]

  """
  The primary key(s) and patch data for `bloodCountUser` for the far side of the relationship.
  """
  updateById: [BloodCountUserOnBloodCountUserForBloodcountuserBloodcountFkUsingBloodcountuserPkUpdate!]

  """
  The primary key(s) and patch data for `bloodCountUser` for the far side of the relationship.
  """
  updateByUserIdAndBloodCountId: [BloodCountUserOnBloodCountUserForBloodcountuserBloodcountFkUsingBloodCountUserUserIdBloodCountIdKeyUpdate!]

  """
  The primary key(s) and patch data for `bloodCountUser` for the far side of the relationship.
  """
  updateByNodeId: [BloodCountOnBloodCountUserForBloodcountuserBloodcountFkNodeIdUpdate!]

  """
  A `BloodCountUserInput` object that will be created and connected to this object.
  """
  create: [BloodcountuserBloodcountFkBloodCountUserCreateInput!]
}

"""The fields on `bloodCountUser` to look up the row to update."""
input BloodCountUserOnBloodCountUserForBloodcountuserBloodcountFkUsingBloodcountuserPkUpdate {
  """
  An object where the defined keys will be set on the `bloodCountUser` being updated.
  """
  patch: updateBloodCountUserOnBloodCountUserForBloodcountuserBloodcountFkPatch!
  id: Int!
}

"""
An object where the defined keys will be set on the `bloodCountUser` being updated.
"""
input updateBloodCountUserOnBloodCountUserForBloodcountuserBloodcountFkPatch {
  id: Int
  userId: Int
  userToUserId: BloodcountuserUserFkInput
  bloodCountToBloodCountId: BloodcountuserBloodcountFkInput
  bloodCountUserValuesUsingId: BloodcountuservalueBloodcountuserFkInverseInput
}

"""
Input for the nested mutation of `bloodCountUserValue` in the `BloodCountUserInput` mutation.
"""
input BloodcountuservalueBloodcountuserFkInverseInput {
  """
  Flag indicating whether all other `bloodCountUserValue` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) for `bloodCountUserValue` for the far side of the relationship.
  """
  connectById: [BloodCountUserValueBloodcountuservaluePkConnect!]

  """
  The primary key(s) for `bloodCountUserValue` for the far side of the relationship.
  """
  connectByNodeId: [BloodCountUserValueNodeIdConnect!]

  """
  The primary key(s) for `bloodCountUserValue` for the far side of the relationship.
  """
  deleteById: [BloodCountUserValueBloodcountuservaluePkDelete!]

  """
  The primary key(s) for `bloodCountUserValue` for the far side of the relationship.
  """
  deleteByNodeId: [BloodCountUserValueNodeIdDelete!]

  """
  The primary key(s) and patch data for `bloodCountUserValue` for the far side of the relationship.
  """
  updateById: [BloodCountUserValueOnBloodCountUserValueForBloodcountuservalueBloodcountuserFkUsingBloodcountuservaluePkUpdate!]

  """
  The primary key(s) and patch data for `bloodCountUserValue` for the far side of the relationship.
  """
  updateByNodeId: [BloodCountUserOnBloodCountUserValueForBloodcountuservalueBloodcountuserFkNodeIdUpdate!]

  """
  A `BloodCountUserValueInput` object that will be created and connected to this object.
  """
  create: [BloodcountuservalueBloodcountuserFkBloodCountUserValueCreateInput!]
}

"""The fields on `bloodCountUserValue` to look up the row to connect."""
input BloodCountUserValueBloodcountuservaluePkConnect {
  id: Int!
}

"""The globally unique `ID` look up for the row to connect."""
input BloodCountUserValueNodeIdConnect {
  """
  The globally unique `ID` which identifies a single `bloodCountUserValue` to be connected.
  """
  nodeId: ID!
}

"""The fields on `bloodCountUserValue` to look up the row to delete."""
input BloodCountUserValueBloodcountuservaluePkDelete {
  id: Int!
}

"""The globally unique `ID` look up for the row to delete."""
input BloodCountUserValueNodeIdDelete {
  """
  The globally unique `ID` which identifies a single `bloodCountUserValue` to be deleted.
  """
  nodeId: ID!
}

"""The fields on `bloodCountUserValue` to look up the row to update."""
input BloodCountUserValueOnBloodCountUserValueForBloodcountuservalueBloodcountuserFkUsingBloodcountuservaluePkUpdate {
  """
  An object where the defined keys will be set on the `bloodCountUserValue` being updated.
  """
  patch: updateBloodCountUserValueOnBloodCountUserValueForBloodcountuservalueBloodcountuserFkPatch!
  id: Int!
}

"""
An object where the defined keys will be set on the `bloodCountUserValue` being updated.
"""
input updateBloodCountUserValueOnBloodCountUserValueForBloodcountuservalueBloodcountuserFkPatch {
  id: Int
  meetingId: Int
  bloodCountValue: Float
  description: String
  createdAt: Date
  bloodCountUserToBloodCountUserId: BloodcountuservalueBloodcountuserFkInput
  meetingToMeetingId: BloodcountuservalueMeetingFkInput
}

"""
Input for the nested mutation of `bloodCountUser` in the `BloodCountUserValueInput` mutation.
"""
input BloodcountuservalueBloodcountuserFkInput {
  """
  The primary key(s) for `bloodCountUser` for the far side of the relationship.
  """
  connectById: BloodCountUserBloodcountuserPkConnect

  """
  The primary key(s) for `bloodCountUser` for the far side of the relationship.
  """
  connectByUserIdAndBloodCountId: BloodCountUserBloodCountUserUserIdBloodCountIdKeyConnect

  """
  The primary key(s) for `bloodCountUser` for the far side of the relationship.
  """
  connectByNodeId: BloodCountUserNodeIdConnect

  """
  The primary key(s) for `bloodCountUser` for the far side of the relationship.
  """
  deleteById: BloodCountUserBloodcountuserPkDelete

  """
  The primary key(s) for `bloodCountUser` for the far side of the relationship.
  """
  deleteByUserIdAndBloodCountId: BloodCountUserBloodCountUserUserIdBloodCountIdKeyDelete

  """
  The primary key(s) for `bloodCountUser` for the far side of the relationship.
  """
  deleteByNodeId: BloodCountUserNodeIdDelete

  """
  The primary key(s) and patch data for `bloodCountUser` for the far side of the relationship.
  """
  updateById: BloodCountUserOnBloodCountUserValueForBloodcountuservalueBloodcountuserFkUsingBloodcountuserPkUpdate

  """
  The primary key(s) and patch data for `bloodCountUser` for the far side of the relationship.
  """
  updateByUserIdAndBloodCountId: BloodCountUserOnBloodCountUserValueForBloodcountuservalueBloodcountuserFkUsingBloodCountUserUserIdBloodCountIdKeyUpdate

  """
  The primary key(s) and patch data for `bloodCountUser` for the far side of the relationship.
  """
  updateByNodeId: BloodCountUserValueOnBloodCountUserValueForBloodcountuservalueBloodcountuserFkNodeIdUpdate

  """
  A `BloodCountUserInput` object that will be created and connected to this object.
  """
  create: BloodcountuservalueBloodcountuserFkBloodCountUserCreateInput
}

"""The fields on `bloodCountUser` to look up the row to update."""
input BloodCountUserOnBloodCountUserValueForBloodcountuservalueBloodcountuserFkUsingBloodcountuserPkUpdate {
  """
  An object where the defined keys will be set on the `bloodCountUser` being updated.
  """
  patch: updateBloodCountUserOnBloodCountUserValueForBloodcountuservalueBloodcountuserFkPatch!
  id: Int!
}

"""
An object where the defined keys will be set on the `bloodCountUser` being updated.
"""
input updateBloodCountUserOnBloodCountUserValueForBloodcountuservalueBloodcountuserFkPatch {
  id: Int
  userId: Int
  bloodCountId: Int
  userToUserId: BloodcountuserUserFkInput
  bloodCountToBloodCountId: BloodcountuserBloodcountFkInput
  bloodCountUserValuesUsingId: BloodcountuservalueBloodcountuserFkInverseInput
}

"""The fields on `bloodCountUser` to look up the row to update."""
input BloodCountUserOnBloodCountUserValueForBloodcountuservalueBloodcountuserFkUsingBloodCountUserUserIdBloodCountIdKeyUpdate {
  """
  An object where the defined keys will be set on the `bloodCountUser` being updated.
  """
  patch: updateBloodCountUserOnBloodCountUserValueForBloodcountuservalueBloodcountuserFkPatch!
  userId: Int!
  bloodCountId: Int!
}

"""The globally unique `ID` look up for the row to update."""
input BloodCountUserValueOnBloodCountUserValueForBloodcountuservalueBloodcountuserFkNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `bloodCountUser` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `bloodCountUser` being updated.
  """
  patch: BloodCountUserPatch!
}

"""
Represents an update to a `BloodCountUser`. Fields that are set will be updated.
"""
input BloodCountUserPatch {
  id: Int
  userId: Int
  bloodCountId: Int
  userToUserId: BloodcountuserUserFkInput
  bloodCountToBloodCountId: BloodcountuserBloodcountFkInput
  bloodCountUserValuesUsingId: BloodcountuservalueBloodcountuserFkInverseInput
}

"""The `bloodCountUser` to be created by this mutation."""
input BloodcountuservalueBloodcountuserFkBloodCountUserCreateInput {
  id: Int
  userId: Int
  bloodCountId: Int
  userToUserId: BloodcountuserUserFkInput
  bloodCountToBloodCountId: BloodcountuserBloodcountFkInput
  bloodCountUserValuesUsingId: BloodcountuservalueBloodcountuserFkInverseInput
}

"""
Input for the nested mutation of `meeting` in the `BloodCountUserValueInput` mutation.
"""
input BloodcountuservalueMeetingFkInput {
  """The primary key(s) for `meeting` for the far side of the relationship."""
  connectById: MeetingMeetingPkConnect

  """The primary key(s) for `meeting` for the far side of the relationship."""
  connectByMeetingDateAndUserIdAndAdminId: MeetingMeetingMeetingDateUserIdAdminIdKeyConnect

  """The primary key(s) for `meeting` for the far side of the relationship."""
  connectByAdminIdAndMeetingTimeAndMeetingDate: MeetingMeetingAdminIdMeetingTimeMeetingDateKeyConnect

  """The primary key(s) for `meeting` for the far side of the relationship."""
  connectByNodeId: MeetingNodeIdConnect

  """The primary key(s) for `meeting` for the far side of the relationship."""
  deleteById: MeetingMeetingPkDelete

  """The primary key(s) for `meeting` for the far side of the relationship."""
  deleteByMeetingDateAndUserIdAndAdminId: MeetingMeetingMeetingDateUserIdAdminIdKeyDelete

  """The primary key(s) for `meeting` for the far side of the relationship."""
  deleteByAdminIdAndMeetingTimeAndMeetingDate: MeetingMeetingAdminIdMeetingTimeMeetingDateKeyDelete

  """The primary key(s) for `meeting` for the far side of the relationship."""
  deleteByNodeId: MeetingNodeIdDelete

  """
  The primary key(s) and patch data for `meeting` for the far side of the relationship.
  """
  updateById: MeetingOnBloodCountUserValueForBloodcountuservalueMeetingFkUsingMeetingPkUpdate

  """
  The primary key(s) and patch data for `meeting` for the far side of the relationship.
  """
  updateByMeetingDateAndUserIdAndAdminId: MeetingOnBloodCountUserValueForBloodcountuservalueMeetingFkUsingMeetingMeetingDateUserIdAdminIdKeyUpdate

  """
  The primary key(s) and patch data for `meeting` for the far side of the relationship.
  """
  updateByAdminIdAndMeetingTimeAndMeetingDate: MeetingOnBloodCountUserValueForBloodcountuservalueMeetingFkUsingMeetingAdminIdMeetingTimeMeetingDateKeyUpdate

  """
  The primary key(s) and patch data for `meeting` for the far side of the relationship.
  """
  updateByNodeId: BloodCountUserValueOnBloodCountUserValueForBloodcountuservalueMeetingFkNodeIdUpdate

  """
  A `MeetingInput` object that will be created and connected to this object.
  """
  create: BloodcountuservalueMeetingFkMeetingCreateInput
}

"""The fields on `meeting` to look up the row to update."""
input MeetingOnBloodCountUserValueForBloodcountuservalueMeetingFkUsingMeetingPkUpdate {
  """
  An object where the defined keys will be set on the `meeting` being updated.
  """
  patch: updateMeetingOnBloodCountUserValueForBloodcountuservalueMeetingFkPatch!
  id: Int!
}

"""
An object where the defined keys will be set on the `meeting` being updated.
"""
input updateMeetingOnBloodCountUserValueForBloodcountuservalueMeetingFkPatch {
  id: Int
  meetingDate: Date
  note: String
  userId: Int
  adminId: Int
  meetingTime: Time
  ambulanceId: Int
  createdAt: Date
  userToUserId: MeetingUserFkInput
  adminToAdminId: MeetingAdminFkInput
  ambulanceToAmbulanceId: MeetingAmbulanceFkInput
  bloodCountUserValuesUsingId: BloodcountuservalueMeetingFkInverseInput
}

"""
Input for the nested mutation of `bloodCountUserValue` in the `MeetingInput` mutation.
"""
input BloodcountuservalueMeetingFkInverseInput {
  """
  Flag indicating whether all other `bloodCountUserValue` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) for `bloodCountUserValue` for the far side of the relationship.
  """
  connectById: [BloodCountUserValueBloodcountuservaluePkConnect!]

  """
  The primary key(s) for `bloodCountUserValue` for the far side of the relationship.
  """
  connectByNodeId: [BloodCountUserValueNodeIdConnect!]

  """
  The primary key(s) for `bloodCountUserValue` for the far side of the relationship.
  """
  deleteById: [BloodCountUserValueBloodcountuservaluePkDelete!]

  """
  The primary key(s) for `bloodCountUserValue` for the far side of the relationship.
  """
  deleteByNodeId: [BloodCountUserValueNodeIdDelete!]

  """
  The primary key(s) and patch data for `bloodCountUserValue` for the far side of the relationship.
  """
  updateById: [BloodCountUserValueOnBloodCountUserValueForBloodcountuservalueMeetingFkUsingBloodcountuservaluePkUpdate!]

  """
  The primary key(s) and patch data for `bloodCountUserValue` for the far side of the relationship.
  """
  updateByNodeId: [MeetingOnBloodCountUserValueForBloodcountuservalueMeetingFkNodeIdUpdate!]

  """
  A `BloodCountUserValueInput` object that will be created and connected to this object.
  """
  create: [BloodcountuservalueMeetingFkBloodCountUserValueCreateInput!]
}

"""The fields on `bloodCountUserValue` to look up the row to update."""
input BloodCountUserValueOnBloodCountUserValueForBloodcountuservalueMeetingFkUsingBloodcountuservaluePkUpdate {
  """
  An object where the defined keys will be set on the `bloodCountUserValue` being updated.
  """
  patch: updateBloodCountUserValueOnBloodCountUserValueForBloodcountuservalueMeetingFkPatch!
  id: Int!
}

"""
An object where the defined keys will be set on the `bloodCountUserValue` being updated.
"""
input updateBloodCountUserValueOnBloodCountUserValueForBloodcountuservalueMeetingFkPatch {
  id: Int
  bloodCountUserId: Int
  bloodCountValue: Float
  description: String
  createdAt: Date
  bloodCountUserToBloodCountUserId: BloodcountuservalueBloodcountuserFkInput
  meetingToMeetingId: BloodcountuservalueMeetingFkInput
}

"""The globally unique `ID` look up for the row to update."""
input MeetingOnBloodCountUserValueForBloodcountuservalueMeetingFkNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `bloodCountUserValue` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `bloodCountUserValue` being updated.
  """
  patch: BloodCountUserValuePatch!
}

"""
Represents an update to a `BloodCountUserValue`. Fields that are set will be updated.
"""
input BloodCountUserValuePatch {
  id: Int
  bloodCountUserId: Int
  meetingId: Int
  bloodCountValue: Float
  description: String
  createdAt: Date
  bloodCountUserToBloodCountUserId: BloodcountuservalueBloodcountuserFkInput
  meetingToMeetingId: BloodcountuservalueMeetingFkInput
}

"""The `bloodCountUserValue` to be created by this mutation."""
input BloodcountuservalueMeetingFkBloodCountUserValueCreateInput {
  id: Int
  bloodCountUserId: Int
  bloodCountValue: Float!
  description: String
  createdAt: Date
  bloodCountUserToBloodCountUserId: BloodcountuservalueBloodcountuserFkInput
  meetingToMeetingId: BloodcountuservalueMeetingFkInput
}

"""The fields on `meeting` to look up the row to update."""
input MeetingOnBloodCountUserValueForBloodcountuservalueMeetingFkUsingMeetingMeetingDateUserIdAdminIdKeyUpdate {
  """
  An object where the defined keys will be set on the `meeting` being updated.
  """
  patch: updateMeetingOnBloodCountUserValueForBloodcountuservalueMeetingFkPatch!
  meetingDate: Date!
  userId: Int!
  adminId: Int!
}

"""The fields on `meeting` to look up the row to update."""
input MeetingOnBloodCountUserValueForBloodcountuservalueMeetingFkUsingMeetingAdminIdMeetingTimeMeetingDateKeyUpdate {
  """
  An object where the defined keys will be set on the `meeting` being updated.
  """
  patch: updateMeetingOnBloodCountUserValueForBloodcountuservalueMeetingFkPatch!
  adminId: Int!
  meetingTime: Time!
  meetingDate: Date!
}

"""The globally unique `ID` look up for the row to update."""
input BloodCountUserValueOnBloodCountUserValueForBloodcountuservalueMeetingFkNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `meeting` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `meeting` being updated.
  """
  patch: MeetingPatch!
}

"""
Represents an update to a `Meeting`. Fields that are set will be updated.
"""
input MeetingPatch {
  id: Int
  meetingDate: Date
  note: String
  userId: Int
  adminId: Int
  meetingTime: Time
  ambulanceId: Int
  createdAt: Date
  userToUserId: MeetingUserFkInput
  adminToAdminId: MeetingAdminFkInput
  ambulanceToAmbulanceId: MeetingAmbulanceFkInput
  bloodCountUserValuesUsingId: BloodcountuservalueMeetingFkInverseInput
}

"""The `meeting` to be created by this mutation."""
input BloodcountuservalueMeetingFkMeetingCreateInput {
  id: Int
  meetingDate: Date!
  note: String
  userId: Int
  adminId: Int
  meetingTime: Time!
  ambulanceId: Int
  createdAt: Date
  userToUserId: MeetingUserFkInput
  adminToAdminId: MeetingAdminFkInput
  ambulanceToAmbulanceId: MeetingAmbulanceFkInput
  bloodCountUserValuesUsingId: BloodcountuservalueMeetingFkInverseInput
}

"""The globally unique `ID` look up for the row to update."""
input BloodCountUserOnBloodCountUserValueForBloodcountuservalueBloodcountuserFkNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `bloodCountUserValue` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `bloodCountUserValue` being updated.
  """
  patch: BloodCountUserValuePatch!
}

"""The `bloodCountUserValue` to be created by this mutation."""
input BloodcountuservalueBloodcountuserFkBloodCountUserValueCreateInput {
  id: Int
  meetingId: Int
  bloodCountValue: Float!
  description: String
  createdAt: Date
  bloodCountUserToBloodCountUserId: BloodcountuservalueBloodcountuserFkInput
  meetingToMeetingId: BloodcountuservalueMeetingFkInput
}

"""The fields on `bloodCountUser` to look up the row to update."""
input BloodCountUserOnBloodCountUserForBloodcountuserBloodcountFkUsingBloodCountUserUserIdBloodCountIdKeyUpdate {
  """
  An object where the defined keys will be set on the `bloodCountUser` being updated.
  """
  patch: updateBloodCountUserOnBloodCountUserForBloodcountuserBloodcountFkPatch!
  userId: Int!
  bloodCountId: Int!
}

"""The globally unique `ID` look up for the row to update."""
input BloodCountOnBloodCountUserForBloodcountuserBloodcountFkNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `bloodCountUser` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `bloodCountUser` being updated.
  """
  patch: BloodCountUserPatch!
}

"""The `bloodCountUser` to be created by this mutation."""
input BloodcountuserBloodcountFkBloodCountUserCreateInput {
  id: Int
  userId: Int
  userToUserId: BloodcountuserUserFkInput
  bloodCountToBloodCountId: BloodcountuserBloodcountFkInput
  bloodCountUserValuesUsingId: BloodcountuservalueBloodcountuserFkInverseInput
}

"""The globally unique `ID` look up for the row to update."""
input BloodCountUserOnBloodCountUserForBloodcountuserBloodcountFkNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `bloodCount` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `bloodCount` being updated.
  """
  patch: BloodCountPatch!
}

"""
Represents an update to a `BloodCount`. Fields that are set will be updated.
"""
input BloodCountPatch {
  id: Int
  acronym: String
  title: String
  men: BigFloatRangeInput
  women: BigFloatRangeInput
  units: String
  source: String
  description: String
  bloodCountUsersUsingId: BloodcountuserBloodcountFkInverseInput
}

"""The `bloodCount` to be created by this mutation."""
input BloodcountuserBloodcountFkBloodCountCreateInput {
  id: Int
  acronym: String!
  title: String!
  men: BigFloatRangeInput!
  women: BigFloatRangeInput!
  units: String
  source: String!
  description: String
  bloodCountUsersUsingId: BloodcountuserBloodcountFkInverseInput
}

"""The fields on `bloodCountUser` to look up the row to update."""
input BloodCountUserOnBloodCountUserForBloodcountuserUserFkUsingBloodCountUserUserIdBloodCountIdKeyUpdate {
  """
  An object where the defined keys will be set on the `bloodCountUser` being updated.
  """
  patch: updateBloodCountUserOnBloodCountUserForBloodcountuserUserFkPatch!
  userId: Int!
  bloodCountId: Int!
}

"""The globally unique `ID` look up for the row to update."""
input UserOnBloodCountUserForBloodcountuserUserFkNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `bloodCountUser` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `bloodCountUser` being updated.
  """
  patch: BloodCountUserPatch!
}

"""The `bloodCountUser` to be created by this mutation."""
input BloodcountuserUserFkBloodCountUserCreateInput {
  id: Int
  bloodCountId: Int
  userToUserId: BloodcountuserUserFkInput
  bloodCountToBloodCountId: BloodcountuserBloodcountFkInput
  bloodCountUserValuesUsingId: BloodcountuservalueBloodcountuserFkInverseInput
}

"""The globally unique `ID` look up for the row to update."""
input AmbulanceUserOnAmbulanceUserForAmbulanceuserUserFkNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `user` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `user` being updated.
  """
  patch: UserPatch!
}

"""The `user` to be created by this mutation."""
input AmbulanceuserUserFkUserCreateInput {
  id: Int
  foreName: String!
  surName: String!
  identNumber: String
  insuranceNumber: String
  email: String
  phone: String
  birthdate: Date
  verified: Boolean
  insuranceCompanyId: Int
  lastLogin: Date
  bloodTypeId: Int
  rhD: Boolean
  registeredAt: Date
  insuranceCompanyToInsuranceCompanyId: UserInsurancecompanyFkInput
  bloodTypeToBloodTypeId: UserBloodtypeFkInput
  meetingsUsingId: MeetingUserFkInverseInput
  userDiagnosesUsingId: UserdiagnosisUserFkInverseInput
  userMedicamentDaysUsingId: UsermedicamentdayUserFkInverseInput
  userMedicamentsUsingId: UsermedicamentUserFkInverseInput
  bloodCountUsersUsingId: BloodcountuserUserFkInverseInput
  ambulanceUsersUsingId: AmbulanceuserUserFkInverseInput
}

"""The fields on `ambulanceUser` to look up the row to update."""
input AmbulanceUserOnAmbulanceUserForAmbulanceuserAmbulanceFkUsingAmbulanceUserUserIdAmbulanceIdKeyUpdate {
  """
  An object where the defined keys will be set on the `ambulanceUser` being updated.
  """
  patch: updateAmbulanceUserOnAmbulanceUserForAmbulanceuserAmbulanceFkPatch!
  userId: Int!
  ambulanceId: Int!
}

"""The globally unique `ID` look up for the row to update."""
input AmbulanceOnAmbulanceUserForAmbulanceuserAmbulanceFkNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `ambulanceUser` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `ambulanceUser` being updated.
  """
  patch: AmbulanceUserPatch!
}

"""The `ambulanceUser` to be created by this mutation."""
input AmbulanceuserAmbulanceFkAmbulanceUserCreateInput {
  id: Int
  userId: Int
  ambulanceToAmbulanceId: AmbulanceuserAmbulanceFkInput
  userToUserId: AmbulanceuserUserFkInput
}

"""The globally unique `ID` look up for the row to update."""
input MeetingOnMeetingForMeetingAmbulanceFkNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `ambulance` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `ambulance` being updated.
  """
  patch: AmbulancePatch!
}

"""The `ambulance` to be created by this mutation."""
input MeetingAmbulanceFkAmbulanceCreateInput {
  id: Int
  name: String!
  ico: String
  cityId: Int
  street: String!
  state: String!
  suite: String!
  email: String!
  cityToCityId: AmbulanceCityFkInput
  adminsUsingId: AdminAmbulanceFkInverseInput
  meetingsUsingId: MeetingAmbulanceFkInverseInput
  ambulanceUsersUsingId: AmbulanceuserAmbulanceFkInverseInput
  meetingHoursUsingId: MeetinghoursAmbulanceFkInverseInput
}

"""The fields on `meeting` to look up the row to update."""
input MeetingOnMeetingForMeetingAmbulanceFkUsingMeetingMeetingDateUserIdAdminIdKeyUpdate {
  """
  An object where the defined keys will be set on the `meeting` being updated.
  """
  patch: updateMeetingOnMeetingForMeetingAmbulanceFkPatch!
  meetingDate: Date!
  userId: Int!
  adminId: Int!
}

"""The fields on `meeting` to look up the row to update."""
input MeetingOnMeetingForMeetingAmbulanceFkUsingMeetingAdminIdMeetingTimeMeetingDateKeyUpdate {
  """
  An object where the defined keys will be set on the `meeting` being updated.
  """
  patch: updateMeetingOnMeetingForMeetingAmbulanceFkPatch!
  adminId: Int!
  meetingTime: Time!
  meetingDate: Date!
}

"""The globally unique `ID` look up for the row to update."""
input AmbulanceOnMeetingForMeetingAmbulanceFkNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `meeting` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `meeting` being updated.
  """
  patch: MeetingPatch!
}

"""The `meeting` to be created by this mutation."""
input MeetingAmbulanceFkMeetingCreateInput {
  id: Int
  meetingDate: Date!
  note: String
  userId: Int
  adminId: Int
  meetingTime: Time!
  createdAt: Date
  userToUserId: MeetingUserFkInput
  adminToAdminId: MeetingAdminFkInput
  ambulanceToAmbulanceId: MeetingAmbulanceFkInput
  bloodCountUserValuesUsingId: BloodcountuservalueMeetingFkInverseInput
}

"""The globally unique `ID` look up for the row to update."""
input MeetingHourOnMeetingHourForMeetinghoursAmbulanceFkNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `ambulance` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `ambulance` being updated.
  """
  patch: AmbulancePatch!
}

"""The `ambulance` to be created by this mutation."""
input MeetinghoursAmbulanceFkAmbulanceCreateInput {
  id: Int
  name: String!
  ico: String
  cityId: Int
  street: String!
  state: String!
  suite: String!
  email: String!
  cityToCityId: AmbulanceCityFkInput
  adminsUsingId: AdminAmbulanceFkInverseInput
  meetingsUsingId: MeetingAmbulanceFkInverseInput
  ambulanceUsersUsingId: AmbulanceuserAmbulanceFkInverseInput
  meetingHoursUsingId: MeetinghoursAmbulanceFkInverseInput
}

"""The globally unique `ID` look up for the row to update."""
input AdminOnMeetingHourForMeetinghoursAdminFkNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `meetingHour` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `meetingHour` being updated.
  """
  patch: MeetingHourPatch!
}

"""The `meetingHour` to be created by this mutation."""
input MeetinghoursAdminFkMeetingHoursCreateInput {
  id: Int
  ambulanceId: Int
  startHours: JSON
  endHours: JSON
  interval: Int
  adminToAdminId: MeetinghoursAdminFkInput
  ambulanceToAmbulanceId: MeetinghoursAmbulanceFkInput
}

"""The globally unique `ID` look up for the row to update."""
input AdminMedicamentDescriptionOnAdminMedicamentDescriptionForAdminmedicamentdescriptionAdminFkNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `admin` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `admin` being updated.
  """
  patch: AdminPatch!
}

"""The `admin` to be created by this mutation."""
input AdminmedicamentdescriptionAdminFkAdminCreateInput {
  id: Int
  firstName: String!
  lastName: String!
  ambulanceId: Int
  adminVerified: Boolean
  registrationDate: Date
  email: String
  phone: String
  lastLogin: Date
  interval: Int!
  ambulanceToAmbulanceId: AdminAmbulanceFkInput
  meetingsUsingId: MeetingAdminFkInverseInput
  userMedicamentsUsingId: UsermedicamentAdminFkInverseInput
  adminMedicamentDescriptionsUsingId: AdminmedicamentdescriptionAdminFkInverseInput
  meetingHoursUsingId: MeetinghoursAdminFkInverseInput
}

"""
Input for the nested mutation of `medicament` in the `AdminMedicamentDescriptionInput` mutation.
"""
input AdminmedicamentdescriptionMedicamentFkInput {
  """
  The primary key(s) for `medicament` for the far side of the relationship.
  """
  connectById: MedicamentMedicamentPkConnect

  """
  The primary key(s) for `medicament` for the far side of the relationship.
  """
  connectByNodeId: MedicamentNodeIdConnect

  """
  The primary key(s) for `medicament` for the far side of the relationship.
  """
  deleteById: MedicamentMedicamentPkDelete

  """
  The primary key(s) for `medicament` for the far side of the relationship.
  """
  deleteByNodeId: MedicamentNodeIdDelete

  """
  The primary key(s) and patch data for `medicament` for the far side of the relationship.
  """
  updateById: MedicamentOnAdminMedicamentDescriptionForAdminmedicamentdescriptionMedicamentFkUsingMedicamentPkUpdate

  """
  The primary key(s) and patch data for `medicament` for the far side of the relationship.
  """
  updateByNodeId: AdminMedicamentDescriptionOnAdminMedicamentDescriptionForAdminmedicamentdescriptionMedicamentFkNodeIdUpdate

  """
  A `MedicamentInput` object that will be created and connected to this object.
  """
  create: AdminmedicamentdescriptionMedicamentFkMedicamentCreateInput
}

"""The fields on `medicament` to look up the row to update."""
input MedicamentOnAdminMedicamentDescriptionForAdminmedicamentdescriptionMedicamentFkUsingMedicamentPkUpdate {
  """
  An object where the defined keys will be set on the `medicament` being updated.
  """
  patch: updateMedicamentOnAdminMedicamentDescriptionForAdminmedicamentdescriptionMedicamentFkPatch!
  id: Int!
}

"""
An object where the defined keys will be set on the `medicament` being updated.
"""
input updateMedicamentOnAdminMedicamentDescriptionForAdminmedicamentdescriptionMedicamentFkPatch {
  id: Int
  code: String
  title: String
  supplement: String
  strength: String
  packaging: Int
  holderCode: String
  stateCode: String
  atcCode: String
  atcTitleSk: String
  indicationGroup: String
  regNumber: String
  expiration: String
  dispensing: String
  registrationType: String
  regDate: String
  validity: String
  securityFeature: Boolean
  userMedicamentsUsingId: UsermedicamentMedicamentFkInverseInput
  adminMedicamentDescriptionsUsingId: AdminmedicamentdescriptionMedicamentFkInverseInput
}

"""
Input for the nested mutation of `adminMedicamentDescription` in the `MedicamentInput` mutation.
"""
input AdminmedicamentdescriptionMedicamentFkInverseInput {
  """
  Flag indicating whether all other `adminMedicamentDescription` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) for `adminMedicamentDescription` for the far side of the relationship.
  """
  connectById: [AdminMedicamentDescriptionAdminmedicamentdescriptionPkConnect!]

  """
  The primary key(s) for `adminMedicamentDescription` for the far side of the relationship.
  """
  connectByNodeId: [AdminMedicamentDescriptionNodeIdConnect!]

  """
  The primary key(s) for `adminMedicamentDescription` for the far side of the relationship.
  """
  deleteById: [AdminMedicamentDescriptionAdminmedicamentdescriptionPkDelete!]

  """
  The primary key(s) for `adminMedicamentDescription` for the far side of the relationship.
  """
  deleteByNodeId: [AdminMedicamentDescriptionNodeIdDelete!]

  """
  The primary key(s) and patch data for `adminMedicamentDescription` for the far side of the relationship.
  """
  updateById: [AdminMedicamentDescriptionOnAdminMedicamentDescriptionForAdminmedicamentdescriptionMedicamentFkUsingAdminmedicamentdescriptionPkUpdate!]

  """
  The primary key(s) and patch data for `adminMedicamentDescription` for the far side of the relationship.
  """
  updateByNodeId: [MedicamentOnAdminMedicamentDescriptionForAdminmedicamentdescriptionMedicamentFkNodeIdUpdate!]

  """
  A `AdminMedicamentDescriptionInput` object that will be created and connected to this object.
  """
  create: [AdminmedicamentdescriptionMedicamentFkAdminMedicamentDescriptionCreateInput!]
}

"""
The fields on `adminMedicamentDescription` to look up the row to update.
"""
input AdminMedicamentDescriptionOnAdminMedicamentDescriptionForAdminmedicamentdescriptionMedicamentFkUsingAdminmedicamentdescriptionPkUpdate {
  """
  An object where the defined keys will be set on the `adminMedicamentDescription` being updated.
  """
  patch: updateAdminMedicamentDescriptionOnAdminMedicamentDescriptionForAdminmedicamentdescriptionMedicamentFkPatch!
  id: Int!
}

"""
An object where the defined keys will be set on the `adminMedicamentDescription` being updated.
"""
input updateAdminMedicamentDescriptionOnAdminMedicamentDescriptionForAdminmedicamentdescriptionMedicamentFkPatch {
  id: Int
  adminId: Int
  description: String
  adminToAdminId: AdminmedicamentdescriptionAdminFkInput
  medicamentToMedicamentId: AdminmedicamentdescriptionMedicamentFkInput
}

"""The globally unique `ID` look up for the row to update."""
input MedicamentOnAdminMedicamentDescriptionForAdminmedicamentdescriptionMedicamentFkNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `adminMedicamentDescription` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `adminMedicamentDescription` being updated.
  """
  patch: AdminMedicamentDescriptionPatch!
}

"""
Represents an update to a `AdminMedicamentDescription`. Fields that are set will be updated.
"""
input AdminMedicamentDescriptionPatch {
  id: Int
  adminId: Int
  medicamentId: Int
  description: String
  adminToAdminId: AdminmedicamentdescriptionAdminFkInput
  medicamentToMedicamentId: AdminmedicamentdescriptionMedicamentFkInput
}

"""The `adminMedicamentDescription` to be created by this mutation."""
input AdminmedicamentdescriptionMedicamentFkAdminMedicamentDescriptionCreateInput {
  id: Int
  adminId: Int
  description: String!
  adminToAdminId: AdminmedicamentdescriptionAdminFkInput
  medicamentToMedicamentId: AdminmedicamentdescriptionMedicamentFkInput
}

"""The globally unique `ID` look up for the row to update."""
input AdminMedicamentDescriptionOnAdminMedicamentDescriptionForAdminmedicamentdescriptionMedicamentFkNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `medicament` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `medicament` being updated.
  """
  patch: MedicamentPatch!
}

"""
Represents an update to a `Medicament`. Fields that are set will be updated.
"""
input MedicamentPatch {
  id: Int
  code: String
  title: String
  supplement: String
  strength: String
  packaging: Int
  holderCode: String
  stateCode: String
  atcCode: String
  atcTitleSk: String
  indicationGroup: String
  regNumber: String
  expiration: String
  dispensing: String
  registrationType: String
  regDate: String
  validity: String
  securityFeature: Boolean
  userMedicamentsUsingId: UsermedicamentMedicamentFkInverseInput
  adminMedicamentDescriptionsUsingId: AdminmedicamentdescriptionMedicamentFkInverseInput
}

"""The `medicament` to be created by this mutation."""
input AdminmedicamentdescriptionMedicamentFkMedicamentCreateInput {
  id: Int
  code: String!
  title: String!
  supplement: String
  strength: String
  packaging: Int
  holderCode: String
  stateCode: String
  atcCode: String
  atcTitleSk: String
  indicationGroup: String
  regNumber: String
  expiration: String
  dispensing: String
  registrationType: String
  regDate: String
  validity: String
  securityFeature: Boolean
  userMedicamentsUsingId: UsermedicamentMedicamentFkInverseInput
  adminMedicamentDescriptionsUsingId: AdminmedicamentdescriptionMedicamentFkInverseInput
}

"""The globally unique `ID` look up for the row to update."""
input AdminOnAdminMedicamentDescriptionForAdminmedicamentdescriptionAdminFkNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `adminMedicamentDescription` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `adminMedicamentDescription` being updated.
  """
  patch: AdminMedicamentDescriptionPatch!
}

"""The `adminMedicamentDescription` to be created by this mutation."""
input AdminmedicamentdescriptionAdminFkAdminMedicamentDescriptionCreateInput {
  id: Int
  medicamentId: Int
  description: String!
  adminToAdminId: AdminmedicamentdescriptionAdminFkInput
  medicamentToMedicamentId: AdminmedicamentdescriptionMedicamentFkInput
}

"""The globally unique `ID` look up for the row to update."""
input UserMedicamentOnUserMedicamentForUsermedicamentAdminFkNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `admin` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `admin` being updated.
  """
  patch: AdminPatch!
}

"""The `admin` to be created by this mutation."""
input UsermedicamentAdminFkAdminCreateInput {
  id: Int
  firstName: String!
  lastName: String!
  ambulanceId: Int
  adminVerified: Boolean
  registrationDate: Date
  email: String
  phone: String
  lastLogin: Date
  interval: Int!
  ambulanceToAmbulanceId: AdminAmbulanceFkInput
  meetingsUsingId: MeetingAdminFkInverseInput
  userMedicamentsUsingId: UsermedicamentAdminFkInverseInput
  adminMedicamentDescriptionsUsingId: AdminmedicamentdescriptionAdminFkInverseInput
  meetingHoursUsingId: MeetinghoursAdminFkInverseInput
}

"""
Input for the nested mutation of `userMedicamentDay` in the `UserMedicamentInput` mutation.
"""
input UsermedicamentUsermedicamentdayFkInput {
  """
  The primary key(s) for `userMedicamentDay` for the far side of the relationship.
  """
  connectById: UserMedicamentDayUsermedicamentdaysPkConnect

  """
  The primary key(s) for `userMedicamentDay` for the far side of the relationship.
  """
  connectByNodeId: UserMedicamentDayNodeIdConnect

  """
  The primary key(s) for `userMedicamentDay` for the far side of the relationship.
  """
  deleteById: UserMedicamentDayUsermedicamentdaysPkDelete

  """
  The primary key(s) for `userMedicamentDay` for the far side of the relationship.
  """
  deleteByNodeId: UserMedicamentDayNodeIdDelete

  """
  The primary key(s) and patch data for `userMedicamentDay` for the far side of the relationship.
  """
  updateById: UserMedicamentDayOnUserMedicamentForUsermedicamentUsermedicamentdayFkUsingUsermedicamentdaysPkUpdate

  """
  The primary key(s) and patch data for `userMedicamentDay` for the far side of the relationship.
  """
  updateByNodeId: UserMedicamentOnUserMedicamentForUsermedicamentUsermedicamentdayFkNodeIdUpdate

  """
  A `UserMedicamentDayInput` object that will be created and connected to this object.
  """
  create: UsermedicamentUsermedicamentdayFkUserMedicamentDayCreateInput
}

"""The fields on `userMedicamentDay` to look up the row to update."""
input UserMedicamentDayOnUserMedicamentForUsermedicamentUsermedicamentdayFkUsingUsermedicamentdaysPkUpdate {
  """
  An object where the defined keys will be set on the `userMedicamentDay` being updated.
  """
  patch: updateUserMedicamentDayOnUserMedicamentForUsermedicamentUsermedicamentdayFkPatch!
  id: Int!
}

"""
An object where the defined keys will be set on the `userMedicamentDay` being updated.
"""
input updateUserMedicamentDayOnUserMedicamentForUsermedicamentUsermedicamentdayFkPatch {
  monday: Boolean
  tuesday: Boolean
  wednesday: Boolean
  thursday: Boolean
  friday: Boolean
  saturday: Boolean
  sunday: Boolean
  id: Int
  userId: Int
  userToUserId: UsermedicamentdayUserFkInput
  userMedicamentsUsingId: UsermedicamentUsermedicamentdayFkInverseInput
}

"""
Input for the nested mutation of `userMedicament` in the `UserMedicamentDayInput` mutation.
"""
input UsermedicamentUsermedicamentdayFkInverseInput {
  """
  Flag indicating whether all other `userMedicament` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) for `userMedicament` for the far side of the relationship.
  """
  connectById: [UserMedicamentUsermedicamentPkConnect!]

  """
  The primary key(s) for `userMedicament` for the far side of the relationship.
  """
  connectByNodeId: [UserMedicamentNodeIdConnect!]

  """
  The primary key(s) for `userMedicament` for the far side of the relationship.
  """
  deleteById: [UserMedicamentUsermedicamentPkDelete!]

  """
  The primary key(s) for `userMedicament` for the far side of the relationship.
  """
  deleteByNodeId: [UserMedicamentNodeIdDelete!]

  """
  The primary key(s) and patch data for `userMedicament` for the far side of the relationship.
  """
  updateById: [UserMedicamentOnUserMedicamentForUsermedicamentUsermedicamentdayFkUsingUsermedicamentPkUpdate!]

  """
  The primary key(s) and patch data for `userMedicament` for the far side of the relationship.
  """
  updateByNodeId: [UserMedicamentDayOnUserMedicamentForUsermedicamentUsermedicamentdayFkNodeIdUpdate!]

  """
  A `UserMedicamentInput` object that will be created and connected to this object.
  """
  create: [UsermedicamentUsermedicamentdayFkUserMedicamentCreateInput!]
}

"""The fields on `userMedicament` to look up the row to update."""
input UserMedicamentOnUserMedicamentForUsermedicamentUsermedicamentdayFkUsingUsermedicamentPkUpdate {
  """
  An object where the defined keys will be set on the `userMedicament` being updated.
  """
  patch: updateUserMedicamentOnUserMedicamentForUsermedicamentUsermedicamentdayFkPatch!
  id: Int!
}

"""
An object where the defined keys will be set on the `userMedicament` being updated.
"""
input updateUserMedicamentOnUserMedicamentForUsermedicamentUsermedicamentdayFkPatch {
  id: Int
  userId: Int
  medicamentId: Int
  active: Boolean
  dosing: Int
  createdAt: Date
  nextPrescriptionDate: Date
  adminId: Int
  updatedAt: Date
  interval: Int
  everyXday: Int
  morning: Boolean
  noon: Boolean
  evening: Boolean
  userToUserId: UsermedicamentUserFkInput
  medicamentToMedicamentId: UsermedicamentMedicamentFkInput
  adminToAdminId: UsermedicamentAdminFkInput
  userMedicamentDayToUserMedicamentDayId: UsermedicamentUsermedicamentdayFkInput
  userMedicamentTimesUsingId: UsermedicamenttimeUsermedicamentFkInverseInput
}

"""
Input for the nested mutation of `userMedicamentTime` in the `UserMedicamentInput` mutation.
"""
input UsermedicamenttimeUsermedicamentFkInverseInput {
  """
  Flag indicating whether all other `userMedicamentTime` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) for `userMedicamentTime` for the far side of the relationship.
  """
  connectById: [UserMedicamentTimeUsermedicamenttimesPkConnect!]

  """
  The primary key(s) for `userMedicamentTime` for the far side of the relationship.
  """
  connectByUserMedicamentIdAndTime: [UserMedicamentTimeUserMedicamentTimeUserMedicamentIdTimeKeyConnect!]

  """
  The primary key(s) for `userMedicamentTime` for the far side of the relationship.
  """
  connectByNodeId: [UserMedicamentTimeNodeIdConnect!]

  """
  The primary key(s) for `userMedicamentTime` for the far side of the relationship.
  """
  deleteById: [UserMedicamentTimeUsermedicamenttimesPkDelete!]

  """
  The primary key(s) for `userMedicamentTime` for the far side of the relationship.
  """
  deleteByUserMedicamentIdAndTime: [UserMedicamentTimeUserMedicamentTimeUserMedicamentIdTimeKeyDelete!]

  """
  The primary key(s) for `userMedicamentTime` for the far side of the relationship.
  """
  deleteByNodeId: [UserMedicamentTimeNodeIdDelete!]

  """
  The primary key(s) and patch data for `userMedicamentTime` for the far side of the relationship.
  """
  updateById: [UserMedicamentTimeOnUserMedicamentTimeForUsermedicamenttimeUsermedicamentFkUsingUsermedicamenttimesPkUpdate!]

  """
  The primary key(s) and patch data for `userMedicamentTime` for the far side of the relationship.
  """
  updateByUserMedicamentIdAndTime: [UserMedicamentTimeOnUserMedicamentTimeForUsermedicamenttimeUsermedicamentFkUsingUserMedicamentTimeUserMedicamentIdTimeKeyUpdate!]

  """
  The primary key(s) and patch data for `userMedicamentTime` for the far side of the relationship.
  """
  updateByNodeId: [UserMedicamentOnUserMedicamentTimeForUsermedicamenttimeUsermedicamentFkNodeIdUpdate!]

  """
  A `UserMedicamentTimeInput` object that will be created and connected to this object.
  """
  create: [UsermedicamenttimeUsermedicamentFkUserMedicamentTimeCreateInput!]
}

"""The fields on `userMedicamentTime` to look up the row to connect."""
input UserMedicamentTimeUsermedicamenttimesPkConnect {
  id: Int!
}

"""The fields on `userMedicamentTime` to look up the row to connect."""
input UserMedicamentTimeUserMedicamentTimeUserMedicamentIdTimeKeyConnect {
  userMedicamentId: Int!
  time: Time!
}

"""The globally unique `ID` look up for the row to connect."""
input UserMedicamentTimeNodeIdConnect {
  """
  The globally unique `ID` which identifies a single `userMedicamentTime` to be connected.
  """
  nodeId: ID!
}

"""The fields on `userMedicamentTime` to look up the row to delete."""
input UserMedicamentTimeUsermedicamenttimesPkDelete {
  id: Int!
}

"""The fields on `userMedicamentTime` to look up the row to delete."""
input UserMedicamentTimeUserMedicamentTimeUserMedicamentIdTimeKeyDelete {
  userMedicamentId: Int!
  time: Time!
}

"""The globally unique `ID` look up for the row to delete."""
input UserMedicamentTimeNodeIdDelete {
  """
  The globally unique `ID` which identifies a single `userMedicamentTime` to be deleted.
  """
  nodeId: ID!
}

"""The fields on `userMedicamentTime` to look up the row to update."""
input UserMedicamentTimeOnUserMedicamentTimeForUsermedicamenttimeUsermedicamentFkUsingUsermedicamenttimesPkUpdate {
  """
  An object where the defined keys will be set on the `userMedicamentTime` being updated.
  """
  patch: updateUserMedicamentTimeOnUserMedicamentTimeForUsermedicamenttimeUsermedicamentFkPatch!
  id: Int!
}

"""
An object where the defined keys will be set on the `userMedicamentTime` being updated.
"""
input updateUserMedicamentTimeOnUserMedicamentTimeForUsermedicamenttimeUsermedicamentFkPatch {
  id: Int
  time: Time
  userMedicamentToUserMedicamentId: UsermedicamenttimeUsermedicamentFkInput
}

"""
Input for the nested mutation of `userMedicament` in the `UserMedicamentTimeInput` mutation.
"""
input UsermedicamenttimeUsermedicamentFkInput {
  """
  The primary key(s) for `userMedicament` for the far side of the relationship.
  """
  connectById: UserMedicamentUsermedicamentPkConnect

  """
  The primary key(s) for `userMedicament` for the far side of the relationship.
  """
  connectByNodeId: UserMedicamentNodeIdConnect

  """
  The primary key(s) for `userMedicament` for the far side of the relationship.
  """
  deleteById: UserMedicamentUsermedicamentPkDelete

  """
  The primary key(s) for `userMedicament` for the far side of the relationship.
  """
  deleteByNodeId: UserMedicamentNodeIdDelete

  """
  The primary key(s) and patch data for `userMedicament` for the far side of the relationship.
  """
  updateById: UserMedicamentOnUserMedicamentTimeForUsermedicamenttimeUsermedicamentFkUsingUsermedicamentPkUpdate

  """
  The primary key(s) and patch data for `userMedicament` for the far side of the relationship.
  """
  updateByNodeId: UserMedicamentTimeOnUserMedicamentTimeForUsermedicamenttimeUsermedicamentFkNodeIdUpdate

  """
  A `UserMedicamentInput` object that will be created and connected to this object.
  """
  create: UsermedicamenttimeUsermedicamentFkUserMedicamentCreateInput
}

"""The fields on `userMedicament` to look up the row to update."""
input UserMedicamentOnUserMedicamentTimeForUsermedicamenttimeUsermedicamentFkUsingUsermedicamentPkUpdate {
  """
  An object where the defined keys will be set on the `userMedicament` being updated.
  """
  patch: updateUserMedicamentOnUserMedicamentTimeForUsermedicamenttimeUsermedicamentFkPatch!
  id: Int!
}

"""
An object where the defined keys will be set on the `userMedicament` being updated.
"""
input updateUserMedicamentOnUserMedicamentTimeForUsermedicamenttimeUsermedicamentFkPatch {
  id: Int
  userId: Int
  medicamentId: Int
  active: Boolean
  dosing: Int
  createdAt: Date
  nextPrescriptionDate: Date
  adminId: Int
  updatedAt: Date
  interval: Int
  everyXday: Int
  morning: Boolean
  noon: Boolean
  evening: Boolean
  userMedicamentDayId: Int
  userToUserId: UsermedicamentUserFkInput
  medicamentToMedicamentId: UsermedicamentMedicamentFkInput
  adminToAdminId: UsermedicamentAdminFkInput
  userMedicamentDayToUserMedicamentDayId: UsermedicamentUsermedicamentdayFkInput
  userMedicamentTimesUsingId: UsermedicamenttimeUsermedicamentFkInverseInput
}

"""The globally unique `ID` look up for the row to update."""
input UserMedicamentTimeOnUserMedicamentTimeForUsermedicamenttimeUsermedicamentFkNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `userMedicament` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `userMedicament` being updated.
  """
  patch: UserMedicamentPatch!
}

"""
Represents an update to a `UserMedicament`. Fields that are set will be updated.
"""
input UserMedicamentPatch {
  id: Int
  userId: Int
  medicamentId: Int
  active: Boolean
  dosing: Int
  createdAt: Date
  nextPrescriptionDate: Date
  adminId: Int
  updatedAt: Date
  interval: Int
  everyXday: Int
  morning: Boolean
  noon: Boolean
  evening: Boolean
  userMedicamentDayId: Int
  userToUserId: UsermedicamentUserFkInput
  medicamentToMedicamentId: UsermedicamentMedicamentFkInput
  adminToAdminId: UsermedicamentAdminFkInput
  userMedicamentDayToUserMedicamentDayId: UsermedicamentUsermedicamentdayFkInput
  userMedicamentTimesUsingId: UsermedicamenttimeUsermedicamentFkInverseInput
}

"""The `userMedicament` to be created by this mutation."""
input UsermedicamenttimeUsermedicamentFkUserMedicamentCreateInput {
  id: Int
  userId: Int
  medicamentId: Int
  active: Boolean
  dosing: Int
  createdAt: Date
  nextPrescriptionDate: Date
  adminId: Int
  updatedAt: Date
  interval: Int
  everyXday: Int
  morning: Boolean
  noon: Boolean
  evening: Boolean
  userMedicamentDayId: Int
  userToUserId: UsermedicamentUserFkInput
  medicamentToMedicamentId: UsermedicamentMedicamentFkInput
  adminToAdminId: UsermedicamentAdminFkInput
  userMedicamentDayToUserMedicamentDayId: UsermedicamentUsermedicamentdayFkInput
  userMedicamentTimesUsingId: UsermedicamenttimeUsermedicamentFkInverseInput
}

"""The fields on `userMedicamentTime` to look up the row to update."""
input UserMedicamentTimeOnUserMedicamentTimeForUsermedicamenttimeUsermedicamentFkUsingUserMedicamentTimeUserMedicamentIdTimeKeyUpdate {
  """
  An object where the defined keys will be set on the `userMedicamentTime` being updated.
  """
  patch: updateUserMedicamentTimeOnUserMedicamentTimeForUsermedicamenttimeUsermedicamentFkPatch!
  userMedicamentId: Int!
  time: Time!
}

"""The globally unique `ID` look up for the row to update."""
input UserMedicamentOnUserMedicamentTimeForUsermedicamenttimeUsermedicamentFkNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `userMedicamentTime` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `userMedicamentTime` being updated.
  """
  patch: UserMedicamentTimePatch!
}

"""
Represents an update to a `UserMedicamentTime`. Fields that are set will be updated.
"""
input UserMedicamentTimePatch {
  id: Int
  time: Time
  userMedicamentId: Int
  userMedicamentToUserMedicamentId: UsermedicamenttimeUsermedicamentFkInput
}

"""The `userMedicamentTime` to be created by this mutation."""
input UsermedicamenttimeUsermedicamentFkUserMedicamentTimeCreateInput {
  id: Int
  time: Time!
  userMedicamentToUserMedicamentId: UsermedicamenttimeUsermedicamentFkInput
}

"""The globally unique `ID` look up for the row to update."""
input UserMedicamentDayOnUserMedicamentForUsermedicamentUsermedicamentdayFkNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `userMedicament` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `userMedicament` being updated.
  """
  patch: UserMedicamentPatch!
}

"""The `userMedicament` to be created by this mutation."""
input UsermedicamentUsermedicamentdayFkUserMedicamentCreateInput {
  id: Int
  userId: Int
  medicamentId: Int
  active: Boolean
  dosing: Int
  createdAt: Date
  nextPrescriptionDate: Date
  adminId: Int
  updatedAt: Date
  interval: Int
  everyXday: Int
  morning: Boolean
  noon: Boolean
  evening: Boolean
  userToUserId: UsermedicamentUserFkInput
  medicamentToMedicamentId: UsermedicamentMedicamentFkInput
  adminToAdminId: UsermedicamentAdminFkInput
  userMedicamentDayToUserMedicamentDayId: UsermedicamentUsermedicamentdayFkInput
  userMedicamentTimesUsingId: UsermedicamenttimeUsermedicamentFkInverseInput
}

"""The globally unique `ID` look up for the row to update."""
input UserMedicamentOnUserMedicamentForUsermedicamentUsermedicamentdayFkNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `userMedicamentDay` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `userMedicamentDay` being updated.
  """
  patch: UserMedicamentDayPatch!
}

"""
Represents an update to a `UserMedicamentDay`. Fields that are set will be updated.
"""
input UserMedicamentDayPatch {
  monday: Boolean
  tuesday: Boolean
  wednesday: Boolean
  thursday: Boolean
  friday: Boolean
  saturday: Boolean
  sunday: Boolean
  id: Int
  userId: Int
  userToUserId: UsermedicamentdayUserFkInput
  userMedicamentsUsingId: UsermedicamentUsermedicamentdayFkInverseInput
}

"""The `userMedicamentDay` to be created by this mutation."""
input UsermedicamentUsermedicamentdayFkUserMedicamentDayCreateInput {
  monday: Boolean
  tuesday: Boolean
  wednesday: Boolean
  thursday: Boolean
  friday: Boolean
  saturday: Boolean
  sunday: Boolean
  id: Int
  userId: Int
  userToUserId: UsermedicamentdayUserFkInput
  userMedicamentsUsingId: UsermedicamentUsermedicamentdayFkInverseInput
}

"""The globally unique `ID` look up for the row to update."""
input MedicamentOnUserMedicamentForUsermedicamentMedicamentFkNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `userMedicament` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `userMedicament` being updated.
  """
  patch: UserMedicamentPatch!
}

"""The `userMedicament` to be created by this mutation."""
input UsermedicamentMedicamentFkUserMedicamentCreateInput {
  id: Int
  userId: Int
  active: Boolean
  dosing: Int
  createdAt: Date
  nextPrescriptionDate: Date
  adminId: Int
  updatedAt: Date
  interval: Int
  everyXday: Int
  morning: Boolean
  noon: Boolean
  evening: Boolean
  userMedicamentDayId: Int
  userToUserId: UsermedicamentUserFkInput
  medicamentToMedicamentId: UsermedicamentMedicamentFkInput
  adminToAdminId: UsermedicamentAdminFkInput
  userMedicamentDayToUserMedicamentDayId: UsermedicamentUsermedicamentdayFkInput
  userMedicamentTimesUsingId: UsermedicamenttimeUsermedicamentFkInverseInput
}

"""The globally unique `ID` look up for the row to update."""
input UserMedicamentOnUserMedicamentForUsermedicamentMedicamentFkNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `medicament` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `medicament` being updated.
  """
  patch: MedicamentPatch!
}

"""The `medicament` to be created by this mutation."""
input UsermedicamentMedicamentFkMedicamentCreateInput {
  id: Int
  code: String!
  title: String!
  supplement: String
  strength: String
  packaging: Int
  holderCode: String
  stateCode: String
  atcCode: String
  atcTitleSk: String
  indicationGroup: String
  regNumber: String
  expiration: String
  dispensing: String
  registrationType: String
  regDate: String
  validity: String
  securityFeature: Boolean
  userMedicamentsUsingId: UsermedicamentMedicamentFkInverseInput
  adminMedicamentDescriptionsUsingId: AdminmedicamentdescriptionMedicamentFkInverseInput
}

"""The globally unique `ID` look up for the row to update."""
input UserOnUserMedicamentForUsermedicamentUserFkNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `userMedicament` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `userMedicament` being updated.
  """
  patch: UserMedicamentPatch!
}

"""The `userMedicament` to be created by this mutation."""
input UsermedicamentUserFkUserMedicamentCreateInput {
  id: Int
  medicamentId: Int
  active: Boolean
  dosing: Int
  createdAt: Date
  nextPrescriptionDate: Date
  adminId: Int
  updatedAt: Date
  interval: Int
  everyXday: Int
  morning: Boolean
  noon: Boolean
  evening: Boolean
  userMedicamentDayId: Int
  userToUserId: UsermedicamentUserFkInput
  medicamentToMedicamentId: UsermedicamentMedicamentFkInput
  adminToAdminId: UsermedicamentAdminFkInput
  userMedicamentDayToUserMedicamentDayId: UsermedicamentUsermedicamentdayFkInput
  userMedicamentTimesUsingId: UsermedicamenttimeUsermedicamentFkInverseInput
}

"""The globally unique `ID` look up for the row to update."""
input UserMedicamentDayOnUserMedicamentDayForUsermedicamentdayUserFkNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `user` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `user` being updated.
  """
  patch: UserPatch!
}

"""The `user` to be created by this mutation."""
input UsermedicamentdayUserFkUserCreateInput {
  id: Int
  foreName: String!
  surName: String!
  identNumber: String
  insuranceNumber: String
  email: String
  phone: String
  birthdate: Date
  verified: Boolean
  insuranceCompanyId: Int
  lastLogin: Date
  bloodTypeId: Int
  rhD: Boolean
  registeredAt: Date
  insuranceCompanyToInsuranceCompanyId: UserInsurancecompanyFkInput
  bloodTypeToBloodTypeId: UserBloodtypeFkInput
  meetingsUsingId: MeetingUserFkInverseInput
  userDiagnosesUsingId: UserdiagnosisUserFkInverseInput
  userMedicamentDaysUsingId: UsermedicamentdayUserFkInverseInput
  userMedicamentsUsingId: UsermedicamentUserFkInverseInput
  bloodCountUsersUsingId: BloodcountuserUserFkInverseInput
  ambulanceUsersUsingId: AmbulanceuserUserFkInverseInput
}

"""The globally unique `ID` look up for the row to update."""
input UserOnUserMedicamentDayForUsermedicamentdayUserFkNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `userMedicamentDay` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `userMedicamentDay` being updated.
  """
  patch: UserMedicamentDayPatch!
}

"""The `userMedicamentDay` to be created by this mutation."""
input UsermedicamentdayUserFkUserMedicamentDayCreateInput {
  monday: Boolean
  tuesday: Boolean
  wednesday: Boolean
  thursday: Boolean
  friday: Boolean
  saturday: Boolean
  sunday: Boolean
  id: Int
  userToUserId: UsermedicamentdayUserFkInput
  userMedicamentsUsingId: UsermedicamentUsermedicamentdayFkInverseInput
}

"""The globally unique `ID` look up for the row to update."""
input UserDiagnosisOnUserDiagnosisForUserdiagnosisUserFkNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `user` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `user` being updated.
  """
  patch: UserPatch!
}

"""The `user` to be created by this mutation."""
input UserdiagnosisUserFkUserCreateInput {
  id: Int
  foreName: String!
  surName: String!
  identNumber: String
  insuranceNumber: String
  email: String
  phone: String
  birthdate: Date
  verified: Boolean
  insuranceCompanyId: Int
  lastLogin: Date
  bloodTypeId: Int
  rhD: Boolean
  registeredAt: Date
  insuranceCompanyToInsuranceCompanyId: UserInsurancecompanyFkInput
  bloodTypeToBloodTypeId: UserBloodtypeFkInput
  meetingsUsingId: MeetingUserFkInverseInput
  userDiagnosesUsingId: UserdiagnosisUserFkInverseInput
  userMedicamentDaysUsingId: UsermedicamentdayUserFkInverseInput
  userMedicamentsUsingId: UsermedicamentUserFkInverseInput
  bloodCountUsersUsingId: BloodcountuserUserFkInverseInput
  ambulanceUsersUsingId: AmbulanceuserUserFkInverseInput
}

"""
Input for the nested mutation of `diagnosis` in the `UserDiagnosisInput` mutation.
"""
input UserdiagnosisDiagnosisFkInput {
  """
  The primary key(s) for `diagnosis` for the far side of the relationship.
  """
  connectById: DiagnosisDiagnosisPkConnect

  """
  The primary key(s) for `diagnosis` for the far side of the relationship.
  """
  connectByNodeId: DiagnosisNodeIdConnect

  """
  The primary key(s) for `diagnosis` for the far side of the relationship.
  """
  deleteById: DiagnosisDiagnosisPkDelete

  """
  The primary key(s) for `diagnosis` for the far side of the relationship.
  """
  deleteByNodeId: DiagnosisNodeIdDelete

  """
  The primary key(s) and patch data for `diagnosis` for the far side of the relationship.
  """
  updateById: DiagnosisOnUserDiagnosisForUserdiagnosisDiagnosisFkUsingDiagnosisPkUpdate

  """
  The primary key(s) and patch data for `diagnosis` for the far side of the relationship.
  """
  updateByNodeId: UserDiagnosisOnUserDiagnosisForUserdiagnosisDiagnosisFkNodeIdUpdate

  """
  A `DiagnosisInput` object that will be created and connected to this object.
  """
  create: UserdiagnosisDiagnosisFkDiagnosisCreateInput
}

"""The fields on `diagnosis` to look up the row to connect."""
input DiagnosisDiagnosisPkConnect {
  id: String!
}

"""The globally unique `ID` look up for the row to connect."""
input DiagnosisNodeIdConnect {
  """
  The globally unique `ID` which identifies a single `diagnosis` to be connected.
  """
  nodeId: ID!
}

"""The fields on `diagnosis` to look up the row to delete."""
input DiagnosisDiagnosisPkDelete {
  id: String!
}

"""The globally unique `ID` look up for the row to delete."""
input DiagnosisNodeIdDelete {
  """
  The globally unique `ID` which identifies a single `diagnosis` to be deleted.
  """
  nodeId: ID!
}

"""The fields on `diagnosis` to look up the row to update."""
input DiagnosisOnUserDiagnosisForUserdiagnosisDiagnosisFkUsingDiagnosisPkUpdate {
  """
  An object where the defined keys will be set on the `diagnosis` being updated.
  """
  patch: updateDiagnosisOnUserDiagnosisForUserdiagnosisDiagnosisFkPatch!
  id: String!
}

"""
An object where the defined keys will be set on the `diagnosis` being updated.
"""
input updateDiagnosisOnUserDiagnosisForUserdiagnosisDiagnosisFkPatch {
  id: String
  name: String
  diagnosisCategoryId: String
  diagnosisGroupId: String
  description: String
  diagnosisCategoryToDiagnosisCategoryId: DiagnosisDiagnosiscategoryFkInput
  diagnosisGroupToDiagnosisGroupId: DiagnosisDiagnosisgroupFkInput
  userDiagnosesUsingId: UserdiagnosisDiagnosisFkInverseInput
}

"""
Input for the nested mutation of `diagnosisCategory` in the `DiagnosisInput` mutation.
"""
input DiagnosisDiagnosiscategoryFkInput {
  """
  The primary key(s) for `diagnosisCategory` for the far side of the relationship.
  """
  connectById: DiagnosisCategoryDiagnosissubcategoryPkConnect

  """
  The primary key(s) for `diagnosisCategory` for the far side of the relationship.
  """
  connectByNodeId: DiagnosisCategoryNodeIdConnect

  """
  The primary key(s) for `diagnosisCategory` for the far side of the relationship.
  """
  deleteById: DiagnosisCategoryDiagnosissubcategoryPkDelete

  """
  The primary key(s) for `diagnosisCategory` for the far side of the relationship.
  """
  deleteByNodeId: DiagnosisCategoryNodeIdDelete

  """
  The primary key(s) and patch data for `diagnosisCategory` for the far side of the relationship.
  """
  updateById: DiagnosisCategoryOnDiagnosisForDiagnosisDiagnosiscategoryFkUsingDiagnosissubcategoryPkUpdate

  """
  The primary key(s) and patch data for `diagnosisCategory` for the far side of the relationship.
  """
  updateByNodeId: DiagnosisOnDiagnosisForDiagnosisDiagnosiscategoryFkNodeIdUpdate

  """
  A `DiagnosisCategoryInput` object that will be created and connected to this object.
  """
  create: DiagnosisDiagnosiscategoryFkDiagnosisCategoryCreateInput
}

"""The fields on `diagnosisCategory` to look up the row to connect."""
input DiagnosisCategoryDiagnosissubcategoryPkConnect {
  id: String!
}

"""The globally unique `ID` look up for the row to connect."""
input DiagnosisCategoryNodeIdConnect {
  """
  The globally unique `ID` which identifies a single `diagnosisCategory` to be connected.
  """
  nodeId: ID!
}

"""The fields on `diagnosisCategory` to look up the row to delete."""
input DiagnosisCategoryDiagnosissubcategoryPkDelete {
  id: String!
}

"""The globally unique `ID` look up for the row to delete."""
input DiagnosisCategoryNodeIdDelete {
  """
  The globally unique `ID` which identifies a single `diagnosisCategory` to be deleted.
  """
  nodeId: ID!
}

"""The fields on `diagnosisCategory` to look up the row to update."""
input DiagnosisCategoryOnDiagnosisForDiagnosisDiagnosiscategoryFkUsingDiagnosissubcategoryPkUpdate {
  """
  An object where the defined keys will be set on the `diagnosisCategory` being updated.
  """
  patch: updateDiagnosisCategoryOnDiagnosisForDiagnosisDiagnosiscategoryFkPatch!
  id: String!
}

"""
An object where the defined keys will be set on the `diagnosisCategory` being updated.
"""
input updateDiagnosisCategoryOnDiagnosisForDiagnosisDiagnosiscategoryFkPatch {
  id: String
  name: String
  diagnosisGroupId: String
  description: String
  diagnosisGroupToDiagnosisGroupId: DiagnosiscategoryDiagnosisgroupFkInput
  diagnosesUsingId: DiagnosisDiagnosiscategoryFkInverseInput
}

"""
Input for the nested mutation of `diagnosisGroup` in the `DiagnosisCategoryInput` mutation.
"""
input DiagnosiscategoryDiagnosisgroupFkInput {
  """
  The primary key(s) for `diagnosisGroup` for the far side of the relationship.
  """
  connectById: DiagnosisGroupDiagnosiscategoryPkConnect

  """
  The primary key(s) for `diagnosisGroup` for the far side of the relationship.
  """
  connectByNodeId: DiagnosisGroupNodeIdConnect

  """
  The primary key(s) for `diagnosisGroup` for the far side of the relationship.
  """
  deleteById: DiagnosisGroupDiagnosiscategoryPkDelete

  """
  The primary key(s) for `diagnosisGroup` for the far side of the relationship.
  """
  deleteByNodeId: DiagnosisGroupNodeIdDelete

  """
  The primary key(s) and patch data for `diagnosisGroup` for the far side of the relationship.
  """
  updateById: DiagnosisGroupOnDiagnosisCategoryForDiagnosiscategoryDiagnosisgroupFkUsingDiagnosiscategoryPkUpdate

  """
  The primary key(s) and patch data for `diagnosisGroup` for the far side of the relationship.
  """
  updateByNodeId: DiagnosisCategoryOnDiagnosisCategoryForDiagnosiscategoryDiagnosisgroupFkNodeIdUpdate

  """
  A `DiagnosisGroupInput` object that will be created and connected to this object.
  """
  create: DiagnosiscategoryDiagnosisgroupFkDiagnosisGroupCreateInput
}

"""The fields on `diagnosisGroup` to look up the row to connect."""
input DiagnosisGroupDiagnosiscategoryPkConnect {
  id: String!
}

"""The globally unique `ID` look up for the row to connect."""
input DiagnosisGroupNodeIdConnect {
  """
  The globally unique `ID` which identifies a single `diagnosisGroup` to be connected.
  """
  nodeId: ID!
}

"""The fields on `diagnosisGroup` to look up the row to delete."""
input DiagnosisGroupDiagnosiscategoryPkDelete {
  id: String!
}

"""The globally unique `ID` look up for the row to delete."""
input DiagnosisGroupNodeIdDelete {
  """
  The globally unique `ID` which identifies a single `diagnosisGroup` to be deleted.
  """
  nodeId: ID!
}

"""The fields on `diagnosisGroup` to look up the row to update."""
input DiagnosisGroupOnDiagnosisCategoryForDiagnosiscategoryDiagnosisgroupFkUsingDiagnosiscategoryPkUpdate {
  """
  An object where the defined keys will be set on the `diagnosisGroup` being updated.
  """
  patch: updateDiagnosisGroupOnDiagnosisCategoryForDiagnosiscategoryDiagnosisgroupFkPatch!
  id: String!
}

"""
An object where the defined keys will be set on the `diagnosisGroup` being updated.
"""
input updateDiagnosisGroupOnDiagnosisCategoryForDiagnosiscategoryDiagnosisgroupFkPatch {
  id: String
  name: String
  description: String
  diagnosesUsingId: DiagnosisDiagnosisgroupFkInverseInput
  diagnosisCategoriesUsingId: DiagnosiscategoryDiagnosisgroupFkInverseInput
}

"""
Input for the nested mutation of `diagnosis` in the `DiagnosisGroupInput` mutation.
"""
input DiagnosisDiagnosisgroupFkInverseInput {
  """
  Flag indicating whether all other `diagnosis` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) for `diagnosis` for the far side of the relationship.
  """
  connectById: [DiagnosisDiagnosisPkConnect!]

  """
  The primary key(s) for `diagnosis` for the far side of the relationship.
  """
  connectByNodeId: [DiagnosisNodeIdConnect!]

  """
  The primary key(s) for `diagnosis` for the far side of the relationship.
  """
  deleteById: [DiagnosisDiagnosisPkDelete!]

  """
  The primary key(s) for `diagnosis` for the far side of the relationship.
  """
  deleteByNodeId: [DiagnosisNodeIdDelete!]

  """
  The primary key(s) and patch data for `diagnosis` for the far side of the relationship.
  """
  updateById: [DiagnosisOnDiagnosisForDiagnosisDiagnosisgroupFkUsingDiagnosisPkUpdate!]

  """
  The primary key(s) and patch data for `diagnosis` for the far side of the relationship.
  """
  updateByNodeId: [DiagnosisGroupOnDiagnosisForDiagnosisDiagnosisgroupFkNodeIdUpdate!]

  """
  A `DiagnosisInput` object that will be created and connected to this object.
  """
  create: [DiagnosisDiagnosisgroupFkDiagnosisCreateInput!]
}

"""The fields on `diagnosis` to look up the row to update."""
input DiagnosisOnDiagnosisForDiagnosisDiagnosisgroupFkUsingDiagnosisPkUpdate {
  """
  An object where the defined keys will be set on the `diagnosis` being updated.
  """
  patch: updateDiagnosisOnDiagnosisForDiagnosisDiagnosisgroupFkPatch!
  id: String!
}

"""
An object where the defined keys will be set on the `diagnosis` being updated.
"""
input updateDiagnosisOnDiagnosisForDiagnosisDiagnosisgroupFkPatch {
  id: String
  name: String
  diagnosisCategoryId: String
  description: String
  diagnosisCategoryToDiagnosisCategoryId: DiagnosisDiagnosiscategoryFkInput
  diagnosisGroupToDiagnosisGroupId: DiagnosisDiagnosisgroupFkInput
  userDiagnosesUsingId: UserdiagnosisDiagnosisFkInverseInput
}

"""
Input for the nested mutation of `diagnosisGroup` in the `DiagnosisInput` mutation.
"""
input DiagnosisDiagnosisgroupFkInput {
  """
  The primary key(s) for `diagnosisGroup` for the far side of the relationship.
  """
  connectById: DiagnosisGroupDiagnosiscategoryPkConnect

  """
  The primary key(s) for `diagnosisGroup` for the far side of the relationship.
  """
  connectByNodeId: DiagnosisGroupNodeIdConnect

  """
  The primary key(s) for `diagnosisGroup` for the far side of the relationship.
  """
  deleteById: DiagnosisGroupDiagnosiscategoryPkDelete

  """
  The primary key(s) for `diagnosisGroup` for the far side of the relationship.
  """
  deleteByNodeId: DiagnosisGroupNodeIdDelete

  """
  The primary key(s) and patch data for `diagnosisGroup` for the far side of the relationship.
  """
  updateById: DiagnosisGroupOnDiagnosisForDiagnosisDiagnosisgroupFkUsingDiagnosiscategoryPkUpdate

  """
  The primary key(s) and patch data for `diagnosisGroup` for the far side of the relationship.
  """
  updateByNodeId: DiagnosisOnDiagnosisForDiagnosisDiagnosisgroupFkNodeIdUpdate

  """
  A `DiagnosisGroupInput` object that will be created and connected to this object.
  """
  create: DiagnosisDiagnosisgroupFkDiagnosisGroupCreateInput
}

"""The fields on `diagnosisGroup` to look up the row to update."""
input DiagnosisGroupOnDiagnosisForDiagnosisDiagnosisgroupFkUsingDiagnosiscategoryPkUpdate {
  """
  An object where the defined keys will be set on the `diagnosisGroup` being updated.
  """
  patch: updateDiagnosisGroupOnDiagnosisForDiagnosisDiagnosisgroupFkPatch!
  id: String!
}

"""
An object where the defined keys will be set on the `diagnosisGroup` being updated.
"""
input updateDiagnosisGroupOnDiagnosisForDiagnosisDiagnosisgroupFkPatch {
  id: String
  name: String
  description: String
  diagnosesUsingId: DiagnosisDiagnosisgroupFkInverseInput
  diagnosisCategoriesUsingId: DiagnosiscategoryDiagnosisgroupFkInverseInput
}

"""
Input for the nested mutation of `diagnosisCategory` in the `DiagnosisGroupInput` mutation.
"""
input DiagnosiscategoryDiagnosisgroupFkInverseInput {
  """
  Flag indicating whether all other `diagnosisCategory` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) for `diagnosisCategory` for the far side of the relationship.
  """
  connectById: [DiagnosisCategoryDiagnosissubcategoryPkConnect!]

  """
  The primary key(s) for `diagnosisCategory` for the far side of the relationship.
  """
  connectByNodeId: [DiagnosisCategoryNodeIdConnect!]

  """
  The primary key(s) for `diagnosisCategory` for the far side of the relationship.
  """
  deleteById: [DiagnosisCategoryDiagnosissubcategoryPkDelete!]

  """
  The primary key(s) for `diagnosisCategory` for the far side of the relationship.
  """
  deleteByNodeId: [DiagnosisCategoryNodeIdDelete!]

  """
  The primary key(s) and patch data for `diagnosisCategory` for the far side of the relationship.
  """
  updateById: [DiagnosisCategoryOnDiagnosisCategoryForDiagnosiscategoryDiagnosisgroupFkUsingDiagnosissubcategoryPkUpdate!]

  """
  The primary key(s) and patch data for `diagnosisCategory` for the far side of the relationship.
  """
  updateByNodeId: [DiagnosisGroupOnDiagnosisCategoryForDiagnosiscategoryDiagnosisgroupFkNodeIdUpdate!]

  """
  A `DiagnosisCategoryInput` object that will be created and connected to this object.
  """
  create: [DiagnosiscategoryDiagnosisgroupFkDiagnosisCategoryCreateInput!]
}

"""The fields on `diagnosisCategory` to look up the row to update."""
input DiagnosisCategoryOnDiagnosisCategoryForDiagnosiscategoryDiagnosisgroupFkUsingDiagnosissubcategoryPkUpdate {
  """
  An object where the defined keys will be set on the `diagnosisCategory` being updated.
  """
  patch: updateDiagnosisCategoryOnDiagnosisCategoryForDiagnosiscategoryDiagnosisgroupFkPatch!
  id: String!
}

"""
An object where the defined keys will be set on the `diagnosisCategory` being updated.
"""
input updateDiagnosisCategoryOnDiagnosisCategoryForDiagnosiscategoryDiagnosisgroupFkPatch {
  id: String
  name: String
  description: String
  diagnosisGroupToDiagnosisGroupId: DiagnosiscategoryDiagnosisgroupFkInput
  diagnosesUsingId: DiagnosisDiagnosiscategoryFkInverseInput
}

"""
Input for the nested mutation of `diagnosis` in the `DiagnosisCategoryInput` mutation.
"""
input DiagnosisDiagnosiscategoryFkInverseInput {
  """
  Flag indicating whether all other `diagnosis` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) for `diagnosis` for the far side of the relationship.
  """
  connectById: [DiagnosisDiagnosisPkConnect!]

  """
  The primary key(s) for `diagnosis` for the far side of the relationship.
  """
  connectByNodeId: [DiagnosisNodeIdConnect!]

  """
  The primary key(s) for `diagnosis` for the far side of the relationship.
  """
  deleteById: [DiagnosisDiagnosisPkDelete!]

  """
  The primary key(s) for `diagnosis` for the far side of the relationship.
  """
  deleteByNodeId: [DiagnosisNodeIdDelete!]

  """
  The primary key(s) and patch data for `diagnosis` for the far side of the relationship.
  """
  updateById: [DiagnosisOnDiagnosisForDiagnosisDiagnosiscategoryFkUsingDiagnosisPkUpdate!]

  """
  The primary key(s) and patch data for `diagnosis` for the far side of the relationship.
  """
  updateByNodeId: [DiagnosisCategoryOnDiagnosisForDiagnosisDiagnosiscategoryFkNodeIdUpdate!]

  """
  A `DiagnosisInput` object that will be created and connected to this object.
  """
  create: [DiagnosisDiagnosiscategoryFkDiagnosisCreateInput!]
}

"""The fields on `diagnosis` to look up the row to update."""
input DiagnosisOnDiagnosisForDiagnosisDiagnosiscategoryFkUsingDiagnosisPkUpdate {
  """
  An object where the defined keys will be set on the `diagnosis` being updated.
  """
  patch: updateDiagnosisOnDiagnosisForDiagnosisDiagnosiscategoryFkPatch!
  id: String!
}

"""
An object where the defined keys will be set on the `diagnosis` being updated.
"""
input updateDiagnosisOnDiagnosisForDiagnosisDiagnosiscategoryFkPatch {
  id: String
  name: String
  diagnosisGroupId: String
  description: String
  diagnosisCategoryToDiagnosisCategoryId: DiagnosisDiagnosiscategoryFkInput
  diagnosisGroupToDiagnosisGroupId: DiagnosisDiagnosisgroupFkInput
  userDiagnosesUsingId: UserdiagnosisDiagnosisFkInverseInput
}

"""
Input for the nested mutation of `userDiagnosis` in the `DiagnosisInput` mutation.
"""
input UserdiagnosisDiagnosisFkInverseInput {
  """
  A `UserDiagnosisInput` object that will be created and connected to this object.
  """
  create: [UserdiagnosisDiagnosisFkUserDiagnosisCreateInput!]
}

"""The `userDiagnosis` to be created by this mutation."""
input UserdiagnosisDiagnosisFkUserDiagnosisCreateInput {
  userId: Int
  userToUserId: UserdiagnosisUserFkInput
  diagnosisToDiagnosisId: UserdiagnosisDiagnosisFkInput
}

"""The globally unique `ID` look up for the row to update."""
input DiagnosisCategoryOnDiagnosisForDiagnosisDiagnosiscategoryFkNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `diagnosis` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `diagnosis` being updated.
  """
  patch: DiagnosisPatch!
}

"""
Represents an update to a `Diagnosis`. Fields that are set will be updated.
"""
input DiagnosisPatch {
  id: String
  name: String
  diagnosisCategoryId: String
  diagnosisGroupId: String
  description: String
  diagnosisCategoryToDiagnosisCategoryId: DiagnosisDiagnosiscategoryFkInput
  diagnosisGroupToDiagnosisGroupId: DiagnosisDiagnosisgroupFkInput
  userDiagnosesUsingId: UserdiagnosisDiagnosisFkInverseInput
}

"""The `diagnosis` to be created by this mutation."""
input DiagnosisDiagnosiscategoryFkDiagnosisCreateInput {
  id: String!
  name: String!
  diagnosisGroupId: String
  description: String
  diagnosisCategoryToDiagnosisCategoryId: DiagnosisDiagnosiscategoryFkInput
  diagnosisGroupToDiagnosisGroupId: DiagnosisDiagnosisgroupFkInput
  userDiagnosesUsingId: UserdiagnosisDiagnosisFkInverseInput
}

"""The globally unique `ID` look up for the row to update."""
input DiagnosisGroupOnDiagnosisCategoryForDiagnosiscategoryDiagnosisgroupFkNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `diagnosisCategory` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `diagnosisCategory` being updated.
  """
  patch: DiagnosisCategoryPatch!
}

"""
Represents an update to a `DiagnosisCategory`. Fields that are set will be updated.
"""
input DiagnosisCategoryPatch {
  id: String
  name: String
  diagnosisGroupId: String
  description: String
  diagnosisGroupToDiagnosisGroupId: DiagnosiscategoryDiagnosisgroupFkInput
  diagnosesUsingId: DiagnosisDiagnosiscategoryFkInverseInput
}

"""The `diagnosisCategory` to be created by this mutation."""
input DiagnosiscategoryDiagnosisgroupFkDiagnosisCategoryCreateInput {
  id: String!
  name: String!
  description: String
  diagnosisGroupToDiagnosisGroupId: DiagnosiscategoryDiagnosisgroupFkInput
  diagnosesUsingId: DiagnosisDiagnosiscategoryFkInverseInput
}

"""The globally unique `ID` look up for the row to update."""
input DiagnosisOnDiagnosisForDiagnosisDiagnosisgroupFkNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `diagnosisGroup` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `diagnosisGroup` being updated.
  """
  patch: DiagnosisGroupPatch!
}

"""
Represents an update to a `DiagnosisGroup`. Fields that are set will be updated.
"""
input DiagnosisGroupPatch {
  id: String
  name: String
  description: String
  diagnosesUsingId: DiagnosisDiagnosisgroupFkInverseInput
  diagnosisCategoriesUsingId: DiagnosiscategoryDiagnosisgroupFkInverseInput
}

"""The `diagnosisGroup` to be created by this mutation."""
input DiagnosisDiagnosisgroupFkDiagnosisGroupCreateInput {
  id: String!
  name: String!
  description: String
  diagnosesUsingId: DiagnosisDiagnosisgroupFkInverseInput
  diagnosisCategoriesUsingId: DiagnosiscategoryDiagnosisgroupFkInverseInput
}

"""The globally unique `ID` look up for the row to update."""
input DiagnosisGroupOnDiagnosisForDiagnosisDiagnosisgroupFkNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `diagnosis` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `diagnosis` being updated.
  """
  patch: DiagnosisPatch!
}

"""The `diagnosis` to be created by this mutation."""
input DiagnosisDiagnosisgroupFkDiagnosisCreateInput {
  id: String!
  name: String!
  diagnosisCategoryId: String
  description: String
  diagnosisCategoryToDiagnosisCategoryId: DiagnosisDiagnosiscategoryFkInput
  diagnosisGroupToDiagnosisGroupId: DiagnosisDiagnosisgroupFkInput
  userDiagnosesUsingId: UserdiagnosisDiagnosisFkInverseInput
}

"""The globally unique `ID` look up for the row to update."""
input DiagnosisCategoryOnDiagnosisCategoryForDiagnosiscategoryDiagnosisgroupFkNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `diagnosisGroup` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `diagnosisGroup` being updated.
  """
  patch: DiagnosisGroupPatch!
}

"""The `diagnosisGroup` to be created by this mutation."""
input DiagnosiscategoryDiagnosisgroupFkDiagnosisGroupCreateInput {
  id: String!
  name: String!
  description: String
  diagnosesUsingId: DiagnosisDiagnosisgroupFkInverseInput
  diagnosisCategoriesUsingId: DiagnosiscategoryDiagnosisgroupFkInverseInput
}

"""The globally unique `ID` look up for the row to update."""
input DiagnosisOnDiagnosisForDiagnosisDiagnosiscategoryFkNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `diagnosisCategory` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `diagnosisCategory` being updated.
  """
  patch: DiagnosisCategoryPatch!
}

"""The `diagnosisCategory` to be created by this mutation."""
input DiagnosisDiagnosiscategoryFkDiagnosisCategoryCreateInput {
  id: String!
  name: String!
  diagnosisGroupId: String
  description: String
  diagnosisGroupToDiagnosisGroupId: DiagnosiscategoryDiagnosisgroupFkInput
  diagnosesUsingId: DiagnosisDiagnosiscategoryFkInverseInput
}

"""The globally unique `ID` look up for the row to update."""
input UserDiagnosisOnUserDiagnosisForUserdiagnosisDiagnosisFkNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `diagnosis` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `diagnosis` being updated.
  """
  patch: DiagnosisPatch!
}

"""The `diagnosis` to be created by this mutation."""
input UserdiagnosisDiagnosisFkDiagnosisCreateInput {
  id: String!
  name: String!
  diagnosisCategoryId: String
  diagnosisGroupId: String
  description: String
  diagnosisCategoryToDiagnosisCategoryId: DiagnosisDiagnosiscategoryFkInput
  diagnosisGroupToDiagnosisGroupId: DiagnosisDiagnosisgroupFkInput
  userDiagnosesUsingId: UserdiagnosisDiagnosisFkInverseInput
}

"""The globally unique `ID` look up for the row to update."""
input UserMedicamentOnUserMedicamentForUsermedicamentUserFkNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `user` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `user` being updated.
  """
  patch: UserPatch!
}

"""The `user` to be created by this mutation."""
input UsermedicamentUserFkUserCreateInput {
  id: Int
  foreName: String!
  surName: String!
  identNumber: String
  insuranceNumber: String
  email: String
  phone: String
  birthdate: Date
  verified: Boolean
  insuranceCompanyId: Int
  lastLogin: Date
  bloodTypeId: Int
  rhD: Boolean
  registeredAt: Date
  insuranceCompanyToInsuranceCompanyId: UserInsurancecompanyFkInput
  bloodTypeToBloodTypeId: UserBloodtypeFkInput
  meetingsUsingId: MeetingUserFkInverseInput
  userDiagnosesUsingId: UserdiagnosisUserFkInverseInput
  userMedicamentDaysUsingId: UsermedicamentdayUserFkInverseInput
  userMedicamentsUsingId: UsermedicamentUserFkInverseInput
  bloodCountUsersUsingId: BloodcountuserUserFkInverseInput
  ambulanceUsersUsingId: AmbulanceuserUserFkInverseInput
}

"""The globally unique `ID` look up for the row to update."""
input AdminOnUserMedicamentForUsermedicamentAdminFkNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `userMedicament` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `userMedicament` being updated.
  """
  patch: UserMedicamentPatch!
}

"""The `userMedicament` to be created by this mutation."""
input UsermedicamentAdminFkUserMedicamentCreateInput {
  id: Int
  userId: Int
  medicamentId: Int
  active: Boolean
  dosing: Int
  createdAt: Date
  nextPrescriptionDate: Date
  updatedAt: Date
  interval: Int
  everyXday: Int
  morning: Boolean
  noon: Boolean
  evening: Boolean
  userMedicamentDayId: Int
  userToUserId: UsermedicamentUserFkInput
  medicamentToMedicamentId: UsermedicamentMedicamentFkInput
  adminToAdminId: UsermedicamentAdminFkInput
  userMedicamentDayToUserMedicamentDayId: UsermedicamentUsermedicamentdayFkInput
  userMedicamentTimesUsingId: UsermedicamenttimeUsermedicamentFkInverseInput
}

"""The globally unique `ID` look up for the row to update."""
input MeetingOnMeetingForMeetingAdminFkNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `admin` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `admin` being updated.
  """
  patch: AdminPatch!
}

"""The `admin` to be created by this mutation."""
input MeetingAdminFkAdminCreateInput {
  id: Int
  firstName: String!
  lastName: String!
  ambulanceId: Int
  adminVerified: Boolean
  registrationDate: Date
  email: String
  phone: String
  lastLogin: Date
  interval: Int!
  ambulanceToAmbulanceId: AdminAmbulanceFkInput
  meetingsUsingId: MeetingAdminFkInverseInput
  userMedicamentsUsingId: UsermedicamentAdminFkInverseInput
  adminMedicamentDescriptionsUsingId: AdminmedicamentdescriptionAdminFkInverseInput
  meetingHoursUsingId: MeetinghoursAdminFkInverseInput
}

"""The fields on `meeting` to look up the row to update."""
input MeetingOnMeetingForMeetingUserFkUsingMeetingMeetingDateUserIdAdminIdKeyUpdate {
  """
  An object where the defined keys will be set on the `meeting` being updated.
  """
  patch: updateMeetingOnMeetingForMeetingUserFkPatch!
  meetingDate: Date!
  userId: Int!
  adminId: Int!
}

"""The fields on `meeting` to look up the row to update."""
input MeetingOnMeetingForMeetingUserFkUsingMeetingAdminIdMeetingTimeMeetingDateKeyUpdate {
  """
  An object where the defined keys will be set on the `meeting` being updated.
  """
  patch: updateMeetingOnMeetingForMeetingUserFkPatch!
  adminId: Int!
  meetingTime: Time!
  meetingDate: Date!
}

"""The globally unique `ID` look up for the row to update."""
input UserOnMeetingForMeetingUserFkNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `meeting` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `meeting` being updated.
  """
  patch: MeetingPatch!
}

"""The `meeting` to be created by this mutation."""
input MeetingUserFkMeetingCreateInput {
  id: Int
  meetingDate: Date!
  note: String
  adminId: Int
  meetingTime: Time!
  ambulanceId: Int
  createdAt: Date
  userToUserId: MeetingUserFkInput
  adminToAdminId: MeetingAdminFkInput
  ambulanceToAmbulanceId: MeetingAmbulanceFkInput
  bloodCountUserValuesUsingId: BloodcountuservalueMeetingFkInverseInput
}

"""The globally unique `ID` look up for the row to update."""
input BloodTypeOnUserForUserBloodtypeFkNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `user` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `user` being updated.
  """
  patch: UserPatch!
}

"""The `user` to be created by this mutation."""
input UserBloodtypeFkUserCreateInput {
  id: Int
  foreName: String!
  surName: String!
  identNumber: String
  insuranceNumber: String
  email: String
  phone: String
  birthdate: Date
  verified: Boolean
  insuranceCompanyId: Int
  lastLogin: Date
  rhD: Boolean
  registeredAt: Date
  insuranceCompanyToInsuranceCompanyId: UserInsurancecompanyFkInput
  bloodTypeToBloodTypeId: UserBloodtypeFkInput
  meetingsUsingId: MeetingUserFkInverseInput
  userDiagnosesUsingId: UserdiagnosisUserFkInverseInput
  userMedicamentDaysUsingId: UsermedicamentdayUserFkInverseInput
  userMedicamentsUsingId: UsermedicamentUserFkInverseInput
  bloodCountUsersUsingId: BloodcountuserUserFkInverseInput
  ambulanceUsersUsingId: AmbulanceuserUserFkInverseInput
}

"""The globally unique `ID` look up for the row to update."""
input UserOnUserForUserBloodtypeFkNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `bloodType` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `bloodType` being updated.
  """
  patch: BloodTypePatch!
}

"""
Represents an update to a `BloodType`. Fields that are set will be updated.
"""
input BloodTypePatch {
  id: Int
  name: String
  usersUsingId: UserBloodtypeFkInverseInput
}

"""The `bloodType` to be created by this mutation."""
input UserBloodtypeFkBloodTypeCreateInput {
  id: Int!
  name: String!
  usersUsingId: UserBloodtypeFkInverseInput
}

"""The globally unique `ID` look up for the row to update."""
input InsuranceCompanyOnUserForUserInsurancecompanyFkNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `user` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `user` being updated.
  """
  patch: UserPatch!
}

"""The `user` to be created by this mutation."""
input UserInsurancecompanyFkUserCreateInput {
  id: Int
  foreName: String!
  surName: String!
  identNumber: String
  insuranceNumber: String
  email: String
  phone: String
  birthdate: Date
  verified: Boolean
  lastLogin: Date
  bloodTypeId: Int
  rhD: Boolean
  registeredAt: Date
  insuranceCompanyToInsuranceCompanyId: UserInsurancecompanyFkInput
  bloodTypeToBloodTypeId: UserBloodtypeFkInput
  meetingsUsingId: MeetingUserFkInverseInput
  userDiagnosesUsingId: UserdiagnosisUserFkInverseInput
  userMedicamentDaysUsingId: UsermedicamentdayUserFkInverseInput
  userMedicamentsUsingId: UsermedicamentUserFkInverseInput
  bloodCountUsersUsingId: BloodcountuserUserFkInverseInput
  ambulanceUsersUsingId: AmbulanceuserUserFkInverseInput
}

"""The globally unique `ID` look up for the row to update."""
input UserOnUserForUserInsurancecompanyFkNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `insuranceCompany` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `insuranceCompany` being updated.
  """
  patch: InsuranceCompanyPatch!
}

"""
Represents an update to a `InsuranceCompany`. Fields that are set will be updated.
"""
input InsuranceCompanyPatch {
  id: Int
  name: String
  usersUsingId: UserInsurancecompanyFkInverseInput
}

"""The `insuranceCompany` to be created by this mutation."""
input UserInsurancecompanyFkInsuranceCompanyCreateInput {
  id: Int!
  name: String!
  usersUsingId: UserInsurancecompanyFkInverseInput
}

"""The globally unique `ID` look up for the row to update."""
input MeetingOnMeetingForMeetingUserFkNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `user` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `user` being updated.
  """
  patch: UserPatch!
}

"""The `user` to be created by this mutation."""
input MeetingUserFkUserCreateInput {
  id: Int
  foreName: String!
  surName: String!
  identNumber: String
  insuranceNumber: String
  email: String
  phone: String
  birthdate: Date
  verified: Boolean
  insuranceCompanyId: Int
  lastLogin: Date
  bloodTypeId: Int
  rhD: Boolean
  registeredAt: Date
  insuranceCompanyToInsuranceCompanyId: UserInsurancecompanyFkInput
  bloodTypeToBloodTypeId: UserBloodtypeFkInput
  meetingsUsingId: MeetingUserFkInverseInput
  userDiagnosesUsingId: UserdiagnosisUserFkInverseInput
  userMedicamentDaysUsingId: UsermedicamentdayUserFkInverseInput
  userMedicamentsUsingId: UsermedicamentUserFkInverseInput
  bloodCountUsersUsingId: BloodcountuserUserFkInverseInput
  ambulanceUsersUsingId: AmbulanceuserUserFkInverseInput
}

"""The fields on `meeting` to look up the row to update."""
input MeetingOnMeetingForMeetingAdminFkUsingMeetingMeetingDateUserIdAdminIdKeyUpdate {
  """
  An object where the defined keys will be set on the `meeting` being updated.
  """
  patch: updateMeetingOnMeetingForMeetingAdminFkPatch!
  meetingDate: Date!
  userId: Int!
  adminId: Int!
}

"""The fields on `meeting` to look up the row to update."""
input MeetingOnMeetingForMeetingAdminFkUsingMeetingAdminIdMeetingTimeMeetingDateKeyUpdate {
  """
  An object where the defined keys will be set on the `meeting` being updated.
  """
  patch: updateMeetingOnMeetingForMeetingAdminFkPatch!
  adminId: Int!
  meetingTime: Time!
  meetingDate: Date!
}

"""The globally unique `ID` look up for the row to update."""
input AdminOnMeetingForMeetingAdminFkNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `meeting` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `meeting` being updated.
  """
  patch: MeetingPatch!
}

"""The `meeting` to be created by this mutation."""
input MeetingAdminFkMeetingCreateInput {
  id: Int
  meetingDate: Date!
  note: String
  userId: Int
  meetingTime: Time!
  ambulanceId: Int
  createdAt: Date
  userToUserId: MeetingUserFkInput
  adminToAdminId: MeetingAdminFkInput
  ambulanceToAmbulanceId: MeetingAmbulanceFkInput
  bloodCountUserValuesUsingId: BloodcountuservalueMeetingFkInverseInput
}

"""The globally unique `ID` look up for the row to update."""
input AmbulanceOnAdminForAdminAmbulanceFkNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `admin` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `admin` being updated.
  """
  patch: AdminPatch!
}

"""The `admin` to be created by this mutation."""
input AdminAmbulanceFkAdminCreateInput {
  id: Int
  firstName: String!
  lastName: String!
  adminVerified: Boolean
  registrationDate: Date
  email: String
  phone: String
  lastLogin: Date
  interval: Int!
  ambulanceToAmbulanceId: AdminAmbulanceFkInput
  meetingsUsingId: MeetingAdminFkInverseInput
  userMedicamentsUsingId: UsermedicamentAdminFkInverseInput
  adminMedicamentDescriptionsUsingId: AdminmedicamentdescriptionAdminFkInverseInput
  meetingHoursUsingId: MeetinghoursAdminFkInverseInput
}

"""The globally unique `ID` look up for the row to update."""
input CityOnAmbulanceForAmbulanceCityFkNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `ambulance` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `ambulance` being updated.
  """
  patch: AmbulancePatch!
}

"""The `ambulance` to be created by this mutation."""
input AmbulanceCityFkAmbulanceCreateInput {
  id: Int
  name: String!
  ico: String
  street: String!
  state: String!
  suite: String!
  email: String!
  cityToCityId: AmbulanceCityFkInput
  adminsUsingId: AdminAmbulanceFkInverseInput
  meetingsUsingId: MeetingAmbulanceFkInverseInput
  ambulanceUsersUsingId: AmbulanceuserAmbulanceFkInverseInput
  meetingHoursUsingId: MeetinghoursAmbulanceFkInverseInput
}

"""The globally unique `ID` look up for the row to update."""
input RegionOnCityForCityRegionFkNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `city` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `city` being updated.
  """
  patch: CityPatch!
}

"""Represents an update to a `City`. Fields that are set will be updated."""
input CityPatch {
  id: Int
  name: String
  country: String
  iso: String
  regionId: Int
  type: String
  regionToRegionId: CityRegionFkInput
  ambulancesUsingId: AmbulanceCityFkInverseInput
}

"""The `city` to be created by this mutation."""
input CityRegionFkCityCreateInput {
  id: Int
  name: String
  country: String
  iso: String
  type: String
  regionToRegionId: CityRegionFkInput
  ambulancesUsingId: AmbulanceCityFkInverseInput
}

"""The globally unique `ID` look up for the row to update."""
input CityOnCityForCityRegionFkNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `region` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `region` being updated.
  """
  patch: RegionPatch!
}

"""
Represents an update to a `Region`. Fields that are set will be updated.
"""
input RegionPatch {
  id: Int
  region: String
  citiesUsingId: CityRegionFkInverseInput
}

"""The `region` to be created by this mutation."""
input CityRegionFkRegionCreateInput {
  id: Int
  region: String!
  citiesUsingId: CityRegionFkInverseInput
}

"""The globally unique `ID` look up for the row to update."""
input AmbulanceOnAmbulanceForAmbulanceCityFkNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `city` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `city` being updated.
  """
  patch: CityPatch!
}

"""The `city` to be created by this mutation."""
input AmbulanceCityFkCityCreateInput {
  id: Int
  name: String
  country: String
  iso: String
  regionId: Int
  type: String
  regionToRegionId: CityRegionFkInput
  ambulancesUsingId: AmbulanceCityFkInverseInput
}

"""The globally unique `ID` look up for the row to update."""
input AdminOnAdminForAdminAmbulanceFkNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `ambulance` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `ambulance` being updated.
  """
  patch: AmbulancePatch!
}

"""The `ambulance` to be created by this mutation."""
input AdminAmbulanceFkAmbulanceCreateInput {
  id: Int
  name: String!
  ico: String
  cityId: Int
  street: String!
  state: String!
  suite: String!
  email: String!
  cityToCityId: AmbulanceCityFkInput
  adminsUsingId: AdminAmbulanceFkInverseInput
  meetingsUsingId: MeetingAmbulanceFkInverseInput
  ambulanceUsersUsingId: AmbulanceuserAmbulanceFkInverseInput
  meetingHoursUsingId: MeetinghoursAmbulanceFkInverseInput
}

"""The output of our create `AdminMedicamentDescription` mutation."""
type CreateAdminMedicamentDescriptionPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `AdminMedicamentDescription` that was created by this mutation."""
  adminMedicamentDescription: AdminMedicamentDescription

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """
  Reads a single `Admin` that is related to this `AdminMedicamentDescription`.
  """
  admin: Admin

  """
  Reads a single `Medicament` that is related to this `AdminMedicamentDescription`.
  """
  medicament: Medicament

  """An edge for our `AdminMedicamentDescription`. May be used by Relay 1."""
  adminMedicamentDescriptionEdge(
    """The method to use when ordering `AdminMedicamentDescription`."""
    orderBy: [AdminMedicamentDescriptionsOrderBy!] = [PRIMARY_KEY_ASC]
  ): AdminMedicamentDescriptionsEdge
}

"""All input for the create `AdminMedicamentDescription` mutation."""
input CreateAdminMedicamentDescriptionInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `AdminMedicamentDescription` to be created by this mutation."""
  adminMedicamentDescription: AdminMedicamentDescriptionInput!
}

"""An input for mutations affecting `AdminMedicamentDescription`"""
input AdminMedicamentDescriptionInput {
  id: Int
  adminId: Int
  medicamentId: Int
  description: String!
  adminToAdminId: AdminmedicamentdescriptionAdminFkInput
  medicamentToMedicamentId: AdminmedicamentdescriptionMedicamentFkInput
}

"""The output of our create `Ambulance` mutation."""
type CreateAmbulancePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Ambulance` that was created by this mutation."""
  ambulance: Ambulance

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `City` that is related to this `Ambulance`."""
  city: City

  """An edge for our `Ambulance`. May be used by Relay 1."""
  ambulanceEdge(
    """The method to use when ordering `Ambulance`."""
    orderBy: [AmbulancesOrderBy!] = [PRIMARY_KEY_ASC]
  ): AmbulancesEdge
}

"""All input for the create `Ambulance` mutation."""
input CreateAmbulanceInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Ambulance` to be created by this mutation."""
  ambulance: AmbulanceInput!
}

"""An input for mutations affecting `Ambulance`"""
input AmbulanceInput {
  id: Int
  name: String!
  ico: String
  cityId: Int
  street: String!
  state: String!
  suite: String!
  email: String!
  cityToCityId: AmbulanceCityFkInput
  adminsUsingId: AdminAmbulanceFkInverseInput
  meetingsUsingId: MeetingAmbulanceFkInverseInput
  ambulanceUsersUsingId: AmbulanceuserAmbulanceFkInverseInput
  meetingHoursUsingId: MeetinghoursAmbulanceFkInverseInput
}

"""The output of our create `AmbulanceUser` mutation."""
type CreateAmbulanceUserPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `AmbulanceUser` that was created by this mutation."""
  ambulanceUser: AmbulanceUser

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Ambulance` that is related to this `AmbulanceUser`."""
  ambulance: Ambulance

  """Reads a single `User` that is related to this `AmbulanceUser`."""
  user: User

  """An edge for our `AmbulanceUser`. May be used by Relay 1."""
  ambulanceUserEdge(
    """The method to use when ordering `AmbulanceUser`."""
    orderBy: [AmbulanceUsersOrderBy!] = [PRIMARY_KEY_ASC]
  ): AmbulanceUsersEdge
}

"""All input for the create `AmbulanceUser` mutation."""
input CreateAmbulanceUserInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `AmbulanceUser` to be created by this mutation."""
  ambulanceUser: AmbulanceUserInput!
}

"""An input for mutations affecting `AmbulanceUser`"""
input AmbulanceUserInput {
  id: Int
  ambulanceId: Int
  userId: Int
  ambulanceToAmbulanceId: AmbulanceuserAmbulanceFkInput
  userToUserId: AmbulanceuserUserFkInput
}

"""The output of our create `BloodCount` mutation."""
type CreateBloodCountPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `BloodCount` that was created by this mutation."""
  bloodCount: BloodCount

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `BloodCount`. May be used by Relay 1."""
  bloodCountEdge(
    """The method to use when ordering `BloodCount`."""
    orderBy: [BloodCountsOrderBy!] = [PRIMARY_KEY_ASC]
  ): BloodCountsEdge
}

"""All input for the create `BloodCount` mutation."""
input CreateBloodCountInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `BloodCount` to be created by this mutation."""
  bloodCount: BloodCountInput!
}

"""An input for mutations affecting `BloodCount`"""
input BloodCountInput {
  id: Int
  acronym: String!
  title: String!
  men: BigFloatRangeInput!
  women: BigFloatRangeInput!
  units: String
  source: String!
  description: String
  bloodCountUsersUsingId: BloodcountuserBloodcountFkInverseInput
}

"""The output of our create `BloodCountUser` mutation."""
type CreateBloodCountUserPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `BloodCountUser` that was created by this mutation."""
  bloodCountUser: BloodCountUser

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `User` that is related to this `BloodCountUser`."""
  user: User

  """Reads a single `BloodCount` that is related to this `BloodCountUser`."""
  bloodCount: BloodCount

  """An edge for our `BloodCountUser`. May be used by Relay 1."""
  bloodCountUserEdge(
    """The method to use when ordering `BloodCountUser`."""
    orderBy: [BloodCountUsersOrderBy!] = [PRIMARY_KEY_ASC]
  ): BloodCountUsersEdge
}

"""All input for the create `BloodCountUser` mutation."""
input CreateBloodCountUserInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `BloodCountUser` to be created by this mutation."""
  bloodCountUser: BloodCountUserInput!
}

"""An input for mutations affecting `BloodCountUser`"""
input BloodCountUserInput {
  id: Int
  userId: Int
  bloodCountId: Int
  userToUserId: BloodcountuserUserFkInput
  bloodCountToBloodCountId: BloodcountuserBloodcountFkInput
  bloodCountUserValuesUsingId: BloodcountuservalueBloodcountuserFkInverseInput
}

"""The output of our create `BloodCountUserValue` mutation."""
type CreateBloodCountUserValuePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `BloodCountUserValue` that was created by this mutation."""
  bloodCountUserValue: BloodCountUserValue

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """
  Reads a single `BloodCountUser` that is related to this `BloodCountUserValue`.
  """
  bloodCountUser: BloodCountUser

  """
  Reads a single `Meeting` that is related to this `BloodCountUserValue`.
  """
  meeting: Meeting

  """An edge for our `BloodCountUserValue`. May be used by Relay 1."""
  bloodCountUserValueEdge(
    """The method to use when ordering `BloodCountUserValue`."""
    orderBy: [BloodCountUserValuesOrderBy!] = [PRIMARY_KEY_ASC]
  ): BloodCountUserValuesEdge
}

"""All input for the create `BloodCountUserValue` mutation."""
input CreateBloodCountUserValueInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `BloodCountUserValue` to be created by this mutation."""
  bloodCountUserValue: BloodCountUserValueInput!
}

"""An input for mutations affecting `BloodCountUserValue`"""
input BloodCountUserValueInput {
  id: Int
  bloodCountUserId: Int
  meetingId: Int
  bloodCountValue: Float!
  description: String
  createdAt: Date
  bloodCountUserToBloodCountUserId: BloodcountuservalueBloodcountuserFkInput
  meetingToMeetingId: BloodcountuservalueMeetingFkInput
}

"""The output of our create `BloodType` mutation."""
type CreateBloodTypePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `BloodType` that was created by this mutation."""
  bloodType: BloodType

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `BloodType`. May be used by Relay 1."""
  bloodTypeEdge(
    """The method to use when ordering `BloodType`."""
    orderBy: [BloodTypesOrderBy!] = [PRIMARY_KEY_ASC]
  ): BloodTypesEdge
}

"""All input for the create `BloodType` mutation."""
input CreateBloodTypeInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `BloodType` to be created by this mutation."""
  bloodType: BloodTypeInput!
}

"""An input for mutations affecting `BloodType`"""
input BloodTypeInput {
  id: Int!
  name: String!
  usersUsingId: UserBloodtypeFkInverseInput
}

"""The output of our create `City` mutation."""
type CreateCityPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `City` that was created by this mutation."""
  city: City

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Region` that is related to this `City`."""
  region: Region

  """An edge for our `City`. May be used by Relay 1."""
  cityEdge(
    """The method to use when ordering `City`."""
    orderBy: [CitiesOrderBy!] = [PRIMARY_KEY_ASC]
  ): CitiesEdge
}

"""All input for the create `City` mutation."""
input CreateCityInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `City` to be created by this mutation."""
  city: CityInput!
}

"""An input for mutations affecting `City`"""
input CityInput {
  id: Int
  name: String
  country: String
  iso: String
  regionId: Int
  type: String
  regionToRegionId: CityRegionFkInput
  ambulancesUsingId: AmbulanceCityFkInverseInput
}

"""The output of our create `Diagnosis` mutation."""
type CreateDiagnosisPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Diagnosis` that was created by this mutation."""
  diagnosis: Diagnosis

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """
  Reads a single `DiagnosisCategory` that is related to this `Diagnosis`.
  """
  diagnosisCategory: DiagnosisCategory

  """Reads a single `DiagnosisGroup` that is related to this `Diagnosis`."""
  diagnosisGroup: DiagnosisGroup

  """An edge for our `Diagnosis`. May be used by Relay 1."""
  diagnosisEdge(
    """The method to use when ordering `Diagnosis`."""
    orderBy: [DiagnosesOrderBy!] = [PRIMARY_KEY_ASC]
  ): DiagnosesEdge
}

"""All input for the create `Diagnosis` mutation."""
input CreateDiagnosisInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Diagnosis` to be created by this mutation."""
  diagnosis: DiagnosisInput!
}

"""An input for mutations affecting `Diagnosis`"""
input DiagnosisInput {
  id: String!
  name: String!
  diagnosisCategoryId: String
  diagnosisGroupId: String
  description: String
  diagnosisCategoryToDiagnosisCategoryId: DiagnosisDiagnosiscategoryFkInput
  diagnosisGroupToDiagnosisGroupId: DiagnosisDiagnosisgroupFkInput
  userDiagnosesUsingId: UserdiagnosisDiagnosisFkInverseInput
}

"""The output of our create `DiagnosisCategory` mutation."""
type CreateDiagnosisCategoryPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `DiagnosisCategory` that was created by this mutation."""
  diagnosisCategory: DiagnosisCategory

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """
  Reads a single `DiagnosisGroup` that is related to this `DiagnosisCategory`.
  """
  diagnosisGroup: DiagnosisGroup

  """An edge for our `DiagnosisCategory`. May be used by Relay 1."""
  diagnosisCategoryEdge(
    """The method to use when ordering `DiagnosisCategory`."""
    orderBy: [DiagnosisCategoriesOrderBy!] = [PRIMARY_KEY_ASC]
  ): DiagnosisCategoriesEdge
}

"""All input for the create `DiagnosisCategory` mutation."""
input CreateDiagnosisCategoryInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `DiagnosisCategory` to be created by this mutation."""
  diagnosisCategory: DiagnosisCategoryInput!
}

"""An input for mutations affecting `DiagnosisCategory`"""
input DiagnosisCategoryInput {
  id: String!
  name: String!
  diagnosisGroupId: String
  description: String
  diagnosisGroupToDiagnosisGroupId: DiagnosiscategoryDiagnosisgroupFkInput
  diagnosesUsingId: DiagnosisDiagnosiscategoryFkInverseInput
}

"""The output of our create `DiagnosisGroup` mutation."""
type CreateDiagnosisGroupPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `DiagnosisGroup` that was created by this mutation."""
  diagnosisGroup: DiagnosisGroup

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `DiagnosisGroup`. May be used by Relay 1."""
  diagnosisGroupEdge(
    """The method to use when ordering `DiagnosisGroup`."""
    orderBy: [DiagnosisGroupsOrderBy!] = [PRIMARY_KEY_ASC]
  ): DiagnosisGroupsEdge
}

"""All input for the create `DiagnosisGroup` mutation."""
input CreateDiagnosisGroupInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `DiagnosisGroup` to be created by this mutation."""
  diagnosisGroup: DiagnosisGroupInput!
}

"""An input for mutations affecting `DiagnosisGroup`"""
input DiagnosisGroupInput {
  id: String!
  name: String!
  description: String
  diagnosesUsingId: DiagnosisDiagnosisgroupFkInverseInput
  diagnosisCategoriesUsingId: DiagnosiscategoryDiagnosisgroupFkInverseInput
}

"""The output of our create `InsuranceCompany` mutation."""
type CreateInsuranceCompanyPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `InsuranceCompany` that was created by this mutation."""
  insuranceCompany: InsuranceCompany

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `InsuranceCompany`. May be used by Relay 1."""
  insuranceCompanyEdge(
    """The method to use when ordering `InsuranceCompany`."""
    orderBy: [InsuranceCompaniesOrderBy!] = [PRIMARY_KEY_ASC]
  ): InsuranceCompaniesEdge
}

"""All input for the create `InsuranceCompany` mutation."""
input CreateInsuranceCompanyInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `InsuranceCompany` to be created by this mutation."""
  insuranceCompany: InsuranceCompanyInput!
}

"""An input for mutations affecting `InsuranceCompany`"""
input InsuranceCompanyInput {
  id: Int!
  name: String!
  usersUsingId: UserInsurancecompanyFkInverseInput
}

"""The output of our create `Medicament` mutation."""
type CreateMedicamentPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Medicament` that was created by this mutation."""
  medicament: Medicament

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Medicament`. May be used by Relay 1."""
  medicamentEdge(
    """The method to use when ordering `Medicament`."""
    orderBy: [MedicamentsOrderBy!] = [PRIMARY_KEY_ASC]
  ): MedicamentsEdge
}

"""All input for the create `Medicament` mutation."""
input CreateMedicamentInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Medicament` to be created by this mutation."""
  medicament: MedicamentInput!
}

"""An input for mutations affecting `Medicament`"""
input MedicamentInput {
  id: Int
  code: String!
  title: String!
  supplement: String
  strength: String
  packaging: Int
  holderCode: String
  stateCode: String
  atcCode: String
  atcTitleSk: String
  indicationGroup: String
  regNumber: String
  expiration: String
  dispensing: String
  registrationType: String
  regDate: String
  validity: String
  securityFeature: Boolean
  userMedicamentsUsingId: UsermedicamentMedicamentFkInverseInput
  adminMedicamentDescriptionsUsingId: AdminmedicamentdescriptionMedicamentFkInverseInput
}

"""The output of our create `Meeting` mutation."""
type CreateMeetingPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Meeting` that was created by this mutation."""
  meeting: Meeting

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `User` that is related to this `Meeting`."""
  user: User

  """Reads a single `Admin` that is related to this `Meeting`."""
  admin: Admin

  """Reads a single `Ambulance` that is related to this `Meeting`."""
  ambulance: Ambulance

  """An edge for our `Meeting`. May be used by Relay 1."""
  meetingEdge(
    """The method to use when ordering `Meeting`."""
    orderBy: [MeetingsOrderBy!] = [PRIMARY_KEY_ASC]
  ): MeetingsEdge
}

"""All input for the create `Meeting` mutation."""
input CreateMeetingInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Meeting` to be created by this mutation."""
  meeting: MeetingInput!
}

"""An input for mutations affecting `Meeting`"""
input MeetingInput {
  id: Int
  meetingDate: Date!
  note: String
  userId: Int
  adminId: Int
  meetingTime: Time!
  ambulanceId: Int
  createdAt: Date
  userToUserId: MeetingUserFkInput
  adminToAdminId: MeetingAdminFkInput
  ambulanceToAmbulanceId: MeetingAmbulanceFkInput
  bloodCountUserValuesUsingId: BloodcountuservalueMeetingFkInverseInput
}

"""The output of our create `MeetingHour` mutation."""
type CreateMeetingHourPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `MeetingHour` that was created by this mutation."""
  meetingHour: MeetingHour

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Admin` that is related to this `MeetingHour`."""
  admin: Admin

  """Reads a single `Ambulance` that is related to this `MeetingHour`."""
  ambulance: Ambulance

  """An edge for our `MeetingHour`. May be used by Relay 1."""
  meetingHourEdge(
    """The method to use when ordering `MeetingHour`."""
    orderBy: [MeetingHoursOrderBy!] = [PRIMARY_KEY_ASC]
  ): MeetingHoursEdge
}

"""All input for the create `MeetingHour` mutation."""
input CreateMeetingHourInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `MeetingHour` to be created by this mutation."""
  meetingHour: MeetingHourInput!
}

"""An input for mutations affecting `MeetingHour`"""
input MeetingHourInput {
  id: Int
  adminId: Int
  ambulanceId: Int
  startHours: JSON
  endHours: JSON
  interval: Int
  adminToAdminId: MeetinghoursAdminFkInput
  ambulanceToAmbulanceId: MeetinghoursAmbulanceFkInput
}

"""The output of our create `Ref` mutation."""
type CreateRefPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Ref` that was created by this mutation."""
  ref: Ref

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Ref`. May be used by Relay 1."""
  refEdge(
    """The method to use when ordering `Ref`."""
    orderBy: [RefsOrderBy!] = [PRIMARY_KEY_ASC]
  ): RefsEdge
}

"""All input for the create `Ref` mutation."""
input CreateRefInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Ref` to be created by this mutation."""
  ref: RefInput!
}

"""An input for mutations affecting `Ref`"""
input RefInput {
  name: String
  short: String
  unit: String
  id: Int
  refRangesUsingId: RefrangeRefFkInverseInput
}

"""
Input for the nested mutation of `refRange` in the `RefInput` mutation.
"""
input RefrangeRefFkInverseInput {
  """
  Flag indicating whether all other `refRange` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) for `refRange` for the far side of the relationship.
  """
  connectById: [RefRangeRefrangePkConnect!]

  """
  The primary key(s) for `refRange` for the far side of the relationship.
  """
  connectByNodeId: [RefRangeNodeIdConnect!]

  """
  The primary key(s) for `refRange` for the far side of the relationship.
  """
  deleteById: [RefRangeRefrangePkDelete!]

  """
  The primary key(s) for `refRange` for the far side of the relationship.
  """
  deleteByNodeId: [RefRangeNodeIdDelete!]

  """
  The primary key(s) and patch data for `refRange` for the far side of the relationship.
  """
  updateById: [RefRangeOnRefRangeForRefrangeRefFkUsingRefrangePkUpdate!]

  """
  The primary key(s) and patch data for `refRange` for the far side of the relationship.
  """
  updateByNodeId: [RefOnRefRangeForRefrangeRefFkNodeIdUpdate!]

  """
  A `RefRangeInput` object that will be created and connected to this object.
  """
  create: [RefrangeRefFkRefRangeCreateInput!]
}

"""The fields on `refRange` to look up the row to connect."""
input RefRangeRefrangePkConnect {
  id: Int!
}

"""The globally unique `ID` look up for the row to connect."""
input RefRangeNodeIdConnect {
  """
  The globally unique `ID` which identifies a single `refRange` to be connected.
  """
  nodeId: ID!
}

"""The fields on `refRange` to look up the row to delete."""
input RefRangeRefrangePkDelete {
  id: Int!
}

"""The globally unique `ID` look up for the row to delete."""
input RefRangeNodeIdDelete {
  """
  The globally unique `ID` which identifies a single `refRange` to be deleted.
  """
  nodeId: ID!
}

"""The fields on `refRange` to look up the row to update."""
input RefRangeOnRefRangeForRefrangeRefFkUsingRefrangePkUpdate {
  """
  An object where the defined keys will be set on the `refRange` being updated.
  """
  patch: updateRefRangeOnRefRangeForRefrangeRefFkPatch!
  id: Int!
}

"""
An object where the defined keys will be set on the `refRange` being updated.
"""
input updateRefRangeOnRefRangeForRefrangeRefFkPatch {
  id: Int
  vek: String
  m: String
  z: String
  refToRefId: RefrangeRefFkInput
}

"""
Input for the nested mutation of `ref` in the `RefRangeInput` mutation.
"""
input RefrangeRefFkInput {
  """The primary key(s) for `ref` for the far side of the relationship."""
  connectById: RefRefPkConnect

  """The primary key(s) for `ref` for the far side of the relationship."""
  connectByNodeId: RefNodeIdConnect

  """The primary key(s) for `ref` for the far side of the relationship."""
  deleteById: RefRefPkDelete

  """The primary key(s) for `ref` for the far side of the relationship."""
  deleteByNodeId: RefNodeIdDelete

  """
  The primary key(s) and patch data for `ref` for the far side of the relationship.
  """
  updateById: RefOnRefRangeForRefrangeRefFkUsingRefPkUpdate

  """
  The primary key(s) and patch data for `ref` for the far side of the relationship.
  """
  updateByNodeId: RefRangeOnRefRangeForRefrangeRefFkNodeIdUpdate

  """A `RefInput` object that will be created and connected to this object."""
  create: RefrangeRefFkRefCreateInput
}

"""The fields on `ref` to look up the row to connect."""
input RefRefPkConnect {
  id: Int!
}

"""The globally unique `ID` look up for the row to connect."""
input RefNodeIdConnect {
  """
  The globally unique `ID` which identifies a single `ref` to be connected.
  """
  nodeId: ID!
}

"""The fields on `ref` to look up the row to delete."""
input RefRefPkDelete {
  id: Int!
}

"""The globally unique `ID` look up for the row to delete."""
input RefNodeIdDelete {
  """
  The globally unique `ID` which identifies a single `ref` to be deleted.
  """
  nodeId: ID!
}

"""The fields on `ref` to look up the row to update."""
input RefOnRefRangeForRefrangeRefFkUsingRefPkUpdate {
  """
  An object where the defined keys will be set on the `ref` being updated.
  """
  patch: updateRefOnRefRangeForRefrangeRefFkPatch!
  id: Int!
}

"""
An object where the defined keys will be set on the `ref` being updated.
"""
input updateRefOnRefRangeForRefrangeRefFkPatch {
  name: String
  short: String
  unit: String
  id: Int
  refRangesUsingId: RefrangeRefFkInverseInput
}

"""The globally unique `ID` look up for the row to update."""
input RefRangeOnRefRangeForRefrangeRefFkNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `ref` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `ref` being updated.
  """
  patch: RefPatch!
}

"""Represents an update to a `Ref`. Fields that are set will be updated."""
input RefPatch {
  name: String
  short: String
  unit: String
  id: Int
  refRangesUsingId: RefrangeRefFkInverseInput
}

"""The `ref` to be created by this mutation."""
input RefrangeRefFkRefCreateInput {
  name: String
  short: String
  unit: String
  id: Int
  refRangesUsingId: RefrangeRefFkInverseInput
}

"""The globally unique `ID` look up for the row to update."""
input RefOnRefRangeForRefrangeRefFkNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `refRange` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `refRange` being updated.
  """
  patch: RefRangePatch!
}

"""
Represents an update to a `RefRange`. Fields that are set will be updated.
"""
input RefRangePatch {
  id: Int
  vek: String
  m: String
  z: String
  refId: Int
  refToRefId: RefrangeRefFkInput
}

"""The `refRange` to be created by this mutation."""
input RefrangeRefFkRefRangeCreateInput {
  id: Int
  vek: String
  m: String
  z: String
  refToRefId: RefrangeRefFkInput
}

"""The output of our create `RefRange` mutation."""
type CreateRefRangePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `RefRange` that was created by this mutation."""
  refRange: RefRange

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Ref` that is related to this `RefRange`."""
  ref: Ref

  """An edge for our `RefRange`. May be used by Relay 1."""
  refRangeEdge(
    """The method to use when ordering `RefRange`."""
    orderBy: [RefRangesOrderBy!] = [PRIMARY_KEY_ASC]
  ): RefRangesEdge
}

"""All input for the create `RefRange` mutation."""
input CreateRefRangeInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `RefRange` to be created by this mutation."""
  refRange: RefRangeInput!
}

"""An input for mutations affecting `RefRange`"""
input RefRangeInput {
  id: Int
  vek: String
  m: String
  z: String
  refId: Int
  refToRefId: RefrangeRefFkInput
}

"""The output of our create `Region` mutation."""
type CreateRegionPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Region` that was created by this mutation."""
  region: Region

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Region`. May be used by Relay 1."""
  regionEdge(
    """The method to use when ordering `Region`."""
    orderBy: [RegionsOrderBy!] = [PRIMARY_KEY_ASC]
  ): RegionsEdge
}

"""All input for the create `Region` mutation."""
input CreateRegionInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Region` to be created by this mutation."""
  region: RegionInput!
}

"""An input for mutations affecting `Region`"""
input RegionInput {
  id: Int
  region: String!
  citiesUsingId: CityRegionFkInverseInput
}

"""The output of our create `Specialization` mutation."""
type CreateSpecializationPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Specialization` that was created by this mutation."""
  specialization: Specialization

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Specialization`. May be used by Relay 1."""
  specializationEdge(
    """The method to use when ordering `Specialization`."""
    orderBy: [SpecializationsOrderBy!] = [PRIMARY_KEY_ASC]
  ): SpecializationsEdge
}

"""All input for the create `Specialization` mutation."""
input CreateSpecializationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Specialization` to be created by this mutation."""
  specialization: SpecializationInput!
}

"""An input for mutations affecting `Specialization`"""
input SpecializationInput {
  id: Int
  name: String!
}

"""The output of our create `User` mutation."""
type CreateUserPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `User` that was created by this mutation."""
  user: User

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `InsuranceCompany` that is related to this `User`."""
  insuranceCompany: InsuranceCompany

  """Reads a single `BloodType` that is related to this `User`."""
  bloodType: BloodType

  """An edge for our `User`. May be used by Relay 1."""
  userEdge(
    """The method to use when ordering `User`."""
    orderBy: [UsersOrderBy!] = [PRIMARY_KEY_ASC]
  ): UsersEdge
}

"""All input for the create `User` mutation."""
input CreateUserInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `User` to be created by this mutation."""
  user: UserInput!
}

"""An input for mutations affecting `User`"""
input UserInput {
  id: Int
  foreName: String!
  surName: String!
  identNumber: String
  insuranceNumber: String
  email: String
  phone: String
  birthdate: Date
  verified: Boolean
  insuranceCompanyId: Int
  lastLogin: Date
  bloodTypeId: Int
  rhD: Boolean
  registeredAt: Date
  insuranceCompanyToInsuranceCompanyId: UserInsurancecompanyFkInput
  bloodTypeToBloodTypeId: UserBloodtypeFkInput
  meetingsUsingId: MeetingUserFkInverseInput
  userDiagnosesUsingId: UserdiagnosisUserFkInverseInput
  userMedicamentDaysUsingId: UsermedicamentdayUserFkInverseInput
  userMedicamentsUsingId: UsermedicamentUserFkInverseInput
  bloodCountUsersUsingId: BloodcountuserUserFkInverseInput
  ambulanceUsersUsingId: AmbulanceuserUserFkInverseInput
}

"""The output of our create `UserDiagnosis` mutation."""
type CreateUserDiagnosisPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `UserDiagnosis` that was created by this mutation."""
  userDiagnosis: UserDiagnosis

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `User` that is related to this `UserDiagnosis`."""
  user: User

  """Reads a single `Diagnosis` that is related to this `UserDiagnosis`."""
  diagnosis: Diagnosis

  """An edge for our `UserDiagnosis`. May be used by Relay 1."""
  userDiagnosisEdge(
    """The method to use when ordering `UserDiagnosis`."""
    orderBy: [UserDiagnosesOrderBy!] = [NATURAL]
  ): UserDiagnosesEdge
}

"""All input for the create `UserDiagnosis` mutation."""
input CreateUserDiagnosisInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `UserDiagnosis` to be created by this mutation."""
  userDiagnosis: UserDiagnosisInput!
}

"""An input for mutations affecting `UserDiagnosis`"""
input UserDiagnosisInput {
  userId: Int
  diagnosisId: String
  userToUserId: UserdiagnosisUserFkInput
  diagnosisToDiagnosisId: UserdiagnosisDiagnosisFkInput
}

"""The output of our create `UserMedicament` mutation."""
type CreateUserMedicamentPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `UserMedicament` that was created by this mutation."""
  userMedicament: UserMedicament

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `User` that is related to this `UserMedicament`."""
  user: User

  """Reads a single `Medicament` that is related to this `UserMedicament`."""
  medicament: Medicament

  """Reads a single `Admin` that is related to this `UserMedicament`."""
  admin: Admin

  """
  Reads a single `UserMedicamentDay` that is related to this `UserMedicament`.
  """
  userMedicamentDay: UserMedicamentDay

  """An edge for our `UserMedicament`. May be used by Relay 1."""
  userMedicamentEdge(
    """The method to use when ordering `UserMedicament`."""
    orderBy: [UserMedicamentsOrderBy!] = [PRIMARY_KEY_ASC]
  ): UserMedicamentsEdge
}

"""All input for the create `UserMedicament` mutation."""
input CreateUserMedicamentInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `UserMedicament` to be created by this mutation."""
  userMedicament: UserMedicamentInput!
}

"""An input for mutations affecting `UserMedicament`"""
input UserMedicamentInput {
  id: Int
  userId: Int
  medicamentId: Int
  active: Boolean
  dosing: Int
  createdAt: Date
  nextPrescriptionDate: Date
  adminId: Int
  updatedAt: Date
  interval: Int
  everyXday: Int
  morning: Boolean
  noon: Boolean
  evening: Boolean
  userMedicamentDayId: Int
  userToUserId: UsermedicamentUserFkInput
  medicamentToMedicamentId: UsermedicamentMedicamentFkInput
  adminToAdminId: UsermedicamentAdminFkInput
  userMedicamentDayToUserMedicamentDayId: UsermedicamentUsermedicamentdayFkInput
  userMedicamentTimesUsingId: UsermedicamenttimeUsermedicamentFkInverseInput
}

"""The output of our create `UserMedicamentDay` mutation."""
type CreateUserMedicamentDayPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `UserMedicamentDay` that was created by this mutation."""
  userMedicamentDay: UserMedicamentDay

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `User` that is related to this `UserMedicamentDay`."""
  user: User

  """An edge for our `UserMedicamentDay`. May be used by Relay 1."""
  userMedicamentDayEdge(
    """The method to use when ordering `UserMedicamentDay`."""
    orderBy: [UserMedicamentDaysOrderBy!] = [PRIMARY_KEY_ASC]
  ): UserMedicamentDaysEdge
}

"""All input for the create `UserMedicamentDay` mutation."""
input CreateUserMedicamentDayInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `UserMedicamentDay` to be created by this mutation."""
  userMedicamentDay: UserMedicamentDayInput!
}

"""An input for mutations affecting `UserMedicamentDay`"""
input UserMedicamentDayInput {
  monday: Boolean
  tuesday: Boolean
  wednesday: Boolean
  thursday: Boolean
  friday: Boolean
  saturday: Boolean
  sunday: Boolean
  id: Int
  userId: Int
  userToUserId: UsermedicamentdayUserFkInput
  userMedicamentsUsingId: UsermedicamentUsermedicamentdayFkInverseInput
}

"""The output of our create `UserMedicamentTime` mutation."""
type CreateUserMedicamentTimePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `UserMedicamentTime` that was created by this mutation."""
  userMedicamentTime: UserMedicamentTime

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """
  Reads a single `UserMedicament` that is related to this `UserMedicamentTime`.
  """
  userMedicament: UserMedicament

  """An edge for our `UserMedicamentTime`. May be used by Relay 1."""
  userMedicamentTimeEdge(
    """The method to use when ordering `UserMedicamentTime`."""
    orderBy: [UserMedicamentTimesOrderBy!] = [PRIMARY_KEY_ASC]
  ): UserMedicamentTimesEdge
}

"""All input for the create `UserMedicamentTime` mutation."""
input CreateUserMedicamentTimeInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `UserMedicamentTime` to be created by this mutation."""
  userMedicamentTime: UserMedicamentTimeInput!
}

"""An input for mutations affecting `UserMedicamentTime`"""
input UserMedicamentTimeInput {
  id: Int
  time: Time!
  userMedicamentId: Int
  userMedicamentToUserMedicamentId: UsermedicamenttimeUsermedicamentFkInput
}

"""The output of our update `Admin` mutation."""
type UpdateAdminPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Admin` that was updated by this mutation."""
  admin: Admin

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Ambulance` that is related to this `Admin`."""
  ambulance: Ambulance

  """An edge for our `Admin`. May be used by Relay 1."""
  adminEdge(
    """The method to use when ordering `Admin`."""
    orderBy: [AdminsOrderBy!] = [PRIMARY_KEY_ASC]
  ): AdminsEdge
}

"""All input for the `updateAdminByNodeId` mutation."""
input UpdateAdminByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Admin` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Admin` being updated.
  """
  patch: AdminPatch!
}

"""All input for the `updateAdmin` mutation."""
input UpdateAdminInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Admin` being updated.
  """
  patch: AdminPatch!
  id: Int!
}

"""The output of our update `AdminMedicamentDescription` mutation."""
type UpdateAdminMedicamentDescriptionPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `AdminMedicamentDescription` that was updated by this mutation."""
  adminMedicamentDescription: AdminMedicamentDescription

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """
  Reads a single `Admin` that is related to this `AdminMedicamentDescription`.
  """
  admin: Admin

  """
  Reads a single `Medicament` that is related to this `AdminMedicamentDescription`.
  """
  medicament: Medicament

  """An edge for our `AdminMedicamentDescription`. May be used by Relay 1."""
  adminMedicamentDescriptionEdge(
    """The method to use when ordering `AdminMedicamentDescription`."""
    orderBy: [AdminMedicamentDescriptionsOrderBy!] = [PRIMARY_KEY_ASC]
  ): AdminMedicamentDescriptionsEdge
}

"""All input for the `updateAdminMedicamentDescriptionByNodeId` mutation."""
input UpdateAdminMedicamentDescriptionByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `AdminMedicamentDescription` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `AdminMedicamentDescription` being updated.
  """
  patch: AdminMedicamentDescriptionPatch!
}

"""All input for the `updateAdminMedicamentDescription` mutation."""
input UpdateAdminMedicamentDescriptionInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `AdminMedicamentDescription` being updated.
  """
  patch: AdminMedicamentDescriptionPatch!
  id: Int!
}

"""The output of our update `Ambulance` mutation."""
type UpdateAmbulancePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Ambulance` that was updated by this mutation."""
  ambulance: Ambulance

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `City` that is related to this `Ambulance`."""
  city: City

  """An edge for our `Ambulance`. May be used by Relay 1."""
  ambulanceEdge(
    """The method to use when ordering `Ambulance`."""
    orderBy: [AmbulancesOrderBy!] = [PRIMARY_KEY_ASC]
  ): AmbulancesEdge
}

"""All input for the `updateAmbulanceByNodeId` mutation."""
input UpdateAmbulanceByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Ambulance` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Ambulance` being updated.
  """
  patch: AmbulancePatch!
}

"""All input for the `updateAmbulance` mutation."""
input UpdateAmbulanceInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Ambulance` being updated.
  """
  patch: AmbulancePatch!
  id: Int!
}

"""The output of our update `AmbulanceUser` mutation."""
type UpdateAmbulanceUserPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `AmbulanceUser` that was updated by this mutation."""
  ambulanceUser: AmbulanceUser

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Ambulance` that is related to this `AmbulanceUser`."""
  ambulance: Ambulance

  """Reads a single `User` that is related to this `AmbulanceUser`."""
  user: User

  """An edge for our `AmbulanceUser`. May be used by Relay 1."""
  ambulanceUserEdge(
    """The method to use when ordering `AmbulanceUser`."""
    orderBy: [AmbulanceUsersOrderBy!] = [PRIMARY_KEY_ASC]
  ): AmbulanceUsersEdge
}

"""All input for the `updateAmbulanceUserByNodeId` mutation."""
input UpdateAmbulanceUserByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `AmbulanceUser` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `AmbulanceUser` being updated.
  """
  patch: AmbulanceUserPatch!
}

"""All input for the `updateAmbulanceUser` mutation."""
input UpdateAmbulanceUserInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `AmbulanceUser` being updated.
  """
  patch: AmbulanceUserPatch!
  id: Int!
}

"""
All input for the `updateAmbulanceUserByUserIdAndAmbulanceId` mutation.
"""
input UpdateAmbulanceUserByUserIdAndAmbulanceIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `AmbulanceUser` being updated.
  """
  patch: AmbulanceUserPatch!
  userId: Int!
  ambulanceId: Int!
}

"""The output of our update `BloodCount` mutation."""
type UpdateBloodCountPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `BloodCount` that was updated by this mutation."""
  bloodCount: BloodCount

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `BloodCount`. May be used by Relay 1."""
  bloodCountEdge(
    """The method to use when ordering `BloodCount`."""
    orderBy: [BloodCountsOrderBy!] = [PRIMARY_KEY_ASC]
  ): BloodCountsEdge
}

"""All input for the `updateBloodCountByNodeId` mutation."""
input UpdateBloodCountByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `BloodCount` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `BloodCount` being updated.
  """
  patch: BloodCountPatch!
}

"""All input for the `updateBloodCount` mutation."""
input UpdateBloodCountInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `BloodCount` being updated.
  """
  patch: BloodCountPatch!
  id: Int!
}

"""The output of our update `BloodCountUser` mutation."""
type UpdateBloodCountUserPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `BloodCountUser` that was updated by this mutation."""
  bloodCountUser: BloodCountUser

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `User` that is related to this `BloodCountUser`."""
  user: User

  """Reads a single `BloodCount` that is related to this `BloodCountUser`."""
  bloodCount: BloodCount

  """An edge for our `BloodCountUser`. May be used by Relay 1."""
  bloodCountUserEdge(
    """The method to use when ordering `BloodCountUser`."""
    orderBy: [BloodCountUsersOrderBy!] = [PRIMARY_KEY_ASC]
  ): BloodCountUsersEdge
}

"""All input for the `updateBloodCountUserByNodeId` mutation."""
input UpdateBloodCountUserByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `BloodCountUser` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `BloodCountUser` being updated.
  """
  patch: BloodCountUserPatch!
}

"""All input for the `updateBloodCountUser` mutation."""
input UpdateBloodCountUserInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `BloodCountUser` being updated.
  """
  patch: BloodCountUserPatch!
  id: Int!
}

"""
All input for the `updateBloodCountUserByUserIdAndBloodCountId` mutation.
"""
input UpdateBloodCountUserByUserIdAndBloodCountIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `BloodCountUser` being updated.
  """
  patch: BloodCountUserPatch!
  userId: Int!
  bloodCountId: Int!
}

"""The output of our update `BloodCountUserValue` mutation."""
type UpdateBloodCountUserValuePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `BloodCountUserValue` that was updated by this mutation."""
  bloodCountUserValue: BloodCountUserValue

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """
  Reads a single `BloodCountUser` that is related to this `BloodCountUserValue`.
  """
  bloodCountUser: BloodCountUser

  """
  Reads a single `Meeting` that is related to this `BloodCountUserValue`.
  """
  meeting: Meeting

  """An edge for our `BloodCountUserValue`. May be used by Relay 1."""
  bloodCountUserValueEdge(
    """The method to use when ordering `BloodCountUserValue`."""
    orderBy: [BloodCountUserValuesOrderBy!] = [PRIMARY_KEY_ASC]
  ): BloodCountUserValuesEdge
}

"""All input for the `updateBloodCountUserValueByNodeId` mutation."""
input UpdateBloodCountUserValueByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `BloodCountUserValue` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `BloodCountUserValue` being updated.
  """
  patch: BloodCountUserValuePatch!
}

"""All input for the `updateBloodCountUserValue` mutation."""
input UpdateBloodCountUserValueInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `BloodCountUserValue` being updated.
  """
  patch: BloodCountUserValuePatch!
  id: Int!
}

"""The output of our update `BloodType` mutation."""
type UpdateBloodTypePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `BloodType` that was updated by this mutation."""
  bloodType: BloodType

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `BloodType`. May be used by Relay 1."""
  bloodTypeEdge(
    """The method to use when ordering `BloodType`."""
    orderBy: [BloodTypesOrderBy!] = [PRIMARY_KEY_ASC]
  ): BloodTypesEdge
}

"""All input for the `updateBloodTypeByNodeId` mutation."""
input UpdateBloodTypeByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `BloodType` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `BloodType` being updated.
  """
  patch: BloodTypePatch!
}

"""All input for the `updateBloodType` mutation."""
input UpdateBloodTypeInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `BloodType` being updated.
  """
  patch: BloodTypePatch!
  id: Int!
}

"""The output of our update `City` mutation."""
type UpdateCityPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `City` that was updated by this mutation."""
  city: City

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Region` that is related to this `City`."""
  region: Region

  """An edge for our `City`. May be used by Relay 1."""
  cityEdge(
    """The method to use when ordering `City`."""
    orderBy: [CitiesOrderBy!] = [PRIMARY_KEY_ASC]
  ): CitiesEdge
}

"""All input for the `updateCityByNodeId` mutation."""
input UpdateCityByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `City` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `City` being updated.
  """
  patch: CityPatch!
}

"""All input for the `updateCity` mutation."""
input UpdateCityInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `City` being updated.
  """
  patch: CityPatch!
  id: Int!
}

"""The output of our update `Diagnosis` mutation."""
type UpdateDiagnosisPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Diagnosis` that was updated by this mutation."""
  diagnosis: Diagnosis

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """
  Reads a single `DiagnosisCategory` that is related to this `Diagnosis`.
  """
  diagnosisCategory: DiagnosisCategory

  """Reads a single `DiagnosisGroup` that is related to this `Diagnosis`."""
  diagnosisGroup: DiagnosisGroup

  """An edge for our `Diagnosis`. May be used by Relay 1."""
  diagnosisEdge(
    """The method to use when ordering `Diagnosis`."""
    orderBy: [DiagnosesOrderBy!] = [PRIMARY_KEY_ASC]
  ): DiagnosesEdge
}

"""All input for the `updateDiagnosisByNodeId` mutation."""
input UpdateDiagnosisByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Diagnosis` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Diagnosis` being updated.
  """
  patch: DiagnosisPatch!
}

"""All input for the `updateDiagnosis` mutation."""
input UpdateDiagnosisInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Diagnosis` being updated.
  """
  patch: DiagnosisPatch!
  id: String!
}

"""The output of our update `DiagnosisCategory` mutation."""
type UpdateDiagnosisCategoryPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `DiagnosisCategory` that was updated by this mutation."""
  diagnosisCategory: DiagnosisCategory

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """
  Reads a single `DiagnosisGroup` that is related to this `DiagnosisCategory`.
  """
  diagnosisGroup: DiagnosisGroup

  """An edge for our `DiagnosisCategory`. May be used by Relay 1."""
  diagnosisCategoryEdge(
    """The method to use when ordering `DiagnosisCategory`."""
    orderBy: [DiagnosisCategoriesOrderBy!] = [PRIMARY_KEY_ASC]
  ): DiagnosisCategoriesEdge
}

"""All input for the `updateDiagnosisCategoryByNodeId` mutation."""
input UpdateDiagnosisCategoryByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `DiagnosisCategory` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `DiagnosisCategory` being updated.
  """
  patch: DiagnosisCategoryPatch!
}

"""All input for the `updateDiagnosisCategory` mutation."""
input UpdateDiagnosisCategoryInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `DiagnosisCategory` being updated.
  """
  patch: DiagnosisCategoryPatch!
  id: String!
}

"""The output of our update `DiagnosisGroup` mutation."""
type UpdateDiagnosisGroupPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `DiagnosisGroup` that was updated by this mutation."""
  diagnosisGroup: DiagnosisGroup

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `DiagnosisGroup`. May be used by Relay 1."""
  diagnosisGroupEdge(
    """The method to use when ordering `DiagnosisGroup`."""
    orderBy: [DiagnosisGroupsOrderBy!] = [PRIMARY_KEY_ASC]
  ): DiagnosisGroupsEdge
}

"""All input for the `updateDiagnosisGroupByNodeId` mutation."""
input UpdateDiagnosisGroupByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `DiagnosisGroup` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `DiagnosisGroup` being updated.
  """
  patch: DiagnosisGroupPatch!
}

"""All input for the `updateDiagnosisGroup` mutation."""
input UpdateDiagnosisGroupInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `DiagnosisGroup` being updated.
  """
  patch: DiagnosisGroupPatch!
  id: String!
}

"""The output of our update `InsuranceCompany` mutation."""
type UpdateInsuranceCompanyPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `InsuranceCompany` that was updated by this mutation."""
  insuranceCompany: InsuranceCompany

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `InsuranceCompany`. May be used by Relay 1."""
  insuranceCompanyEdge(
    """The method to use when ordering `InsuranceCompany`."""
    orderBy: [InsuranceCompaniesOrderBy!] = [PRIMARY_KEY_ASC]
  ): InsuranceCompaniesEdge
}

"""All input for the `updateInsuranceCompanyByNodeId` mutation."""
input UpdateInsuranceCompanyByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `InsuranceCompany` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `InsuranceCompany` being updated.
  """
  patch: InsuranceCompanyPatch!
}

"""All input for the `updateInsuranceCompany` mutation."""
input UpdateInsuranceCompanyInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `InsuranceCompany` being updated.
  """
  patch: InsuranceCompanyPatch!
  id: Int!
}

"""The output of our update `Medicament` mutation."""
type UpdateMedicamentPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Medicament` that was updated by this mutation."""
  medicament: Medicament

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Medicament`. May be used by Relay 1."""
  medicamentEdge(
    """The method to use when ordering `Medicament`."""
    orderBy: [MedicamentsOrderBy!] = [PRIMARY_KEY_ASC]
  ): MedicamentsEdge
}

"""All input for the `updateMedicamentByNodeId` mutation."""
input UpdateMedicamentByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Medicament` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Medicament` being updated.
  """
  patch: MedicamentPatch!
}

"""All input for the `updateMedicament` mutation."""
input UpdateMedicamentInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Medicament` being updated.
  """
  patch: MedicamentPatch!
  id: Int!
}

"""The output of our update `Meeting` mutation."""
type UpdateMeetingPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Meeting` that was updated by this mutation."""
  meeting: Meeting

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `User` that is related to this `Meeting`."""
  user: User

  """Reads a single `Admin` that is related to this `Meeting`."""
  admin: Admin

  """Reads a single `Ambulance` that is related to this `Meeting`."""
  ambulance: Ambulance

  """An edge for our `Meeting`. May be used by Relay 1."""
  meetingEdge(
    """The method to use when ordering `Meeting`."""
    orderBy: [MeetingsOrderBy!] = [PRIMARY_KEY_ASC]
  ): MeetingsEdge
}

"""All input for the `updateMeetingByNodeId` mutation."""
input UpdateMeetingByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Meeting` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Meeting` being updated.
  """
  patch: MeetingPatch!
}

"""All input for the `updateMeeting` mutation."""
input UpdateMeetingInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Meeting` being updated.
  """
  patch: MeetingPatch!
  id: Int!
}

"""
All input for the `updateMeetingByMeetingDateAndUserIdAndAdminId` mutation.
"""
input UpdateMeetingByMeetingDateAndUserIdAndAdminIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Meeting` being updated.
  """
  patch: MeetingPatch!
  meetingDate: Date!
  userId: Int!
  adminId: Int!
}

"""
All input for the `updateMeetingByAdminIdAndMeetingTimeAndMeetingDate` mutation.
"""
input UpdateMeetingByAdminIdAndMeetingTimeAndMeetingDateInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Meeting` being updated.
  """
  patch: MeetingPatch!
  adminId: Int!
  meetingTime: Time!
  meetingDate: Date!
}

"""The output of our update `MeetingHour` mutation."""
type UpdateMeetingHourPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `MeetingHour` that was updated by this mutation."""
  meetingHour: MeetingHour

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Admin` that is related to this `MeetingHour`."""
  admin: Admin

  """Reads a single `Ambulance` that is related to this `MeetingHour`."""
  ambulance: Ambulance

  """An edge for our `MeetingHour`. May be used by Relay 1."""
  meetingHourEdge(
    """The method to use when ordering `MeetingHour`."""
    orderBy: [MeetingHoursOrderBy!] = [PRIMARY_KEY_ASC]
  ): MeetingHoursEdge
}

"""All input for the `updateMeetingHourByNodeId` mutation."""
input UpdateMeetingHourByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `MeetingHour` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `MeetingHour` being updated.
  """
  patch: MeetingHourPatch!
}

"""All input for the `updateMeetingHour` mutation."""
input UpdateMeetingHourInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `MeetingHour` being updated.
  """
  patch: MeetingHourPatch!
  id: Int!
}

"""The output of our update `Ref` mutation."""
type UpdateRefPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Ref` that was updated by this mutation."""
  ref: Ref

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Ref`. May be used by Relay 1."""
  refEdge(
    """The method to use when ordering `Ref`."""
    orderBy: [RefsOrderBy!] = [PRIMARY_KEY_ASC]
  ): RefsEdge
}

"""All input for the `updateRefByNodeId` mutation."""
input UpdateRefByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Ref` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Ref` being updated.
  """
  patch: RefPatch!
}

"""All input for the `updateRef` mutation."""
input UpdateRefInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Ref` being updated.
  """
  patch: RefPatch!
  id: Int!
}

"""The output of our update `RefRange` mutation."""
type UpdateRefRangePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `RefRange` that was updated by this mutation."""
  refRange: RefRange

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Ref` that is related to this `RefRange`."""
  ref: Ref

  """An edge for our `RefRange`. May be used by Relay 1."""
  refRangeEdge(
    """The method to use when ordering `RefRange`."""
    orderBy: [RefRangesOrderBy!] = [PRIMARY_KEY_ASC]
  ): RefRangesEdge
}

"""All input for the `updateRefRangeByNodeId` mutation."""
input UpdateRefRangeByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `RefRange` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `RefRange` being updated.
  """
  patch: RefRangePatch!
}

"""All input for the `updateRefRange` mutation."""
input UpdateRefRangeInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `RefRange` being updated.
  """
  patch: RefRangePatch!
  id: Int!
}

"""The output of our update `Region` mutation."""
type UpdateRegionPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Region` that was updated by this mutation."""
  region: Region

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Region`. May be used by Relay 1."""
  regionEdge(
    """The method to use when ordering `Region`."""
    orderBy: [RegionsOrderBy!] = [PRIMARY_KEY_ASC]
  ): RegionsEdge
}

"""All input for the `updateRegionByNodeId` mutation."""
input UpdateRegionByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Region` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Region` being updated.
  """
  patch: RegionPatch!
}

"""All input for the `updateRegion` mutation."""
input UpdateRegionInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Region` being updated.
  """
  patch: RegionPatch!
  id: Int!
}

"""The output of our update `Specialization` mutation."""
type UpdateSpecializationPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Specialization` that was updated by this mutation."""
  specialization: Specialization

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Specialization`. May be used by Relay 1."""
  specializationEdge(
    """The method to use when ordering `Specialization`."""
    orderBy: [SpecializationsOrderBy!] = [PRIMARY_KEY_ASC]
  ): SpecializationsEdge
}

"""All input for the `updateSpecializationByNodeId` mutation."""
input UpdateSpecializationByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Specialization` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Specialization` being updated.
  """
  patch: SpecializationPatch!
}

"""
Represents an update to a `Specialization`. Fields that are set will be updated.
"""
input SpecializationPatch {
  id: Int
  name: String
}

"""All input for the `updateSpecialization` mutation."""
input UpdateSpecializationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Specialization` being updated.
  """
  patch: SpecializationPatch!
  id: Int!
}

"""The output of our update `User` mutation."""
type UpdateUserPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `User` that was updated by this mutation."""
  user: User

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `InsuranceCompany` that is related to this `User`."""
  insuranceCompany: InsuranceCompany

  """Reads a single `BloodType` that is related to this `User`."""
  bloodType: BloodType

  """An edge for our `User`. May be used by Relay 1."""
  userEdge(
    """The method to use when ordering `User`."""
    orderBy: [UsersOrderBy!] = [PRIMARY_KEY_ASC]
  ): UsersEdge
}

"""All input for the `updateUserByNodeId` mutation."""
input UpdateUserByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `User` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `User` being updated.
  """
  patch: UserPatch!
}

"""All input for the `updateUser` mutation."""
input UpdateUserInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `User` being updated.
  """
  patch: UserPatch!
  id: Int!
}

"""The output of our update `UserMedicament` mutation."""
type UpdateUserMedicamentPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `UserMedicament` that was updated by this mutation."""
  userMedicament: UserMedicament

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `User` that is related to this `UserMedicament`."""
  user: User

  """Reads a single `Medicament` that is related to this `UserMedicament`."""
  medicament: Medicament

  """Reads a single `Admin` that is related to this `UserMedicament`."""
  admin: Admin

  """
  Reads a single `UserMedicamentDay` that is related to this `UserMedicament`.
  """
  userMedicamentDay: UserMedicamentDay

  """An edge for our `UserMedicament`. May be used by Relay 1."""
  userMedicamentEdge(
    """The method to use when ordering `UserMedicament`."""
    orderBy: [UserMedicamentsOrderBy!] = [PRIMARY_KEY_ASC]
  ): UserMedicamentsEdge
}

"""All input for the `updateUserMedicamentByNodeId` mutation."""
input UpdateUserMedicamentByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `UserMedicament` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `UserMedicament` being updated.
  """
  patch: UserMedicamentPatch!
}

"""All input for the `updateUserMedicament` mutation."""
input UpdateUserMedicamentInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `UserMedicament` being updated.
  """
  patch: UserMedicamentPatch!
  id: Int!
}

"""The output of our update `UserMedicamentDay` mutation."""
type UpdateUserMedicamentDayPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `UserMedicamentDay` that was updated by this mutation."""
  userMedicamentDay: UserMedicamentDay

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `User` that is related to this `UserMedicamentDay`."""
  user: User

  """An edge for our `UserMedicamentDay`. May be used by Relay 1."""
  userMedicamentDayEdge(
    """The method to use when ordering `UserMedicamentDay`."""
    orderBy: [UserMedicamentDaysOrderBy!] = [PRIMARY_KEY_ASC]
  ): UserMedicamentDaysEdge
}

"""All input for the `updateUserMedicamentDayByNodeId` mutation."""
input UpdateUserMedicamentDayByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `UserMedicamentDay` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `UserMedicamentDay` being updated.
  """
  patch: UserMedicamentDayPatch!
}

"""All input for the `updateUserMedicamentDay` mutation."""
input UpdateUserMedicamentDayInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `UserMedicamentDay` being updated.
  """
  patch: UserMedicamentDayPatch!
  id: Int!
}

"""The output of our update `UserMedicamentTime` mutation."""
type UpdateUserMedicamentTimePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `UserMedicamentTime` that was updated by this mutation."""
  userMedicamentTime: UserMedicamentTime

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """
  Reads a single `UserMedicament` that is related to this `UserMedicamentTime`.
  """
  userMedicament: UserMedicament

  """An edge for our `UserMedicamentTime`. May be used by Relay 1."""
  userMedicamentTimeEdge(
    """The method to use when ordering `UserMedicamentTime`."""
    orderBy: [UserMedicamentTimesOrderBy!] = [PRIMARY_KEY_ASC]
  ): UserMedicamentTimesEdge
}

"""All input for the `updateUserMedicamentTimeByNodeId` mutation."""
input UpdateUserMedicamentTimeByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `UserMedicamentTime` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `UserMedicamentTime` being updated.
  """
  patch: UserMedicamentTimePatch!
}

"""All input for the `updateUserMedicamentTime` mutation."""
input UpdateUserMedicamentTimeInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `UserMedicamentTime` being updated.
  """
  patch: UserMedicamentTimePatch!
  id: Int!
}

"""
All input for the `updateUserMedicamentTimeByUserMedicamentIdAndTime` mutation.
"""
input UpdateUserMedicamentTimeByUserMedicamentIdAndTimeInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `UserMedicamentTime` being updated.
  """
  patch: UserMedicamentTimePatch!
  userMedicamentId: Int!
  time: Time!
}

"""The output of our delete `Admin` mutation."""
type DeleteAdminPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Admin` that was deleted by this mutation."""
  admin: Admin
  deletedAdminNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Ambulance` that is related to this `Admin`."""
  ambulance: Ambulance

  """An edge for our `Admin`. May be used by Relay 1."""
  adminEdge(
    """The method to use when ordering `Admin`."""
    orderBy: [AdminsOrderBy!] = [PRIMARY_KEY_ASC]
  ): AdminsEdge
}

"""All input for the `deleteAdminByNodeId` mutation."""
input DeleteAdminByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Admin` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteAdmin` mutation."""
input DeleteAdminInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: Int!
}

"""The output of our delete `AdminMedicamentDescription` mutation."""
type DeleteAdminMedicamentDescriptionPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `AdminMedicamentDescription` that was deleted by this mutation."""
  adminMedicamentDescription: AdminMedicamentDescription
  deletedAdminMedicamentDescriptionNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """
  Reads a single `Admin` that is related to this `AdminMedicamentDescription`.
  """
  admin: Admin

  """
  Reads a single `Medicament` that is related to this `AdminMedicamentDescription`.
  """
  medicament: Medicament

  """An edge for our `AdminMedicamentDescription`. May be used by Relay 1."""
  adminMedicamentDescriptionEdge(
    """The method to use when ordering `AdminMedicamentDescription`."""
    orderBy: [AdminMedicamentDescriptionsOrderBy!] = [PRIMARY_KEY_ASC]
  ): AdminMedicamentDescriptionsEdge
}

"""All input for the `deleteAdminMedicamentDescriptionByNodeId` mutation."""
input DeleteAdminMedicamentDescriptionByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `AdminMedicamentDescription` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteAdminMedicamentDescription` mutation."""
input DeleteAdminMedicamentDescriptionInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: Int!
}

"""The output of our delete `Ambulance` mutation."""
type DeleteAmbulancePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Ambulance` that was deleted by this mutation."""
  ambulance: Ambulance
  deletedAmbulanceNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `City` that is related to this `Ambulance`."""
  city: City

  """An edge for our `Ambulance`. May be used by Relay 1."""
  ambulanceEdge(
    """The method to use when ordering `Ambulance`."""
    orderBy: [AmbulancesOrderBy!] = [PRIMARY_KEY_ASC]
  ): AmbulancesEdge
}

"""All input for the `deleteAmbulanceByNodeId` mutation."""
input DeleteAmbulanceByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Ambulance` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteAmbulance` mutation."""
input DeleteAmbulanceInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: Int!
}

"""The output of our delete `AmbulanceUser` mutation."""
type DeleteAmbulanceUserPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `AmbulanceUser` that was deleted by this mutation."""
  ambulanceUser: AmbulanceUser
  deletedAmbulanceUserNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Ambulance` that is related to this `AmbulanceUser`."""
  ambulance: Ambulance

  """Reads a single `User` that is related to this `AmbulanceUser`."""
  user: User

  """An edge for our `AmbulanceUser`. May be used by Relay 1."""
  ambulanceUserEdge(
    """The method to use when ordering `AmbulanceUser`."""
    orderBy: [AmbulanceUsersOrderBy!] = [PRIMARY_KEY_ASC]
  ): AmbulanceUsersEdge
}

"""All input for the `deleteAmbulanceUserByNodeId` mutation."""
input DeleteAmbulanceUserByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `AmbulanceUser` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteAmbulanceUser` mutation."""
input DeleteAmbulanceUserInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: Int!
}

"""
All input for the `deleteAmbulanceUserByUserIdAndAmbulanceId` mutation.
"""
input DeleteAmbulanceUserByUserIdAndAmbulanceIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  userId: Int!
  ambulanceId: Int!
}

"""The output of our delete `BloodCount` mutation."""
type DeleteBloodCountPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `BloodCount` that was deleted by this mutation."""
  bloodCount: BloodCount
  deletedBloodCountNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `BloodCount`. May be used by Relay 1."""
  bloodCountEdge(
    """The method to use when ordering `BloodCount`."""
    orderBy: [BloodCountsOrderBy!] = [PRIMARY_KEY_ASC]
  ): BloodCountsEdge
}

"""All input for the `deleteBloodCountByNodeId` mutation."""
input DeleteBloodCountByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `BloodCount` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteBloodCount` mutation."""
input DeleteBloodCountInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: Int!
}

"""The output of our delete `BloodCountUser` mutation."""
type DeleteBloodCountUserPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `BloodCountUser` that was deleted by this mutation."""
  bloodCountUser: BloodCountUser
  deletedBloodCountUserNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `User` that is related to this `BloodCountUser`."""
  user: User

  """Reads a single `BloodCount` that is related to this `BloodCountUser`."""
  bloodCount: BloodCount

  """An edge for our `BloodCountUser`. May be used by Relay 1."""
  bloodCountUserEdge(
    """The method to use when ordering `BloodCountUser`."""
    orderBy: [BloodCountUsersOrderBy!] = [PRIMARY_KEY_ASC]
  ): BloodCountUsersEdge
}

"""All input for the `deleteBloodCountUserByNodeId` mutation."""
input DeleteBloodCountUserByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `BloodCountUser` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteBloodCountUser` mutation."""
input DeleteBloodCountUserInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: Int!
}

"""
All input for the `deleteBloodCountUserByUserIdAndBloodCountId` mutation.
"""
input DeleteBloodCountUserByUserIdAndBloodCountIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  userId: Int!
  bloodCountId: Int!
}

"""The output of our delete `BloodCountUserValue` mutation."""
type DeleteBloodCountUserValuePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `BloodCountUserValue` that was deleted by this mutation."""
  bloodCountUserValue: BloodCountUserValue
  deletedBloodCountUserValueNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """
  Reads a single `BloodCountUser` that is related to this `BloodCountUserValue`.
  """
  bloodCountUser: BloodCountUser

  """
  Reads a single `Meeting` that is related to this `BloodCountUserValue`.
  """
  meeting: Meeting

  """An edge for our `BloodCountUserValue`. May be used by Relay 1."""
  bloodCountUserValueEdge(
    """The method to use when ordering `BloodCountUserValue`."""
    orderBy: [BloodCountUserValuesOrderBy!] = [PRIMARY_KEY_ASC]
  ): BloodCountUserValuesEdge
}

"""All input for the `deleteBloodCountUserValueByNodeId` mutation."""
input DeleteBloodCountUserValueByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `BloodCountUserValue` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteBloodCountUserValue` mutation."""
input DeleteBloodCountUserValueInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: Int!
}

"""The output of our delete `BloodType` mutation."""
type DeleteBloodTypePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `BloodType` that was deleted by this mutation."""
  bloodType: BloodType
  deletedBloodTypeNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `BloodType`. May be used by Relay 1."""
  bloodTypeEdge(
    """The method to use when ordering `BloodType`."""
    orderBy: [BloodTypesOrderBy!] = [PRIMARY_KEY_ASC]
  ): BloodTypesEdge
}

"""All input for the `deleteBloodTypeByNodeId` mutation."""
input DeleteBloodTypeByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `BloodType` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteBloodType` mutation."""
input DeleteBloodTypeInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: Int!
}

"""The output of our delete `City` mutation."""
type DeleteCityPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `City` that was deleted by this mutation."""
  city: City
  deletedCityNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Region` that is related to this `City`."""
  region: Region

  """An edge for our `City`. May be used by Relay 1."""
  cityEdge(
    """The method to use when ordering `City`."""
    orderBy: [CitiesOrderBy!] = [PRIMARY_KEY_ASC]
  ): CitiesEdge
}

"""All input for the `deleteCityByNodeId` mutation."""
input DeleteCityByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `City` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteCity` mutation."""
input DeleteCityInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: Int!
}

"""The output of our delete `Diagnosis` mutation."""
type DeleteDiagnosisPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Diagnosis` that was deleted by this mutation."""
  diagnosis: Diagnosis
  deletedDiagnosisNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """
  Reads a single `DiagnosisCategory` that is related to this `Diagnosis`.
  """
  diagnosisCategory: DiagnosisCategory

  """Reads a single `DiagnosisGroup` that is related to this `Diagnosis`."""
  diagnosisGroup: DiagnosisGroup

  """An edge for our `Diagnosis`. May be used by Relay 1."""
  diagnosisEdge(
    """The method to use when ordering `Diagnosis`."""
    orderBy: [DiagnosesOrderBy!] = [PRIMARY_KEY_ASC]
  ): DiagnosesEdge
}

"""All input for the `deleteDiagnosisByNodeId` mutation."""
input DeleteDiagnosisByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Diagnosis` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteDiagnosis` mutation."""
input DeleteDiagnosisInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: String!
}

"""The output of our delete `DiagnosisCategory` mutation."""
type DeleteDiagnosisCategoryPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `DiagnosisCategory` that was deleted by this mutation."""
  diagnosisCategory: DiagnosisCategory
  deletedDiagnosisCategoryNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """
  Reads a single `DiagnosisGroup` that is related to this `DiagnosisCategory`.
  """
  diagnosisGroup: DiagnosisGroup

  """An edge for our `DiagnosisCategory`. May be used by Relay 1."""
  diagnosisCategoryEdge(
    """The method to use when ordering `DiagnosisCategory`."""
    orderBy: [DiagnosisCategoriesOrderBy!] = [PRIMARY_KEY_ASC]
  ): DiagnosisCategoriesEdge
}

"""All input for the `deleteDiagnosisCategoryByNodeId` mutation."""
input DeleteDiagnosisCategoryByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `DiagnosisCategory` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteDiagnosisCategory` mutation."""
input DeleteDiagnosisCategoryInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: String!
}

"""The output of our delete `DiagnosisGroup` mutation."""
type DeleteDiagnosisGroupPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `DiagnosisGroup` that was deleted by this mutation."""
  diagnosisGroup: DiagnosisGroup
  deletedDiagnosisGroupNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `DiagnosisGroup`. May be used by Relay 1."""
  diagnosisGroupEdge(
    """The method to use when ordering `DiagnosisGroup`."""
    orderBy: [DiagnosisGroupsOrderBy!] = [PRIMARY_KEY_ASC]
  ): DiagnosisGroupsEdge
}

"""All input for the `deleteDiagnosisGroupByNodeId` mutation."""
input DeleteDiagnosisGroupByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `DiagnosisGroup` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteDiagnosisGroup` mutation."""
input DeleteDiagnosisGroupInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: String!
}

"""The output of our delete `InsuranceCompany` mutation."""
type DeleteInsuranceCompanyPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `InsuranceCompany` that was deleted by this mutation."""
  insuranceCompany: InsuranceCompany
  deletedInsuranceCompanyNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `InsuranceCompany`. May be used by Relay 1."""
  insuranceCompanyEdge(
    """The method to use when ordering `InsuranceCompany`."""
    orderBy: [InsuranceCompaniesOrderBy!] = [PRIMARY_KEY_ASC]
  ): InsuranceCompaniesEdge
}

"""All input for the `deleteInsuranceCompanyByNodeId` mutation."""
input DeleteInsuranceCompanyByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `InsuranceCompany` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteInsuranceCompany` mutation."""
input DeleteInsuranceCompanyInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: Int!
}

"""The output of our delete `Medicament` mutation."""
type DeleteMedicamentPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Medicament` that was deleted by this mutation."""
  medicament: Medicament
  deletedMedicamentNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Medicament`. May be used by Relay 1."""
  medicamentEdge(
    """The method to use when ordering `Medicament`."""
    orderBy: [MedicamentsOrderBy!] = [PRIMARY_KEY_ASC]
  ): MedicamentsEdge
}

"""All input for the `deleteMedicamentByNodeId` mutation."""
input DeleteMedicamentByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Medicament` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteMedicament` mutation."""
input DeleteMedicamentInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: Int!
}

"""The output of our delete `Meeting` mutation."""
type DeleteMeetingPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Meeting` that was deleted by this mutation."""
  meeting: Meeting
  deletedMeetingNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `User` that is related to this `Meeting`."""
  user: User

  """Reads a single `Admin` that is related to this `Meeting`."""
  admin: Admin

  """Reads a single `Ambulance` that is related to this `Meeting`."""
  ambulance: Ambulance

  """An edge for our `Meeting`. May be used by Relay 1."""
  meetingEdge(
    """The method to use when ordering `Meeting`."""
    orderBy: [MeetingsOrderBy!] = [PRIMARY_KEY_ASC]
  ): MeetingsEdge
}

"""All input for the `deleteMeetingByNodeId` mutation."""
input DeleteMeetingByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Meeting` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteMeeting` mutation."""
input DeleteMeetingInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: Int!
}

"""
All input for the `deleteMeetingByMeetingDateAndUserIdAndAdminId` mutation.
"""
input DeleteMeetingByMeetingDateAndUserIdAndAdminIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  meetingDate: Date!
  userId: Int!
  adminId: Int!
}

"""
All input for the `deleteMeetingByAdminIdAndMeetingTimeAndMeetingDate` mutation.
"""
input DeleteMeetingByAdminIdAndMeetingTimeAndMeetingDateInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  adminId: Int!
  meetingTime: Time!
  meetingDate: Date!
}

"""The output of our delete `MeetingHour` mutation."""
type DeleteMeetingHourPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `MeetingHour` that was deleted by this mutation."""
  meetingHour: MeetingHour
  deletedMeetingHourNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Admin` that is related to this `MeetingHour`."""
  admin: Admin

  """Reads a single `Ambulance` that is related to this `MeetingHour`."""
  ambulance: Ambulance

  """An edge for our `MeetingHour`. May be used by Relay 1."""
  meetingHourEdge(
    """The method to use when ordering `MeetingHour`."""
    orderBy: [MeetingHoursOrderBy!] = [PRIMARY_KEY_ASC]
  ): MeetingHoursEdge
}

"""All input for the `deleteMeetingHourByNodeId` mutation."""
input DeleteMeetingHourByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `MeetingHour` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteMeetingHour` mutation."""
input DeleteMeetingHourInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: Int!
}

"""The output of our delete `Ref` mutation."""
type DeleteRefPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Ref` that was deleted by this mutation."""
  ref: Ref
  deletedRefNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Ref`. May be used by Relay 1."""
  refEdge(
    """The method to use when ordering `Ref`."""
    orderBy: [RefsOrderBy!] = [PRIMARY_KEY_ASC]
  ): RefsEdge
}

"""All input for the `deleteRefByNodeId` mutation."""
input DeleteRefByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Ref` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteRef` mutation."""
input DeleteRefInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: Int!
}

"""The output of our delete `RefRange` mutation."""
type DeleteRefRangePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `RefRange` that was deleted by this mutation."""
  refRange: RefRange
  deletedRefRangeNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Ref` that is related to this `RefRange`."""
  ref: Ref

  """An edge for our `RefRange`. May be used by Relay 1."""
  refRangeEdge(
    """The method to use when ordering `RefRange`."""
    orderBy: [RefRangesOrderBy!] = [PRIMARY_KEY_ASC]
  ): RefRangesEdge
}

"""All input for the `deleteRefRangeByNodeId` mutation."""
input DeleteRefRangeByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `RefRange` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteRefRange` mutation."""
input DeleteRefRangeInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: Int!
}

"""The output of our delete `Region` mutation."""
type DeleteRegionPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Region` that was deleted by this mutation."""
  region: Region
  deletedRegionNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Region`. May be used by Relay 1."""
  regionEdge(
    """The method to use when ordering `Region`."""
    orderBy: [RegionsOrderBy!] = [PRIMARY_KEY_ASC]
  ): RegionsEdge
}

"""All input for the `deleteRegionByNodeId` mutation."""
input DeleteRegionByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Region` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteRegion` mutation."""
input DeleteRegionInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: Int!
}

"""The output of our delete `Specialization` mutation."""
type DeleteSpecializationPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Specialization` that was deleted by this mutation."""
  specialization: Specialization
  deletedSpecializationNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Specialization`. May be used by Relay 1."""
  specializationEdge(
    """The method to use when ordering `Specialization`."""
    orderBy: [SpecializationsOrderBy!] = [PRIMARY_KEY_ASC]
  ): SpecializationsEdge
}

"""All input for the `deleteSpecializationByNodeId` mutation."""
input DeleteSpecializationByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Specialization` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteSpecialization` mutation."""
input DeleteSpecializationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: Int!
}

"""The output of our delete `User` mutation."""
type DeleteUserPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `User` that was deleted by this mutation."""
  user: User
  deletedUserNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `InsuranceCompany` that is related to this `User`."""
  insuranceCompany: InsuranceCompany

  """Reads a single `BloodType` that is related to this `User`."""
  bloodType: BloodType

  """An edge for our `User`. May be used by Relay 1."""
  userEdge(
    """The method to use when ordering `User`."""
    orderBy: [UsersOrderBy!] = [PRIMARY_KEY_ASC]
  ): UsersEdge
}

"""All input for the `deleteUserByNodeId` mutation."""
input DeleteUserByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `User` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteUser` mutation."""
input DeleteUserInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: Int!
}

"""The output of our delete `UserMedicament` mutation."""
type DeleteUserMedicamentPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `UserMedicament` that was deleted by this mutation."""
  userMedicament: UserMedicament
  deletedUserMedicamentNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `User` that is related to this `UserMedicament`."""
  user: User

  """Reads a single `Medicament` that is related to this `UserMedicament`."""
  medicament: Medicament

  """Reads a single `Admin` that is related to this `UserMedicament`."""
  admin: Admin

  """
  Reads a single `UserMedicamentDay` that is related to this `UserMedicament`.
  """
  userMedicamentDay: UserMedicamentDay

  """An edge for our `UserMedicament`. May be used by Relay 1."""
  userMedicamentEdge(
    """The method to use when ordering `UserMedicament`."""
    orderBy: [UserMedicamentsOrderBy!] = [PRIMARY_KEY_ASC]
  ): UserMedicamentsEdge
}

"""All input for the `deleteUserMedicamentByNodeId` mutation."""
input DeleteUserMedicamentByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `UserMedicament` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteUserMedicament` mutation."""
input DeleteUserMedicamentInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: Int!
}

"""The output of our delete `UserMedicamentDay` mutation."""
type DeleteUserMedicamentDayPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `UserMedicamentDay` that was deleted by this mutation."""
  userMedicamentDay: UserMedicamentDay
  deletedUserMedicamentDayNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `User` that is related to this `UserMedicamentDay`."""
  user: User

  """An edge for our `UserMedicamentDay`. May be used by Relay 1."""
  userMedicamentDayEdge(
    """The method to use when ordering `UserMedicamentDay`."""
    orderBy: [UserMedicamentDaysOrderBy!] = [PRIMARY_KEY_ASC]
  ): UserMedicamentDaysEdge
}

"""All input for the `deleteUserMedicamentDayByNodeId` mutation."""
input DeleteUserMedicamentDayByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `UserMedicamentDay` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteUserMedicamentDay` mutation."""
input DeleteUserMedicamentDayInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: Int!
}

"""The output of our delete `UserMedicamentTime` mutation."""
type DeleteUserMedicamentTimePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `UserMedicamentTime` that was deleted by this mutation."""
  userMedicamentTime: UserMedicamentTime
  deletedUserMedicamentTimeNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """
  Reads a single `UserMedicament` that is related to this `UserMedicamentTime`.
  """
  userMedicament: UserMedicament

  """An edge for our `UserMedicamentTime`. May be used by Relay 1."""
  userMedicamentTimeEdge(
    """The method to use when ordering `UserMedicamentTime`."""
    orderBy: [UserMedicamentTimesOrderBy!] = [PRIMARY_KEY_ASC]
  ): UserMedicamentTimesEdge
}

"""All input for the `deleteUserMedicamentTimeByNodeId` mutation."""
input DeleteUserMedicamentTimeByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `UserMedicamentTime` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteUserMedicamentTime` mutation."""
input DeleteUserMedicamentTimeInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: Int!
}

"""
All input for the `deleteUserMedicamentTimeByUserMedicamentIdAndTime` mutation.
"""
input DeleteUserMedicamentTimeByUserMedicamentIdAndTimeInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  userMedicamentId: Int!
  time: Time!
}

"""The output of our `authenticate` mutation."""
type AuthenticatePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  jwt: Jwt

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""
A JSON Web Token defined by [RFC 7519](https://tools.ietf.org/html/rfc7519)
which securely represents claims between two parties.
"""
scalar Jwt

"""All input for the `authenticate` mutation."""
input AuthenticateInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  emailinput: String!
  passwordinput: String!
}

"""The output of our `authenticateadmin` mutation."""
type AuthenticateadminPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  jwt: Jwt

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the `authenticateadmin` mutation."""
input AuthenticateadminInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  emailinput: String!
  password: String!
}

"""The output of our `registeradmin` mutation."""
type RegisteradminPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  admin: Admin

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Ambulance` that is related to this `Admin`."""
  ambulance: Ambulance

  """An edge for our `Admin`. May be used by Relay 1."""
  adminEdge(
    """The method to use when ordering `Admin`."""
    orderBy: [AdminsOrderBy!] = [PRIMARY_KEY_ASC]
  ): AdminsEdge
}

"""All input for the `registeradmin` mutation."""
input RegisteradminInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  forenameinput: String!
  surnameinput: String!
  emailinput: String!
  passwordinput: String!
}

"""The output of our `registeruser` mutation."""
type RegisteruserPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  user: User

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `InsuranceCompany` that is related to this `User`."""
  insuranceCompany: InsuranceCompany

  """Reads a single `BloodType` that is related to this `User`."""
  bloodType: BloodType

  """An edge for our `User`. May be used by Relay 1."""
  userEdge(
    """The method to use when ordering `User`."""
    orderBy: [UsersOrderBy!] = [PRIMARY_KEY_ASC]
  ): UsersEdge
}

"""All input for the `registeruser` mutation."""
input RegisteruserInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  forenameinput: String!
  surnameinput: String!
  emailinput: String!
  passwordinput: String!
}
